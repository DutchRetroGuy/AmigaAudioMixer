<h1 id="audio-mixer-37-documentation">Audio Mixer 3.7 documentation</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#release-notes">Release notes</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a
href="#assemblingcompiling-the-mixer-converter-examples--tools">Assembling/compiling
the mixer, converter, examples &amp; tools</a></li>
<li><a href="#pre-processing-samples">Pre-processing samples</a></li>
<li><a href="#using-the-mixer">Using the mixer</a></li>
<li><a href="#combining-the-mixer-and-a-music-player">Combining the
mixer and a music player</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#tools">Tools</a></li>
<li><a href="#api-changes-between-version-3132-and-37">API Changes
between version 3.1/3.2 and 3.7</a></li>
<li><a href="#mixer-api">Mixer API</a></li>
<li><a href="#callback-api">Callback API</a></li>
<li><a href="#plugin-api">Plugin API</a></li>
<li><a href="#converter-api">Converter API</a></li>
<li><a href="#performance-measuring-api">Performance measuring
API</a></li>
<li><a href="#using-the-mixer-in-c-programs">Using the mixer in C
programs</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
<li><a href="#performance-data">Performance data</a></li>
<li><a href="#best-practices-for-source-samples">Best practices for
source samples</a></li>
<li><a href="#acknowledgements">Acknowledgments</a></li>
<li><a href="#licensedisclaimer">License/Disclaimer</a></li>
</ul>
<h3 id="overview">Overview</h3>
<p>The Audio Mixer is a configurable SFX engine designed to play back
multiple samples at the same time on a single hardware channel. It
achieves a high level of performance on even low end Amiga's (such as
the A500) by making use of optimised code and pre-processed samples. It
is designed to be able to co-exist with music playback routines, as long
as the music playback routine supports disabling access/playback to the
hardware channel(s) the Audio Mixer uses.</p>
<p>If desired, multiple hardware channels can be assigned to the Audio
Mixer, allowing for even more samples to be played at the same time. The
Audio Mixer supports native Amiga audio through Paula only and is
designed for use in programs that disable the OS.</p>
<h4 id="features">Features:</h4>
<ul>
<li>Up to four samples can be mixed onto a single hardware channel.</li>
<li>High performance: mixing four samples onto a single channel at 11KHz
takes only 3.7% CPU time on a 7MHz 68000 without Fast RAM.</li>
<li>Optional high quality mode that uses much more CPU time, but plays
full 8-bit samples, rather than lower quality pre-processed ones.</li>
<li>Can be run while a music playback routine is running, as long as the
music routine does not access the hardware channel(s) used by the Audio
Mixer.</li>
<li>Up to four hardware channels can be assigned to the Audio Mixer,
allowing up to 16 samples being played back at the same time.</li>
<li>Sample playback is priority based, so that drowning out of important
effects can be prevented.</li>
<li>Samples can be stored anywhere in RAM, including in Fast RAM and
Slow RAM.</li>
<li>Samples can be set to loop from either sample start, or from a given
offset into the sample and both looping/non-looping samples can be
stopped on request.</li>
<li>Samples can be assigned to one of the virtual channels the mixer
uses (up to 4 per hardware channel), allowing fine-grained control of
SFX playback.</li>
<li>Supports the use of optional plugins via a plugin system. These
plugins can either be used as control/communication mechanism to other
code, or to alter sample data in real time. There are several plugins
included and custom plugins are also supported.<br />
The included plugins are:
<ul>
<li><em>MixPluginRepeat()</em>
<ul>
<li>Plays the sample sample again after a given delay.</li>
</ul></li>
<li><em>MixPluginSync()</em>
<ul>
<li>Allows various ways to synchronise sample playback with the code
that calls the mixer.</li>
</ul></li>
<li><em>MixPluginVolume()</em>
<ul>
<li>Allows changing of the playback volume of the sample being
played.</li>
</ul></li>
<li><em>MixPluginPitch()</em>
<ul>
<li>Allows changing of the pitch of the sample being played.</li>
</ul></li>
</ul></li>
<li>Supports the use of a callback routine whenever sample playback
ends, to allow custom code to be executed on sample end. The callback
routine can immediately play back another sample if desired, which
allows for seamless sample-to-sample playback using this method.</li>
<li>Supports playback of samples of any size that will fit in RAM*.</li>
<li>Sample rate used can be configured at assembly time, using standard
Paula period values.</li>
<li>Fully PC relative code is used to make relocation as easy as
possible.</li>
<li>Optionally supports using callbacks to handle IRQ and DMA registers,
rather than the mixer doing so natively.</li>
</ul>
<p>*) in practice, this is limited by the largest maximum single block
of free RAM that exists. A system with multiple memory expansions will
be limited to a much smaller maximum sample size than the total RAM size
would seem to indicate.</p>
<h3 id="release-notes">Release Notes</h3>
<p>Release notes for the Audio Mixer</p>
<h4 id="v372">v3.7.2</h4>
<ul>
<li>(BUGFIX) MixerPlayFX channel determination fixed when MIXER_68020 is
set</li>
</ul>
<h4 id="v371">v3.7.1</h4>
<ul>
<li>(BUGFIX) MixerPlayFX, MixerPlayChannelFX, MixerPlaySample and
MixerPlayChannelSample now return the correct channel value in D0.</li>
<li>(BUGFIX) MixerPlayFX, MixerPlayChannelFX, MixerPlaySample and
MixerPlayChannelSample now store the rounded sample length back to the
MXEffect structure.</li>
<li>(BUGFIX) Tables used by MixPluginVolume have been corrected to take
into account the non-signed nature of the register offset used.</li>
</ul>
<h4 id="v37">v3.7</h4>
<ul>
<li>(NEW) The mixer.h and plugins.h file now support Bartman GCC in
addition to Bebbo and VBCC.</li>
<li>(NEW) A new C based example has been added that showcases using the
new external IRQ/DMA option to run the mixer using Amiga OS interrupt
handlers. The example is called OSLegalExample.</li>
<li>(NEW) A new example has been added that showcases the use of
external IRQ/DMA callbacks to handle IRQ and DMA registers. The example
is called ExternalIRQExample.</li>
<li>(NEW) The mixer now optionally supports using callbacks to handle
IRQ and DMA registers, rather than the mixer doing so natively. This
option allows for, amongst other things, implementing an OS-legal
interrupt server for the mixer, or implementing the mixer as part of
another API.
<ul>
<li>This option is configured to be off by default, use
MIXER_EXTERNAL_IRQ_DMA to enable it.</li>
<li>The callbacks can be set by calling MixerSetIRQDMACallbacks().</li>
</ul></li>
<li>(NEW) The mixer now supports calling a routine at the end of
interrupt processing, to allow user code to execute actions as close to
the mixer interrupt loop as possible. This option is configured to be
off by default, use MIXER_ENABLE_RETURN_VECTOR to enable it.
<ul>
<li>The vector for this routine can be set by calling
MixerSetReturnVector().</li>
</ul></li>
<li>(BUGFIX) Performance test now correctly uses 68020 routines for
68020 plugin tests.</li>
<li>(BUGFIX) Fixed a potential issue with the include guard in
mixer_config.i</li>
<li>(MAINTENANCE) mixer.asm, mixer.i, mixer.h, plugins.asm, plugins.i.
plugins.h are now kept in only one directory, their main ones. Any
duplicates needed for building the examples are now temporarily placed
in the example directories and cleaned updated afterwards.</li>
<li>(MAINTENANCE) The makefile now uses batch based copy and delete
operations where possible.</li>
<li>(MAINTENANCE) The makefile is now platform agnostic and will work on
both Windows based systems and Unix-like systems (including Linux, BSD
&amp; Mac OS X).</li>
</ul>
<h4 id="v36">v3.6</h4>
<ul>
<li>(NEW) The mixer now supports a high quality mixing mode, which does
not require pre-processed samples, but rather uses standard 8-bit
samples. Note that this mode uses significantly more CPU time.</li>
<li>(NEW) The mixer now supports the use of plugin routines which will
be called during sample playback. These routines can alter the data
being played back, or work as synchronisation/control routines for
timing and other purposes. There are several plugins provided by
default. It is also possible to create custom plugins for use with the
mixer.
<ul>
<li>The following plugins are provided:</li>
<li>MixPluginRepeat - repeats a sample after a given delay</li>
<li>MixPluginSync - sets a trigger when a given condition occurs</li>
<li>MixPluginVolume - changes the volume of the sample playing back</li>
<li>MixPluginPitch - changes the pitch of the sample playing back</li>
</ul></li>
<li>(NEW) The mixer now has the option of calling a callback function
whenever a non-looping sample ends playing.</li>
<li>(NEW) New loop mode added, MIX_FX_LOOP_OFFSET, which allows samples
to loop from an offset into the sample rather than from the start of the
sample.</li>
<li>(NEW) Added function MixerGetChannelStatus(), which returns whether
or not the given channel is in use by the mixer.</li>
<li>(NEW) Added an optional counter of number of mixer interrupts that
have executed since the counter started. Counter can be reset with
<em>MixerResetCounter()</em> and read using
<em>MixerGetCounter()</em>.</li>
<li>(NEW) A new example has been added to show HQ mode. The example is
named SingleMixerHQExample.</li>
<li>(NEW) New examples have been added to show callback and plugin use.
The examples are named CallbackExample and PluginExample.</li>
<li>(NEW) The CMixerExample has been updated to also show callback and
plugin use.</li>
<li>(NEW) The PerformanceTest has been updated to also measure
performance of callback and plugin use.</li>
<li>(DEPRECATED) The routines <em>MixerPlaySample()</em> and
<em>MixerPlayChannelSample()</em> are deprecated. They have been updated
for 3.6 with the new loop offset mode, but will not support plugins or
potential other changes in future versions of the mixer.
<ul>
<li>Replacement routines to use are <em>MixerPlayFX()</em> and
<em>MixerPlayChannelFX()</em>.</li>
<li>For compatibility with previous versions, the old functions will
remain existing as is for the forseeable future.</li>
</ul></li>
<li>(MAINTENANCE) The source directories for all examples have been
renamed to &lt;example&gt;Source and all binary examples now have a name
ending in 'Example'.</li>
<li>(MAINTENANCE) The MinimalMixer example now uses
<em>MixerPlayFX()</em> instead of <em>MixerPlaySample()</em></li>
<li>(MAINTENANCE) The code for CMixerExample has been updates to use
<em>MixerPlayFX()</em> instead of MixerPlaySample()</li>
<li>(MAINTENANCE) The code for the various functions to play samples
through the mixer has been adjusted so that most of the functionality is
handled by one shared function to increase maintainability.</li>
<li>(BUGFIX) The performance test tool now supports combined mixer
routine sizes above 64KB.</li>
<li>(BUGFIX) The performance test tool now no longer uses more sample
space than needed.</li>
<li>(BUGFIX) The performance test tool now uses samples of addequate
length, no matter the selected period.</li>
<li>(BUGFIX) The performance test tool now correctly runs 132 mixer
interrupt executions per test, rather than 132 detected vblanks as the
mixer interrupt could delay those and cause them to not be
detected.</li>
<li>(BUGFIX) The performance test tool now correctly uses the 68020
optimised interrupt handler when MIXER_68020 is set to 1</li>
<li>(BUGFIX) The various functions added to return information (such as
MixerGetBufferSize()) now always return a longword value.</li>
<li>(BUGFIX) The functions <em>MixerPlaySample()</em>,
<em>MixerPlayChannelSample()</em>, <em>MixerPlayFX()</em> and
<em>MixerPlayChannelFX()</em> now correctly save and restore register D1
to the stack.</li>
<li>(BUGFIX) If MIXER_WORDSIZED is set to 1, the mixer now correctly
uses the 2nd word of mfx_length and mfx_loop_offset in the MXEffect
structure.</li>
<li>(BUGFIX) If MIXER_SIZEXBUF is set to 1, the mixer no longer skips
the first frame of sample playback.</li>
<li>(BUGFIX) If MIXER_68020 is set to 1, the mixer no longer selects
channels above the mixer_sw_channels limit to play back samples on when
using <em>MixerPlayFX()</em> or <em>MixerPlaySample()</em>.</li>
<li>(BUGFIX) The linux/unix version of the makefile now has the correct
commands for make install &amp; make clean to work</li>
<li>(BUGFIX) The mixer makefile will no longer give a "Could not find"
error when using make clean.</li>
<li>(BUGFIX) The mixer makefile will no longer give a "1 file copied"
message when using make install.</li>
<li>(BUGFIX) The HTML version of the documentation no longer contains
any broken links.</li>
</ul>
<h4 id="v32">v3.2</h4>
<ul>
<li>(MAINTENANCE) updated mixer.h to be more compliant with the C
standard.</li>
<li>(BUGFIX) updated the way XREF and XDEF references are handled for
compatibility with vasm 1.9d and other assemblers that don't support
XREF's in the same file as the symbol definitions they reference.</li>
</ul>
<h4 id="v31">v3.1</h4>
<ul>
<li>initial release of the Audio Mixer project</li>
</ul>
<h3 id="requirements">Requirements</h3>
<p>There are three parts to the requirements for using the Audio Mixer.
The first are the requirements for assembling (and optionally compiling)
the Audio Mixer (plus examples &amp; tools), the second are the
requirements for running the mixer in a program. Both of these
requirements are listed below. Lastly, there are the requirements for
the examples and tools.</p>
<h4 id="requirements-for-assembling-the-mixer">Requirements for
assembling the mixer:</h4>
<ul>
<li>A macro assembler &amp; linker compatible with VASM style macro's
and VASM style directives (preferably VASM/VLINK).</li>
<li>The Amiga Native Development Kit (NDK). Version 1.3 or higher is
required.</li>
<li>A system with enough disk space and RAM to run the chosen assembler
and linker for the project. (note: assembly has only been tested on a PC
using cross assembly)</li>
<li>Optional, but highly recommended: make</li>
</ul>
<h4
id="optional-requirements-for-compiling-the-included-c-programs">Optional
requirements for compiling the included C programs:</h4>
<ul>
<li>All requirements for assembling the mixer.</li>
<li>A C compiler capable of generating Amiga OS executables for systems
based on the 68000 series of processors.</li>
</ul>
<p>If you require an assembler, linker or compiler to assemble/compile
the provided source, VASM/VLINK and VBCC can be found here:</p>
<ul>
<li>VASM - <a
href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a></li>
<li>VLINK - <a
href="http://sun.hasenbraten.de/vlink/">http://sun.hasenbraten.de/vlink/</a></li>
<li>VBCC - <a
href="http://sun.hasenbraten.de/vbcc/">http://sun.hasenbraten.de/vbcc/</a></li>
</ul>
<p>Note that VBCC includes VASM/VLINK, as well as make and the Amiga NDK
3.9.</p>
<p>Also note that other assemblers, linkers and compilers should also be
capable of assembling/compiling the provided source, though some changes
to the makefile and/or assembler options might be needed.</p>
<h4 id="requirements-for-running-the-mixer">Requirements for running the
mixer:</h4>
<ul>
<li>An Amiga* with at least Kickstart 1.3 and some Chip Memory**</li>
</ul>
<h4 id="requirements-for-running-the-examples--tools">Requirements for
running the examples &amp; tools:</h4>
<ul>
<li>An Amiga* with at least Kickstart 1.3, 512KB of Chip RAM and an
additional 512KB of any RAM (Chip, Fast or Slow RAM).</li>
</ul>
<p>Note that the Audio Mixer is designed for programs that disable the
OS and directly access the custom chip set. The code is compatible with
both 68000 and higher processors*. Keep in mind that certain systems***
can have issues running code that disables the OS.</p>
<p>For reference, the mixer has successfully been tested on the
following:</p>
<ul>
<li>WinUAE emulating various systems, all running in Cycle Exact
mode<br />
(not tested using JIT or "fastest possible" configurations)</li>
<li>A500/A600 with 68000@7MHz and varying amounts of Chip/Slow/Fast
RAM</li>
<li>A600 with 68030@25MHz and 32MB of Fast RAM</li>
<li>A1200 with 68020@14MHz</li>
<li>A1200 with 68020@14MHz/8MB Fast RAM</li>
<li>A1200 with 68030@50MHz/16MB Fast RAM</li>
</ul>
<p>Further, the mixer has been reported to successfully work on:</p>
<ul>
<li>A500 with ACA+@42MHz</li>
<li>Various 68030 based systems</li>
<li>An A1200 with a TF1260 accelerator</li>
</ul>
<p>*) This should include emulators &amp; FPGA systems, as long as these
systems include accurate emulation/re-creation of the Amiga Chip Set,
68000 and certain Kickstart functionality. Compatibility with FPGA
systems is not guaranteed.</p>
<p>**) Exact required amount depends on the size of the samples and rest
of the program. The mixer itself requires about 4-8KB of any RAM for
code &amp; variables and about 0.5-8KB of Chip RAM for mixing buffers
(these values depends on the number of hardware channels configured and
the chosen period value)</p>
<p>***) In particular, Amiga systems that are highly expanded sometimes
include expansions that are incompatible with software that takes over
the system, such as network cards that rely on the NMI interrupt. On
such systems, extra steps might be needed. Such as disabling the network
prior to running the code or using a wrapper such as WHDLoad.</p>
<h3 id="configuration">Configuration</h3>
<p>In order to reach high performance, the Audio Mixer needs to be
configured at assembly time, rather than at runtime. This is done using
the mixer_config.i file, which contains all but one of the configurable
options for the mixer. Options in this file can't be changed at runtime.
The only option that can be changed at runtime is the system's video
type (PAL/NTSC).</p>
<p>The configuration consists of six sections. In the first section, the
mixer type is selected. In the second, the playback mode is selected. In
the third section, the mixer playback settings are selected. In the
fourth section various optimisation settings can be enabled or disabled.
The fifth section selects performance measurement options and the sixth
section sets advanced options.</p>
<ol type="1">
<li><h4 id="mixer-type">Mixer type</h4>
<ul>
<li><p>The mixer can run in one of three ways. In the mixer type
selection section, the desired playback type is selected. The three
types are:</p>
<ul>
<li>MIXER_SINGLE</li>
<li>MIXER_MULTI</li>
<li>MIXER_MULTI_PAIRED</li>
</ul>
<p>The first type, <em>MIXER_SINGLE</em>, uses a single hardware channel
to play back mixer output on. It allows up to 4 samples to be mixed at
the same time onto the selected channel.</p>
<p>The second type, <em>MIXER_MULTI</em>, uses multiple hardware
channels to play back mixer output on. Each of these hardware channels
can have its own set of samples mixed onto it. In total, this mode
allows up to four hardware channels to be selected, each of which can
play back up to 4 samples mixed together (for a total of up to 16
samples played back at the same time).</p>
<p>The third type, <em>MIXER_MULTI_PAIRED</em>, is similar to
<em>MIXER_MULTI</em> in that it uses multiple hardware channels to play
back mixer output on. However, unlike <em>MIXER_MULTI</em>, two of the
four hardware channels are paired. The paired channels will always play
back the same output from the mixer. The result is that the paired
channel is effectively playing back on both the left and the right
speaker at the same time, creating a centred output.</p>
<p>In <em>MIXER_MULTI_PAIRED</em> type AUD2 and AUD3 are used to create
the centred channel. As such both of these channels must always be
selected. The other two hardware channels can optionally also be
selected and will act as though running in <em>MIXER_MULTI
type</em>.</p>
<p>To select which type to use, change the desired equate to 1 and set
the others to 0. For example, to set up for <em>MIXER_SINGLE</em> type,
set up this section of the mixer_config.i file as follows:</p>
<pre><code>MIXER_SINGLE         EQU 1
MIXER_MULTI          EQU 0
MIXER_MULTI_PAIRED   EQU 0</code></pre></li>
</ul></li>
<li><h4 id="mixer-mode">Mixer mode</h4>
<ul>
<li><p>The mixer supports two modes of playback. In the mixer mode
selection section, the desired mode is selected.</p>
<pre><code>MIXER_HQ_MODE        EQU 0</code></pre>
<p>Setting the value for <em>MIXER_HQ_MODE</em> to 1 enables the high
quality playback mode. This mode does not require pre-processed samples,
but rather plays back standard 8-bit samples. Enabling this mode costs
much more CPU time, but does allow higher quality playback.</p></li>
</ul></li>
<li><h4 id="mixer-playback-settings">Mixer playback settings</h4>
<ul>
<li><p>In order to correctly play back samples, the mixer playback
settings need to be configured. The values that need to be set up
are:</p>
<ul>
<li>mixer_output_channels</li>
<li>mixer_sw_channels</li>
<li>mixer_period</li>
<li>MIXER_PER_IS_NTSC</li>
</ul>
<p><em>mixer_output_channels</em> configures which hardware channel(s)
the mixer will use for output. When <em>MIXER_SINGLE</em> is set to 1,
only one channel can be selected, otherwise multiple channels can be
selected. Channel selection is done using the standard DMA flag
indicators: DMAF_AUD0...DMAF_AUD3.</p>
<p>Note that when <em>MIXER_MULTI_PAIRED</em> is set to 1, at least
DMAF_AUD2 and DMAF_AUD3 must be selected.</p>
<p>To select which channels to use, change the equate to the desired
hardware channels, combining multiple channels using the or operator.
For example:</p>
<pre><code>mixer_output_channels   EQU DMAF_AUD2|DMAF_AUD3</code></pre>
<p><em>mixer_sw_channels</em> selects the maximum number of software
mixed voices the mixer will use. This can be set at any value in the
range of 1 to 4. Selecting fewer channels will reduce the maximum number
of samples that can be mixed together. It will also lower CPU overhead
of the mixer and will allow for samples with higher maximum / minimum
amplitude values to be used (this in turn makes the samples sound less
quiet/have a higher dynamic range).</p>
<p>See <a href="#pre-processing-samples">"Pre-processing samples"</a>
for more information on the topic of maximum / minimum amplitude
values.</p>
<p>To select the number of software mixed voices, change the equate to
the desired number. For example:</p>
<pre><code>mixer_sw_channels   EQU 4</code></pre>
<p><em>mixer_period</em> sets the period value used by Paula for playing
back the mixer output. The value is limited by the normal limits for
Paula for 15KHz display modes. The supported range is 124* to 65535. For
completeness, a lower value corresponds to a higher sample rate.</p>
<p>Selecting a lower period will increase mixer CPU overhead compared to
a higher period. To select the period, change the equate to the desired
period value. For example, to set the mixer to play back at ~11KHz set
the value to:</p>
<pre><code>mixer_period   EQU 322</code></pre>
<p>*) PAL limit. The NTSC limit is 123.</p>
<p><em>MIXER_PER_IS_NTSC</em> is a flag that can be set if the period
value set in <em>mixer_period</em> assumes an NTSC system. This flag is
separate from the runtime video system selection that can be provided
during mixer setup. It is only used to determine in which direction the
PAL/NTSC period value conversion should operate.</p></li>
</ul></li>
<li><h4 id="optimisation-options">Optimisation options</h4>
<ul>
<li><p>The mixer offers a variety of different optimisation options that
can be set to improve the performance of the mixer (usually in exchange
for one or more tradeoffs). Some of these options have a larger effect,
some have a smaller effect and some only change the performance in
certain edge cases.</p>
<p>By default all these options are disabled. Unless otherwise noted,
options can be combined for potentially greater gains. The available
options are:</p>
<ul>
<li>MIXER_68020</li>
<li>MIXER_WORDSIZED</li>
<li>MIXER_SIZEX32</li>
<li>MIXER_SIZEXBUF</li>
</ul>
<p>The option <em>MIXER_68020</em> can be set to 1 to change code
generation to be optimised for 68020+ based systems. It improves
performance on such systems, by making more effective use of the cache.
Setting it also reduces object size and significantly reduces
performance on 68000/68010 based systems.</p>
<p>(note that the mixer will still run on 68000 based systems even when
this option is set to 1).</p>
<p>To enable the option, set the equate to 1:</p>
<pre><code>MIXER_68020   EQU 1</code></pre>
<p>NOTE: Setting this option to 1 disables *all* other optimisation
options.</p>
<p>The option <em>MIXER_WORDSIZED</em> can be set to 1 to limit the
maximum sample size to be one unsigned word (64KB). If set to 0, sample
length is limited to a signed long value (~2GB). Setting this option to
1 provides a small increase in performance by changing some operations
to be word sized.</p>
<p>To enable the option, set the equate to 1:</p>
<pre><code>MIXER_WORDSIZED   EQU 1</code></pre>
<p>The option <em>MIXER_SIZEX32</em> can be set to 1 to force the mixer
to only process samples in blocks of 32 bytes. This can provide a small
performance boost when playing several small looping samples at the same
time. In normal use the performance increase is negligible.</p>
<p>To enable the option, set the equate to 1:</p>
<pre><code>MIXER_SIZEX32   EQU 1</code></pre>
<p>NOTE: setting this option to 1 requires all samples to be a multiple
of 32 bytes in length, rather than the standard 4 bytes.</p>
<p>The option <em>MIXER_SIZEXBUF</em> can be set to 1 to force the mixer
to only process samples in blocks of the <em>mixer_PAL_buffer_size</em>
or <em>mixer_NTSC_buffer_size</em> (depending on which video system is
selected at runtime. This value is calculated in mixer.i), which is to
say in blocks of 1/50th or 1/60th of a second. Setting this option to 1
results in an increase in performance at the cost of sample size
flexibility.</p>
<p>To enable the option, set the equate to 1:</p>
<pre><code>MIXER_SIZEXBUF   EQU 1</code></pre>
<p>NOTE: setting this option to 1 requires all samples to be a multiple
of <em>mixer_PAL_buffer_size</em> or <em>mixer_NTSC_buffer_size</em> in
length (depending on the selected video system), rather than the
standard 4 bytes.</p></li>
</ul></li>
<li><h4 id="performance-measurement-options">Performance measurement
options</h4>
<ul>
<li><p>The mixer has several options to help programmers to measure the
performance of the chosen settings. The available options are:</p>
<ul>
<li>MIXER_TIMING_BARS</li>
<li>MIXER_DEFAULT_COLOUR</li>
<li>MIXER_CIA_TIMER</li>
<li>MIXER_CIA_KBOARD_RES</li>
<li>MIXER_COUNTER</li>
</ul>
<p>Setting <em>MIXER_TIMING_BARS</em> to 1 changes the behaviour of the
mixer to show CPU time used by changing colour 0 to various different
colours based on what the mixer is currently doing. This allows
programmers to visualise the impact of the mixer on the system.</p>
<p>The colours used are:</p>
<ul>
<li><p>$B0B (bright magenta) =&gt; Interrupt handler<br />
This colour denotes the overhead for the interrupt handler, such as
stack operations, interrupt acknowledgement and Paula register
writes.</p></li>
<li><p>$909 (magenta) =&gt; Channel update<br />
This colour denotes the overhead for the selection of samples to be
mixed during the current interrupt.</p></li>
<li><p>$707 (dark magenta) =&gt; Mixing<br />
This colour denotes the time spent on mixing the samples.</p></li>
<li><p>$099 (cyan) =&gt; Other<br />
This colour is used for mixer routines that are expected to be called
frequently, but are not part of the interrupt handler. This includes the
various routines to play back and/or stop samples.</p></li>
</ul>
<p>To enable this option, set the equate to 1:</p>
<pre><code>MIXER_TIMING_BARS   EQU 1</code></pre>
<p>The setting <em>MIXER_DEFAULT_COLOUR</em> changes which colour the
mixer will use when it reaches the end of a routine or interrupt.
Changing this allows for better integration with existing graphics.</p>
<p>To select a colour, set the equate to the desired hexadecimal colour
value:</p>
<pre><code>MIXER_DEFAULT_COLOUR   EQU $456</code></pre>
<p>Note that this option only has an effect if
<em>MIXER_TIMING_BARS</em> is set to 1.</p>
<p>Setting <em>MIXER_CIA_TIMER</em> to 1 enables the use of CIA-A timer
A to measure performance of the mixer interrupt handler (which includes
the mixing of samples). Note that for correct measuring of performance,
it's recommended no higher priority* interrupts are allowed to fire,
otherwise the results will be skewed.</p>
<p>*) The mixer uses audio interrupts, which run at level 4. This means
interrupts at level 5+ can interrupt the mixer and skew results of the
measurements.</p>
<p>The CIA timer will be used to generate several values (include via
mixer.i):</p>
<ul>
<li><p><em>mixer_ticks_last</em><br />
This word will contain the number of CIA timer ticks the last mixer
interrupt took to complete.</p></li>
<li><p><em>mixer_ticks_best</em><br />
This word will contain the best (=lowest) number of CIA timer ticks the
mixer interrupt took to complete since start. In most cases, this
represents the time an idle interrupt takes (one where no sample is
playing)</p></li>
<li><p><em>mixer_ticks_worst</em><br />
This word will contain the worst (=highest) number of CIA timer ticks
the mixer interrupt took since start.</p></li>
<li><p><em>mixer_ticks_average</em><br />
This word is initially filled with 0, but can be updated by calling the
routine <em>MixerCalcTicks()</em> (included from mixer.i). After this
routine is called, this word will contain the average number of CIA
timer ticks the mixer interrupt took over the last 128 frames.</p></li>
</ul>
<p>To enable this option, set the equate to 1:</p>
<pre><code>MIXER_CIA_TIMER   EQU 1</code></pre>
<p>NOTE: setting this option to 1 assumes CIA-A timer A is available for
use.<br />
NOTE: the routine <em>MixerCalcTicks()</em> and the values
mixer_ticks_last/best/ worst/average are only available if this option
is set to 1. NOTE: this option should not be enabled if
MIXER_EXTERNAL_IRQ_DMA is set with the goal of using Amiga OS interrupt
handlers for the mixer interrupt.</p>
<p>The option <em>MIXER_CIA_KBOARD_RES</em> is used to restore the
keyboard for Amiga OS if <em>MIXER_CIA_TIMER</em> is set to one and
<em>MixerRemoveHandler()</em> is called. If this option is not set, the
CIA-A timer will merely be stopped. If this option is set, the CIA-A
timer registers and control register A will be set such that the
keyboard will function correctly in the OS.</p>
<p>To correctly use this feature, call <em>MixerRemoveHandler()</em> as
the last thing prior to re-enabling the OS.</p>
<p>To enable this option, set the equate to 1:</p>
<pre><code>MIXER_CIA_KBOARD_RES   EQU 1</code></pre>
<p>NOTE: this option is only valid if <em>MIXER_CIA_TIMER</em> is set to
one.<br />
NOTE: if this option is not set, but <em>MIXER_CIA_TIMER</em> is set to
one and the program returns to the OS, the keyboard may lose
functionality (depending on the OS version and Amiga keyboard type).</p>
<p>If the program never returns to the OS, or runs via WHDLoad, this
setting is not required.</p>
<p>The option <em>MIXER_COUNTER</em> can be used to enable a built in
counter, which counts the number of mixer interrupts that has been
executed. This can be useful, since mixer interrupts occur at roughly
1/50th or 1/60th of a second, but not quite once per frame. The counter
maintained is word sized and can be accessed using the functions
<em>MixerResetCounter()</em> and <em>MixerGetCounter()</em></p>
<p>To enable the counter, set the equate to 1:</p>
<pre><code>MIXER_COUNTER          EQU 1</code></pre></li>
</ul></li>
<li><h4 id="advanced-options">Advanced options</h4>
<ul>
<li><p>The mixer provides three advanced settings which may be of use
for some users. Options provided are:</p>
<ul>
<li>MIXER_ENABLE_CALLBACK</li>
<li>MIXER_ENABLE_PLUGINS</li>
<li>MIXER_ENABLE_RETURN_VECTOR</li>
<li>MIXER_SECTION</li>
<li>MIXER_EXTERNAL_IRQ_DMA</li>
<li>MIXER_EXTERNAL_BITWISE</li>
<li>MIXER_EXTERNAL_RTE</li>
<li>MIXER_NO_ECHO</li>
<li>MIXER_C_DEFS</li>
</ul>
<p>The option <em>MIXER_ENABLE_CALLBACK</em> can be used to enable
support for callback routines. Callback routines are automatically
called whenever any sample ends playback naturally (but not when
playback is stopped manually). Enabling this option has a small CPU
overhead cost.</p>
<p>The routines <em>MixerEnableCallback()</em> and
<em>MixerDisableCallback()</em> are used to set and remove a callback
function respectively. See the <a href="#callback-api">Callback API</a>
for more information about callback routines.</p>
<p>To enable callback routine support, set the equate to 1:</p>
<pre><code>MIXER_ENABLE_CALLBACK   EQU 1</code></pre>
<p>The option <em>MIXER_ENABLE_PLUGINS</em> can be used to enable
support for running plugins. Plugins are routines that are executed by
the mixer whenever a mixer interrupt occurs and a sample with an
attached plugin is being mixed. Plugin routines can be used to
non-destructively alter sample contents to change what is played back,
to play back new samples when certain situations occur and to
communicate information (such as timing information) to code outside of
the mixer. See the <a href="#plugin-api">Plugin API</a> for more
information.</p>
<p>Enabling plugin support has a small CPU overhead cost. The plugin
routines themselves can add significant CPU overhead if they
non-destructively alter sample contents. Apart from built-in plugins,
the system also supports custom plugins.</p>
<p>To enable plugin support, set the equate to 1:</p>
<pre><code>MIXER_ENABLE_PLUGINS    EQU 1</code></pre>
<p>The option <em>MIXER_ENABLE_RETURN_VECTOR</em> can be used to enable
calling a routine at the end of the mixer interrupt handler.</p>
<p>Enabling return vector support has a small CPU overhead cost. In
addition, the routine called will also add to the interrupt
overhead.</p>
<p>To enable return vector support, set the equate to 1:</p>
<pre><code>MIXER_ENABLE_RETURN_VECTOR    EQU 1</code></pre>
<p>The option <em>MIXER_SECTION</em> can be used to disable adding the
mixer to section code,code. By default this option is set to 1 and the
mixer is added to section code,code. If set to 0, the mixer is not added
to any section.</p>
<p>To enable this option, set the equate to 1:</p>
<pre><code>MIXER_SECTION   EQU 1</code></pre>
<p>NOTE: normally, this setting should not be changed. But in certain
situations it can be useful to not utilise sections. In those cases, set
the value to 0.</p>
<p>The option <em>MIXER_EXTERNAL_IRQ_DMA</em> can be used to enable
external handling of the INTENA, INTREQ and DMACON registers. In
addition it also enables setting the interrupt handler vector. If this
setting is enabled, these tasks will be given to callbacks the mixer
will call when needed. Setting up these callbacks is done through the
MixerSetIRQDMACallbacks() function. See the <a href="#mixer-api">"Mixer
API"</a> for more information.</p>
<p>Enabling external IRQ and DMA support has a small CPU overhead
cost.</p>
<p>To enable external IRQ and DMA support, set the equate to 1:</p>
<pre><code>MIXER_EXTERNAL_IRQ_DMA    EQU 1</code></pre>
<p>The option <em>MIXER_EXTERNAL_BITWISE</em> can be used to enable the
mixer IRQ &amp; DMA callback support to only set one bit per callback.
This option is only available if MIXER_EXTERNAL_IRQ_DMA is set to 1.</p>
<p>Enabling bitwise operations has a small CPU overhead cost.</p>
<p>To enable bitwise operations, set the equate to 1:</p>
<pre><code>MIXER_EXTERNAL_BITWISE    EQU 1</code></pre>
<p>The option <em>MIXER_EXTERNAL_RTE</em> can be used to change the
behaviour of the MIXER_EXTERNAL_IRQ_DMA setting. Normally, this will
cause the mixer interrupt to end in an RTS instruction. Setting this
option to 1 changes that to be an RTE. This option is only available if
MIXER_EXTERNAL_IRQ_DMA is set to 1.</p>
<p>To enable external RTE support, set the equate to 1:</p>
<pre><code>MIXER_EXTERNAL_RTE    EQU 1</code></pre>
<p>The option <em>MIXER_NO_ECHO</em> can be set to 1 to disable the use
of the "echo" directive to display certain messages during assembly. Not
all assemblers support the use of the "echo" directive and with this
option such assemblers might still be usable.</p>
<p>To enable this option, set the equate to 1:</p>
<pre><code>MIXER_NO_ECHO   EQU 1</code></pre>
<p>The option <em>MIXER_C_DEFS</em> can be set to 1 to enable C style
function definition aliases. This allows C compilers to link the mixer.o
file correctly. If disabled, these aliases are not created and linking
mixer.o in C programs will likely fail.</p>
<p>To enable this option, set the equate to 1:</p>
<pre><code>MIXER_C_DEFS            EQU 1</code></pre></li>
</ul></li>
</ol>
<h3
id="assemblingcompiling-the-mixer-converter-examples--tools">Assembling/compiling
the mixer, converter, examples &amp; tools</h3>
<p>The Audio Mixer consists of the mixer itself, an example sample
conversion routine, plus examples and tools. All of these are provided
in the form of the source code in 68000 assembly. The source code has
been written for use with VASM/VLINK or assemblers/linkers that are
compatible with VASM/VLINK directives. The Audio Mixer also comes with
two C programs, one to show how integration with the assembly routines
works and one tool to pre-process samples. The C source code has been
compiled and tested using VBCC with an Amiga OS 1.3 target.</p>
<p>For convenience, the package is distributed with binary versions of
the examples and tools. These binary versions have been made using the
default configuration of 4 channel mixing (per hardware channel) and an
11KHz sample rate. No optimisation options have been enabled.</p>
<p>In order to assemble, compile and/or link the provided source code, a
makefile has been supplied. Before using the makefile, four variables in
the makefile must be configured. These variables are:</p>
<ul>
<li><p>INSTLOC<br />
Set this variable to the directory you wish to install the examples and
the mixer/converter objects to. The makefile will attempt to create this
directory if it doesn't exist. It will do the same for one or more
subdirectories in this directory.</p></li>
<li><p>LIBS<br />
Set this variable to the directory that contains the Amiga library from
the Amiga NDK (v1.3+)</p></li>
<li><p>SYSTEMDIR<br />
Set this variable to the directory that contains the Amiga NDK (1.3+)
assembly include files.</p></li>
<li><p>COMPILE_C<br />
Set this variable to 1 to enable compiling the C programs</p></li>
</ul>
<p>This makefile has several different options:</p>
<ul>
<li><p>make<br />
assembles all objects and links the examples/tools</p></li>
<li><p>make install<br />
assembles all objects and links the examples/tools. Also copies the
result to the configured installation directory</p></li>
<li><p>make mixer<br />
assembles only the mixer &amp; converter object files</p></li>
</ul>
<p>Note that the makefile uses VASM &amp; VLINK and assumes both are in
the current path (as vasmm68k_mot and vlink respectively). Also note
that the makefile uses VBCC as it's C compiler.</p>
<p>For those who wish to manually assemble/compile, make sure to keep in
mind that the examples/tools have a variety of dependencies you'll have
to also assemble. On top of the internal dependencies, the mixer,
examples and tools also have the Amiga NDK (1.3+) as a dependency.</p>
<p>The order of linking for the assembly examples/tools should be
PhotonsMiniWrapper.o first, everything else after that (this goes for
each assembly language example/tool).</p>
<p>Assembling the mixer &amp; converter object files should be simpler
as the list of dependencies is limited to the NDK (1.3+) and the files
in the mixer or converter directory itself.</p>
<p>When assembling (parts) of the mixer code manually, it's important to
note that various files require a specific symbol to be set when
assembling them. This symbol should not be set when assembling different
files. The full list of symbols and what file needs which symbol can be
found in the makefile.</p>
<p>Setting these symbols can normally be done as a (command line) option
for the assembler.</p>
<p>As an example, assembling mixer.asm requires the symbol BUILD_MIXER
to be set. If VASM is being used, this is done by specifying
-DBUILD_MIXER as one of the command line parameters. For reference, the
full VASM command line used to build the mixer object file is as
follows:</p>
<pre><code>vasmm68k_mot -nowarn=62 -kick1hunks -Fhunk -m68000 -allmp -I. -IC:\Development\AmigaDev\NDK13\INCLUDES1.3\INCLUDE.I -I.\Mixer -DBUILD_MIXER .\Mixer\mixer.asm -o .\Mixer\mixer.o</code></pre>
<p>The supplied makefile has been created for use under Windows. A
version for systems using UNIX style commands and directories is also
supplied, as makefile_unix.mak.</p>
<h3 id="pre-processing-samples">Pre-processing samples</h3>
<p>The mixer requires pre-processed samples in order to play back mixed
sound correctly*. The pre-processing consists of two steps: making sure
the samples are of the correct length to be mixed and making sure the
sample data does not exceed minimum/maximum values for the number of
samples to be mixed at the same time.</p>
<p>*) when the mixer is run in the high quality mode, sample
pre-processing is limited to merely making sure the samples meet the
length requirements. No limits on sample data values exist. In this
case, step "Sample data minimum/maximum values" of the steps below can
be skipped.</p>
<p>A detailed description of both steps follows.</p>
<ol type="1">
<li><h4 id="sample-length-requirements">Sample length requirements</h4>
<p>The mixer will always process samples in a multiple of a minimum
number of bytes. The consequence of this is that samples provided to the
mixer must also be a multiple of that minimum number of bytes in length.
The minimum length multiple required depends on the configuration as set
up in mixer_config.i.</p>
<ul>
<li>If no optimisation options are enabled, samples must be a multiple
of 4 bytes in length.</li>
<li>If <em>MIXER_68020</em> is set to 1, samples must be a multiple of 4
bytes in length. Setting <em>MIXER_68020</em> to 1 overrides all other
optimisation flags, so this value will not change depending on other set
flags.</li>
<li>If <em>MIXER_SIZEX32</em> is set to 1, samples must be a multiple of
32 bytes in length.</li>
<li>If <em>MIXER_SIZEXBUF</em> is set to 1, samples must be a multiple
of either <em>mixer_PAL_buffer_size</em> or
<em>mixer_NTSC_buffer_size</em> in length, depending on the video system
selected during <em>MixerSetup()</em>.</li>
<li><em>MIXER_SIZEX32</em> and <em>MIXER_SIZEXBUF</em> can be selected
at the same time, in which case both limitations apply (i.e. the
<em>mixer_PAL_buffer_size</em> / <em>mixer_NTSC_buffer_size</em> must
now also be a multiple of 32 bytes).</li>
</ul>
<p>The mixer offers a routine (<em>MixerGetSampleMinSize()</em>) to get
the minimum number of bytes that samples must be a multiple in length
of.</p>
<p>The easiest way to make sure samples are of the correct length is to
pad them with zeroes to the required minimum multiple length. Note that
this will work even in the case of <em>MIX_SIZEXBUF</em> and supporting
both PAL and NTSC, as <em>mixer_PAL_buffer_size</em> will always be
larger than <em>mixer_NTSC_buffer_size</em> for any possible
configuration.</p>
<p>This means that the easiest way to deal with <em>MIXER_SIZEXBUF</em>
in a program that supports both PAL and NTSC is to pad the samples with
zeroes to a multiple of <em>mixer_PAL_buffer_size</em>.</p></li>
<li><h4 id="sample-data-minimummaximum-values">Sample data
minimum/maximum values</h4>
<p>For performance reason, the mixer does no range or overflow checking
on any samples it adds. This means that samples that are not limited to
a certain range of values can create over/underflows. These
over/underflows create very audible and very ugly distortions of sound.
To prevent this, the mixer requires all sample data points to be kept in
a range that allows them to be added together under all circumstances
without generating over/ underflow.</p>
<p>The limits are based directly on the maximum number of samples mixed
together (as set in mixer_config.i):</p>
<ul>
<li>if <em>mixer_sw_channels</em>=1, the range is -128 to +127 (sample
bytes/1)</li>
<li>if <em>mixer_sw_channels</em>=2, the range is -64 to +63 (sample
bytes/2)</li>
<li>if <em>mixer_sw_channels</em>=3, the range is -43 to +42 (sample
bytes/3)</li>
<li>if <em>mixer_sw_channels</em>=4, the range is -32 to +32 (sample
bytes/4)</li>
</ul>
<p>All samples used by the mixer should only have data points in the
value ranges given above. It should be pointed out that this
pre-processing will have an effect on the volume of the samples played
back. The higher the number of channels that can be mixed, the quieter
the samples will sound.</p>
<p>It is highly recommended to keep this in mind for both the samples to
be used and any/all music that will be played alongside the samples
played back using the mixer. Choosing the correct HW volume for any
module playing back is an important part of making the mixer output
sound best.</p>
<p>For more information on how to get good quality samples for use with
the mixer, see <a href="#best-practices-for-source-samples">"Best
practices for source samples"</a>.</p></li>
</ol>
<p>The mixer provides both a tool (SampleConverter) and an assembly
routine (<em>ConvertSampleDivide()</em>) to aid in pre-processing
samples. Both of these are also described in the documentation. See <a
href="#tools">"Tools"</a> and <a href="#converter-api">"Converter
API"</a> for more details.</p>
<p>Note that using these specific options is not required, it's
certainly possible to create a separate converter (for example one that
does bulk conversion) for this purpose, or to generate the initial
samples such that they already conform to the requirements.</p>
<p>Indeed, the assembly routine provided is quite slow due to the
byte-by-byte lookup that it needs to do for the conversion, so
pre-processing samples at or before assembly/compile time is recommended
for projects that include many samples.</p>
<h3 id="using-the-mixer">Using the mixer</h3>
<p>After configuring and assembling the mixer, the resulting object file
(mixer.o) can be linked into other programs to provide the mixer API (as
described in <a href="#mixer-api">"Mixer API"</a>).</p>
<p>In order to use the mixer, several steps need to be taken. A basic
example follows (in Assembly and C). The example assumes
<em>MIXER_SINGLE</em> is set to 1 and callback routines &amp; plugins
are disabled (<em>MIXER_ENABLE_CALLBACK</em> &amp;
<em>MIXER_ENABLE_PLUGINS</em> are both set to 0).</p>
<p>Note: while initially setting up the mixer, it can be useful to set
<em>MIXER_TIMING_BARS</em> to 1 in mixer_config.i to have a visual
representation of the mixer working (or not working if something went
wrong).</p>
<ol type="1">
<li><h4 id="allocatereserve-a-block-of-chip-ram">Allocate/reserve a
block of Chip RAM</h4>
<p>This block has to be equal in size to the value of
<em>mixer_buffer_size</em> as found in mixer.i*.</p>
<p>*) the mixer provides the support routine
<em>MixerGetBufferSize()</em> to get the correct size if using mixer.i
is not desired. <em>MixerGetBufferSize()</em> returns the correct size
in D0.</p>
<pre><code>   Assembly:                                C:
   move.l   #mixer_buffer_size,d0           size = MixerGetBufferSize();
   ; allocate memory using the above size   /* allocate memory here */
   ; alternatively, use a block of memory
   ; defined in a Chip RAM section of this
   ; size.</code></pre></li>
<li><h4 id="set-up-the-mixer">Set up the mixer</h4>
<p>This is done by calling the routine <em>MixerSetup()</em>, with the
current video system and the block of allocated Chip RAM from step one
as parameters.</p>
<pre><code>   Assembly:                                C:
   ; Pointer to Chip RAM block in A0        /* buffer points to Chip RAM
   moveq   #MIX_PAL,d0                         block */
   bsr     MixerSetup                       MixerSetup(buffer, NULL, NULL, MIX_PAL, 0);</code></pre></li>
<li><h4 id="start-the-interrupt-handler">Start the interrupt
handler</h4>
<p>This is done by calling the routine <em>MixerInstallHandler()</em>.
This routine requires the value of the Vector Base Register (VBR)* and a
flag that tells the routine whether or not to save the pre-existing
interrupt vectors to be able to restore them later when the handler is
removed.</p>
<p>Note that the value of the flag to save the vectors is 0 and to not
save the vectors is 1.</p>
<p>*) this is always 0 on 68000 based systems, but on systems with a
68010 or higher this value can be different (this is especially true on
systems with a 68030+, which usually remap the VBR to Fast RAM for
improved performance).</p>
<pre><code>   Assembly:                                C:
   ; VBR value in A0                        /* VBR value in vbr */
   moveq   #0,d0                            MixerInstallHandler(vbr, 0);
   bsr     MixerInstallHandler</code></pre></li>
<li><h4 id="start-the-mixer">Start the mixer</h4>
<p>This is done by calling the routine <em>MixerStart()</em></p>
<pre><code>   Assembly:                                C:
   bsr      MixerStart                      MixerStart();</code></pre></li>
<li><h4
id="the-mixer-is-now-running-sfx-can-now-be-played-back-using-one-of-the-playback-routines">The
mixer is now running, SFX can now be played back using one of the
playback routines</h4>
<p>These routines include <em>MixerPlayFX()</em>. To use
<em>MixerPlayFX()</em> as an example, this routine has 2 parameters:</p>
<ol type="1">
<li>Pointer to an instance of the MXEffect structure in A0</li>
<li>The hardware channel to use in D0, or 0 if mixer_config.i has
<em>MIXER_SINGLE</em> set to 1.</li>
</ol>
<p>The MXEffect structure needs to have the following members filled for
basic sample playback:</p>
<ul>
<li>mfx_length<br />
The length of the sample to play</li>
<li>mfx_sample_ptr<br />
Pointer to the (pre-processed) sample to play</li>
<li>mfx_loop<br />
The loop indicator. Either <em>MIX_FX_ONCE</em> to play back a sample
once, <em>MIX_FX_LOOP</em> to play back a sample in a loop forever or
<em>MIX_FX_LOOP_OFFSET</em> to play back a sample looping back to a
given loop offset forever.</li>
<li>mfx_priority<br />
The priority of the sample - higher priority samples can overwrite
already playing lower priority samples if needed.</li>
<li>mfx_loop_offset<br />
Set to the desired offset into the sample when
<em>MIX_FX_LOOP_OFFSET</em> is used, leave 0 otherwise.</li>
<li>mfx_plugin_ptr leave at 0 (NULL for C programs)</li>
</ul>
<p><em>MixerPlayFX()</em> returns the mixer channel used in D0, or -1 if
no free channel can be found.</p>
<pre><code>   Assembly:
   lea.l   effect_struct,a0               ; Assumed to be a block of memory
                                          ; mfx_SIZEOF bytes in length.
   move.l  #sample_length,mfx_length(a0)
   move.l  sample,mfx_sample_ptr(a0)
   move.w  #MIX_FX_ONCE,mfx_loop(a0)
   move.w  #1,mfx_priority(a0)
   clr.l   mfx_loop_offset(a0)
   clr.l   mfx_plugin_ptr(a0)
   moveq   #0,d0                          ; Channel can be left 0 when using
                                          ; MIXER_SINGLE
   
   C:
   MXEffect effect_struct;

   effect_struct.mfx_length = sample_length;
   effect_struct.mfx_sample_ptr = sample;
   effect_struct.mfx_loop = MIX_FX_ONCE;
   effect_struct.mfx_priority = 1;
   effect_struct.mfx_loop_offset = 0;
   effect_struct.mfx_plugin_ptr = NULL;

   MixerPlayFX(&amp;effect_struct, 0); /* Channel can be left 0 when using 
                                      MIXER_SINGLE */</code></pre></li>
<li><h4 id="if-desired-sample-playback-on-a-channel-can-be-stopped">If
desired, sample playback on a channel can be stopped</h4>
<p>This is done by calling the <em>MixerStopFx()</em> routine. This
routine has one argument, a channel mask. The channel mask combines the
hardware channel (or 0 if <em>MIXER_SINGLE</em> is set to 1) and the
mixer channel as returned by <em>MixerPlaySample()</em> into a single
value. Samples playing back on this combination of channels will be
stopped.</p>
<pre><code>   Assembly:                                C:
   ; MIXER_SINGLE=1, so no HW channel       /* MIXER_SINGLE=1, so no HW
   ; is needed.                                channel is needed */
   move.w   #MIX_CH0,d0                     MixerStopFX(MIX_CH0);
   bsr      MixerStopFX</code></pre>
<p>For more information about mixer channels vs hardware channels, see
<a href="#mixer-api">"Mixer API"</a>. For more information about using
the mixer in C programs, see <a
href="#using-the-mixer-in-c-programs">"Using the mixer in C
programs"</a>.</p></li>
<li><h4 id="to-stop-the-mixer-and-all-playback-on-it">To stop the mixer
(and all playback on it)</h4>
<p>Call the routine <em>MixerStop()</em>.</p>
<pre><code>   Assembly:                                C:
   bsr      MixerStop                       MixerStop();</code></pre></li>
<li><h4
id="at-the-end-of-the-program-or-once-no-more-mixing-is-required">At the
end of the program, or once no more mixing is required</h4>
<p>Call the routine <em>MixerRemoveHandler()</em>. This will remove the
interrupt handler and optionally restore the old interrupt vectors (if
the flag to do so was set to 0 when calling
<em>MixerInstallHandler()</em>)</p>
<pre><code>   Assembly:                                C:
   bsr      MixerRemoveHandler              MixerRemoveHandler();</code></pre></li>
</ol>
<p>For more information on using the various mixer routines, see <a
href="#mixer-api">"Mixer API"</a> For more information of integrating
the mixer in C programs, see <a
href="#using-the-mixer-in-c-programs">"Using the mixer in C
programs"</a>.</p>
<h3 id="combining-the-mixer-and-a-music-player">Combining the mixer and
a music player</h3>
<p>It's possible to combine the mixer with an existing music player,
such as the PTPlayer 6.3* from Frank Wille or the LSP player from Arnaud
Carr. Other music players could also be compatible, depending on how
the player deals with channels on which no music is played.</p>
<p>*) Note that only version 6.3+ will work, version 6.2 and below miss
a patch designed to block channels correctly for use with the mixer.</p>
<p>Version 6.3 was released to Aminet on 26-03-2023 and can be found
here: <a
href="https://aminet.net/package/mus/play/ptplayer">https://aminet.net/package/mus/play/ptplayer</a></p>
<p>In order to combine the mixer with a music player, the music player
can't touch any of the hardware registers of any of the channels
configured to be used by the mixer. For example, if mixer_config.i has
<em>mixer_output_channels</em> set to DMAF_AUD2, then the music player
can't touch AUD2 in any way while the mixer is running. This includes
the audio interrupt for this channel, which also can't be used.</p>
<p>This requires two things: a music track that omits the channel(s) as
configured in mixer_config.i and a music player that doesn't touch
channels that aren't in use.</p>
<p>The first is a matter of composition, the second needs to be
supported by the player itself. Some players support this directly (by
not touching unused channels), some support this indirectly (for
instance, by having a function that disables one or more channels from
being used). If the selected player does not natively support channels
being disabled, it's sometimes possible to patch the player by looking
through it for instances of the audio registers for the selected
channel(s) being used and removing them from the code.</p>
<p>If both of these are taken care of, what remains is activating the
mixer and music player in the correct order. Generally speaking, the
music player should be started first, the mixer second*. Depending on
the music player, one or more frames may have to be waited before the
mixer can be successfully started.</p>
<p>*) this is because many music players initialise all audio channels
when they start, even if the channels are empty or disabled.</p>
<p>One thing to keep in mind is that some music players trash some of
the registers used when setting them up, so be sure to initialise the
registers used by the mixer routines correctly prior to calling any of
them.</p>
<p>The mixer contains an example using Frank Wille's PTPlayer that shows
how to make use of it and the mixer together. This is the SingleMixer
example. See <a href="#examples">"Examples"</a> for more
information.</p>
<h4 id="for-ptplayer-63-the-way-to-set-it-up-is-as-follows">For PTPlayer
6.3, the way to set it up is as follows:</h4>
<ol type="1">
<li>initialise PTPlayer as normal</li>
<li>call the routine <em>_mt_channelmask()</em> with the correct channel
mask in D0</li>
<li>set up the mixer as described in <a href="#using-the-mixer">"Using
the mixer"</a></li>
<li>both the mixer and PTPlayer should now work, allowing music and
sound effects at the same time. Note that SFX playback should be done
exclusively through the mixer, not using the built in SFX abilities of
PTPlayer.</li>
</ol>
<p>The SingleMixer example also shows how to integrate LSP.</p>
<h4 id="for-lsp-the-way-to-set-it-up-is-as-follows">For LSP, the way to
set it up is as follows:</h4>
<ol type="1">
<li>initialise the LSP CIA player as normal (don't forget to enable the
CIA interrupt as in the LSP example)</li>
<li>set up the mixer as described in <a href="#using-the-mixer">"Using
the mixer"</a></li>
<li>both the mixer and LSP should now work, allowing music and sound
effects at the same time.</li>
</ol>
<p>For other music players, try initialising the music player first,
then the mixer. If this does not work, look in the documentation of the
music player for ways to disable playback on one or more channels and
use that. If that also does not work, it may be required to patch the
music player to not touch the channel(s) reserved for mixing.</p>
<p>In all cases, the music track(s) used should not use the channel(s)
reserved for mixing to play back audio. Other things (i.e. commands such
as pattern jumps) should still work.</p>
<h3 id="examples">Examples</h3>
<p>The mixer comes with a number of example programs which show the
abilities of the mixer as well as giving working examples of how to use
the mixer. The following examples are provided:</p>
<ul>
<li><h4 id="minimalmixerexample">MinimalMixerExample</h4>
<p>An example program with a minimum of extra features or support code.
The purpose of the example is to show a simple case of using the mixer.
Note that this example does not disable the OS, assumes the VBR is at
address 0 and that the code is running on a PAL Amiga.</p></li>
<li><h4 id="singlemixerexample">SingleMixerExample</h4>
<p>An example program showing the abilities of the mixer when
<em>MIXER_SINGLE</em> is set to 1. The example program shows both
non-looping and looping samples and has two different music players
built in (PTPlayer by Frank Wille and LSP by Arnaud Carr) which can be
selected or disabled.</p>
<p>The example also shows the ability to select an internal mixer
channel for SFX and the ability to stop SFX playback for any/all of the
internal mixer channels on demand.</p>
<p>This program disables the OS, automatically selects between PAL and
NTSC and uses the VBR register to set up the interrupt.</p>
<p>Note that switching the music on or off, or switching between the two
music players will cause the mixer to stop playback of any playing
samples due to the required reset of the interrupt handler.</p></li>
<li><h4 id="singlemixerhqexample">SingleMixerHQExample</h4>
<p>An example program showing the abilities of the mixer when
<em>MIXER_SINGLE</em> is set to 1 and <em>MIXER_HQ_MODE</em> is also set
to 1.</p>
<p>It has the same options and functionality as the SingleMixerExample,
but uses the High Quality mixing mode for higher quality sample
playback.</p></li>
<li><h4 id="multimixerexample">MultiMixerExample</h4>
<p>An example program that shows the ability of the mixer to run on
multiple hardware channels. This example allows mixing of up to 16
samples at the same time and uses all four hardware channels to be able
to do this.</p>
<p>The example allows you to pick a hardware channel and internal mixer
channel to play SFX on. SFX can be both non-looping or looping. SFX can
be stopped when desired.</p>
<p>This program disables the OS, automatically selects between PAL and
NTSC and uses the VBR register to set up the interrupt. It does not
contain music playback.</p></li>
<li><h4 id="multipairedmixerexample">MultiPairedMixerExample</h4>
<p>An example program that shows the ability of the mixer to create a
paired channel which allows for seamless centred SFX to be played back.
The example allows you to pick a hardware channel (AUD2 is paired with
AUD3) and an internal mixer channel to play SFX on. SFX can be both
non-looping or looping. SFX can be stopped when desired.</p>
<p>This program disables the OS, automatically selects between PAL and
NTSC and uses the VBR register to set up the interrupt. It does not
contain music playback.</p></li>
<li><h4 id="callbackexample">CallbackExample</h4>
<p>An example program that shows the ability of the mixer to use
callback routines. The example runs with <em>MIXER_SINGLE</em> set to 1
and allows you to pick an internal mixer channel to play SFX on and set
whether or not to loop the SFX. It also allows you to select whether or
not to use a callback routine.</p></li>
<li><h4 id="pluginexample">PluginExample</h4>
<p>An example program that shows the ability of the mixer to use
plugins. The example runs with <em>MIXER_SINGLE</em> set to 1 and allows
you to pick an internal mixer channel to play SFX on and set whether or
not to loop the SFX.</p>
<p>It also allows you to select a plugin to use. You can select no
plugin, an example custom plugin that replaces the sample played back by
a simple sine wave, the built-in repeat plugin, the built-in
synchronisation plugin, the built-in volume plugin and the built-in
pitch change plugin.</p></li>
<li><h4 id="externalirqexample">ExternalIRQExample</h4>
<p>An example program with external IRQ/DMA handling enabled and a
minimum of extra features or support code. The purpose of the example is
to show a simple case of using external IRQ/DMA handling with the mixer.
Note that this example does not disable the OS, assumes the VBR is at
address 0 and that the code is running on a PAL Amiga.</p></li>
<li><h4 id="cmixerexample">CMixerExample</h4>
<p>An example program that shows the ability of the mixer to be
integrated in C programs. Like the MinimalMixerExample, the example is
kept as simple as possible. Note that this example does not disable the
OS, assumes the VBR is at address 0 and that the code is running on a
PAL Amiga.</p>
<p>Unlike the MinimalMixerExample however, it also shows the use of
plugins and callback routines. The plugin used to showcase plugin use is
the pitch change plugin.</p></li>
<li><h4 id="oslegalexample">OSLegalExample</h4>
<p>An example program in C that shows how to use the mixer in an OS
legal way.</p></li>
</ul>
<h3 id="tools">Tools</h3>
<p>Alongside the mixer, two tools have been included. These tools
are:</p>
<ul>
<li><h4 id="performancetest">PerformanceTest</h4>
<p>A tool to measure the performance of a given mixer configuration.
This tool shows a detailed set of performance figures for all the
various optimisation flags (as well as no optimisations enabled). It
also shows results for the high quality mode, callback routines and the
use of the various built-in plugins. In total, it runs 48 performance
tests and displays the results. Results pages can can be switched with
the right mouse button. There are four pages: default/non-HQ tests in
CIA ticks, default/non-HQ tests as a CPU use percentage,
HQ/callback/plugin tests in CIA ticks and HQ/callback/plugins as a CPU
use percentage.</p>
<p>To use the PerformanceTest, change the mixer_config.i found in the
Mixer subdirectory of the PerformanceTestSource directory and assemble
the PerformanceTest program using make. Then run the resulting
PerformanceTest executable on the Amiga environment you wish to check
the performance results for.</p>
<p>Note that the PerformanceTest uses a changed version of the mixer,
with its own mixer_config.i/mixer.i and mixer.asm. The core routines are
identical, but the PerformanceTest variant has been changed to enable
multiple different versions of the mixer code (with different
performance flags enabled or disabled) to co-exist at the same time.</p>
<p>The mixer_config.i is similarly changed to only include those parts
which are needed to be configured for testing the performance being
included.</p>
<p>This program disables the OS, automatically selects between PAL and
NTSC and uses the VBR register to set up the interrupt. It does not
contain music playback. While no sound will be heard, the
PerformanceTest program does mix and play back sample data via Paula.
However, the volume is set to zero and therefore it results in no sound
being heard.</p></li>
<li><h4 id="sampleconverter">SampleConverter</h4>
<p>A tool written in standard C to convert samples to the correct limits
for use with the mixer, as described in <a
href="#pre-processing-samples">"Pre-processing samples"</a>. The
included binary (and makefile instructions) is for Amiga systems, but
the code only required the C standard libraries and thus should be
easily recompilable on other target systems.</p>
<p>Usage:</p>
<pre><code>SampleConverter &lt;number of software channels&gt; &lt;input file&gt; &lt;output file&gt;</code></pre>
<p>Where the number of software channels is the value given for
<em>mixer_sw_channels</em> in mixer_config.i, input is the sample input
file name and output file is the output file name. Note that
SampleConverter expects 8 bit signed raw sample data as input and will
likewise output this format.</p>
<p>The output file is padded with zeroes to the nearest multiple of four
bytes if required. If the output is to be used with a mixer
configuration where <em>MIXER_SIZEX32</em> or <em>MIXER_SIZEXBUF</em> is
set, the sample will still need to be padded with zeroes to a multiple
of either 32 bytes or <em>mixer_PAL_buffer_size</em> bytes after the
conversion.</p>
<p>Note that this conversion process is only strictly needed for the
standard mixing mode, the high quality mode can play back normal 8-bit
samples. However, it can still be useful to run the SampleConverter with
the number of software channels set to 1 as a convenient way to pad the
samples to a multiple of 4 bytes (which is still required for the high
quality mode).</p></li>
</ul>
<h3 id="api-changes-between-version-3132-and-37">API Changes between
version 3.1/3.2 and 3.7</h3>
<p>Version 3.7 of the mixer makes several changes to the existing API.
These changes are summarised in this section. For more detailed
information, see <a href="#mixer-api">Mixer API</a>, <a
href="#callback-api">Callback API</a>, <a href="#plugin-api">Plugin
API</a> and <a href="#performance-measuring-api">Performance Measuring
API</a>.</p>
<h4 id="new-apis">New API's</h4>
<p>There are new API's for callbacks and plugins (see <a
href="#callback-api">Callback API</a> and <a href="#plugin-api">Plugin
API</a>)</p>
<h4 id="constants">Constants</h4>
<p>There are several new constants and variables defined in
mixer.i/mixer.h:</p>
<ul>
<li>MIX_FX_LOOP_OFFSET</li>
<li>MIX_CH_FREE</li>
<li>MIX_CH_BUSY</li>
<li>MIX_PLUGIN_STD (part of the Plugin API)</li>
<li>MIX_PLUGIN_NODATA (part of the Plugin API)</li>
<li>mixer_plugin_buffer_size (part of the Plugin API)</li>
</ul>
<h4 id="type-definitions">Type definitions</h4>
<p>There are some changes surrounding the type definitions in
mixer.i/mixer.h:</p>
<ul>
<li>The definition of MXEffect has changed</li>
<li>There is a new type, MXPlugin (part of the Plugin API)</li>
</ul>
<h4 id="functions">Functions</h4>
<p>Several existing functions have their parameters changed:</p>
<ul>
<li><em>MixerSetup()</em></li>
<li><em>MixerPlaySample()</em></li>
<li><em>MixerPlayChannelSample()</em></li>
</ul>
<p>Several existing functions have been deprecated and are provided
solely for backwards compatibility:</p>
<ul>
<li><em>MixerPlaySample()</em></li>
<li><em>MixerPlayChannelSample</em>()</li>
</ul>
<p>Note: these functions will no longer be updated with new features for
new versions after 3.6. They do not support the use of plugins.</p>
<p>There are several new functions:</p>
<ul>
<li><em>MixerGetChannelStatus()</em></li>
<li><em>MixerGetTotalChannelCount()</em></li>
<li><em>MixerGetChannelBufferSize()</em></li>
<li><em>MixerEnableCallback()</em> (part of the Callback API)</li>
<li><em>MixerDisableCallback()</em> (part of the Callback API)</li>
<li><em>MixerGetPluginsBufferSize()</em> (part of the Plugin API)</li>
<li><em>MixerSetPluginDeferredPtr()</em> (part of the Plugin API)</li>
<li><em>MixerResetCounter()</em> (part of the Performance Measuring
API)</li>
<li><em>MixerGetCounter()</em> (part of the Performance Measuring
API)</li>
</ul>
<p>There are several new plugins:</p>
<ul>
<li><em>MixPluginRepeat()</em> (part of the Plugin API)</li>
<li><em>MixPluginSync()</em> (part of the Plugin API)</li>
<li><em>MixPluginPitch()</em> (part of the Plugin API)</li>
<li><em>MixPluginVolume()</em> (part of the Plugin API)</li>
</ul>
<h3 id="mixer-api">Mixer API</h3>
<p>The mixer provides several routines, constants and variables* to
enable mixing samples**. It also makes use of several elements of the
Amiga NDK (1.3+) for convenience and clarity.</p>
<p>In particular, it makes use of the exec_types.i include file to have
a set of standard data types and a standardized way to define structures
in assembly. It also makes use of several constants provided by the
Amiga NDK.</p>
<p>*) Note that only routines/constants/variables used to play back
samples using the mixer will be documented. There are internal routines,
constants and variables that are not needed to play back samples and
these are not documented.</p>
<p>**) Note that samples played back by the mixer can be stored in any
type of RAM (not just Chip RAM). Also note that samples played back by
the mixer must be pre-processed as described in <a
href="#pre-processing-samples">"Pre-processing samples"</a>.</p>
<p>For 68020+ based systems, it's recommended to store samples on 4 byte
boundaries to get optimal performance.</p>
<h4 id="ndk-constants-used-follow">NDK constants used follow:</h4>
<ul>
<li><p>DMAF_AUD0 / DMAF_AUD1 / DMAF_AUD2 / DMAF_AUD3<br />
These four constants refer to the four hardware audio channels the Amiga
sound chip, Paula, provides. They are used by various mixer routines as
well as mixer_config.i to identify the destination hardware channel(s)
to be used for mixed output.</p>
<p>Note that mixer routines that require a hardware channel only require
one of these if the mixer is running with <em>MIXER_MULTI</em> or
<em>MIXER_MULTI_PAIRED</em> set to 1. If <em>MIXER_SINGLE</em> is set
instead, mixer routines that require a hardware channel simply ignore
the hardware channel set.</p></li>
</ul>
<h4 id="constant-info-follows">Constant info follows:</h4>
<ul>
<li><p>MIX_PAL / MIX_NTSC<br />
These two constants are used to indicate whether the mixer should run in
PAL or NTSC mode when calling <em>MixerSetup()</em>. The difference
between these two modes is a very small change in the period value used
and a change in the size of number of bytes the mixer processes. If the
mixer is set to run in PAL mode, it will mix enough bytes to fill 1/50th
of a second per interrupt. If it is set to run in NTSC bytes, the mixer
will instead mix enough bytes to fill 1/60th of a second per
interrupt.</p>
<p>Effectively, this changes the frequency of the interrupts to 1/50th
or 1/60th of a second.</p></li>
<li><p>MIX_FX_ONCE / MIX_FX_LOOP / MIX_FX_LOOP_OFFSET<br />
These three constants are used to indicate whether a sample should be
played back once by the mixer, or be played back in a loop. They are
used by various mixer routines that play back samples.</p>
<ul>
<li>MIX_FX_ONCE<br />
play back the sample once</li>
<li>MIX_FX_LOOP<br />
play back the sample in a loop, restarting at the beginning of the
sample</li>
<li>MIX_FX_LOOP_OFFSET<br />
play back the sample in a loop, restarting at the given offset into the
sample, rather than at the beginning</li>
</ul>
<p>Note: none of these constants has the value zero.</p></li>
<li><p>MIX_CH0 / MIX_CH1 / MIX_CH2 / MIX_CH3<br />
These four constants are used to indicate which internal mixer channel
should be used when calling routines that allow choosing an internal
mixer channel. Routines that do not allow this choice will select an
internal channel automatically using priority and age.</p>
<p>Each hardware channel the mixer is configured to use in
mixer_config.i has between 1 and 4 internal mixer channels associated
with it. How many of these internal channels are available depends on
the value of <em>mixer_sw_channels</em> in mixer_config.i.</p>
<p>When using a routine that allows choosing an internal mixer channel,
these values select which of the internal channels to use. This is
useful to have more control over what samples are being played. Note
that when selecting an internal channel, priority still applies - a
lower priority sample will not overwrite a higher priority one.</p></li>
<li><p>MIX_CH_FREE / MIX_CH_BUSY<br />
These two constants are used by MixerGetChannelStatus() to indicate
whether a given internal mixer channel is free, or busy playing back a
sample.</p></li>
</ul>
<h4 id="variable-info-follows">Variable info follows:</h4>
<ul>
<li><p>mixer_buffer_size<br />
This variable contains the calculated total size of the Chip RAM buffer
that needs to be passed to <em>MixerSetup()</em> for use by the mixer.
For optimal performance on 68020+ systems, this buffer should be aligned
on a four byte boundary.</p>
<p>Note that this value is not identical to either
<em>mixer_PAL_buffer_size</em> or <em>mixer_NTSC_buffer_size</em>, which
should not be used to determine the size of the Chip RAM buffer.</p>
<p>See also <em>MixerGetBufferSize()</em></p></li>
<li><p>mixer_PAL_buffer_size<br />
This variable contains the calculated size needed by the mixer to play
back 1/50th of a second of sample data. It's mostly useful to determine
the amount of bytes to pad samples with in case <em>MIXER_SIZEXBUF</em>
is set.</p>
<p>See also <em>MixerGetSampleMinSize()</em></p></li>
<li><p>mixer_NTSC_buffer_size<br />
This variable contains the calculated size needed by the mixer to play
back 1/60th of a second of sample data. It's mostly useful to determine
the amount of bytes to pad samples with in case <em>MIXER_SIZEXBUF</em>
is set if the mixer is expected to never run in PAL mode.</p>
<p>See also <em>MixerGetSampleMinSize()</em></p></li>
</ul>
<h4 id="structure-info-follows">Structure info follows:</h4>
<ul>
<li><p>MXEffect<br />
This structure defines a sample to be played back by the mixer. It is
used by routines that expect a pointer to the effect structure rather
than individually set registers.</p>
<p>The structure elements are as follows:</p>
<ul>
<li><p>mfx_length<br />
Length of the sample in bytes (signed long unless
<em>MIXER_WORDSIZED</em> is set to 1 in mixer_config.i, in which case
the length is an unsigned word)</p></li>
<li><p>mfx_sample_ptr<br />
Pointer to the pre-processed sample to play</p></li>
<li><p>mfx_loop<br />
Either <em>MIX_FX_ONCE</em> to play back the sample once,
<em>MIX_FX_LOOP</em> to play the sample on a loop or
<em>MIX_FX_LOOP_OFFSET</em> to play the sample on a loop that restarts
at the given <em>mfx_loop_offset</em>.</p></li>
<li><p>mfx_priority<br />
Signed priority value, higher priority samples can overwrite lower
priority samples.</p>
<p>Note that looping samples (once playing) can never be
overwritten.</p></li>
<li><p>mfx_loop_offset<br />
Offset into the sample at which it will restart playback if the loop
mode is set to <em>MIX_FX_LOOP_OFFSET</em>.</p></li>
<li><p>mfx_plugin_ptr<br />
The value set here is only used if <em>MIXER_ENABLE_PLUGINS</em> is set
to 1.</p>
<p>Set to 0 (NULL) if no plugin is to be used for this sample, or set to
a pointer to an instance of MXPlugin if a plugin is to be used.</p>
<p>See <a href="#plugin-api">Plugin API</a> for more
information.</p></li>
<li><p>mfx_SIZEOF<br />
Gives the length of the structure in bytes</p></li>
</ul></li>
<li><p>MXIRQDMACallbacks This structure is only available if
<em>MIXER_EXTERNAL_IRQ_DMA</em> is set to 1 and is used by the function
MixerSetIRQDMACallbacks() to set the callback function pointers it
requires.</p>
<p>The structure elements are as follows:</p>
<ul>
<li><p>mxicb_set_irq_vector Function pointer to routine that sets the
IRQ vector for audio interrupts. This function has a parameter:</p>
<ul>
<li>A0 = vector to mixer interrupt handler</li>
</ul>
<p>Note: the mixer interrupt handler will return using RTS rather than
RTE when using external IRQ/DMA callbacks. This behaviour can be
overridden by setting MIXER_EXTERNAL_RTE to 1, in which case the
interrupt handler will exit using RTE.</p></li>
<li><p>mxicb_remove_irq_vector Function pointer to routine that removes
the IRQ vector for audio interrupts.</p>
<p>Note: if MIXER_EXTERNAL_BITWISE is set to 1, this routine is also
responsible for resetting INTENA to the value it had prior to calling
MixerInstallHandler(), if this is desired. When MIXER_EXTERNAL_BITWISE
is set to 0, this is done by the mixer automatically</p></li>
<li><p>mxicb_set_irq_bits Function pointer to routine that sets the
correct bits in INTENA to enable audio interrupts for the mixer.</p>
<p>This function has a parameter:</p>
<ul>
<li>D0 = INTENA bits to set</li>
</ul>
<p>Note: if MIXER_EXTERNAL_BITWISE is set to 1, the relevant bits are
passed as individual INTENA values, where the set/clear bit is set as
appropriate</p></li>
<li><p>mxicb_disable_irq Function pointer to routine that disables audio
interrupts</p>
<p>This function has a parameter:</p>
<ul>
<li>D0 = INTENA bits to disable</li>
</ul>
<p>Note: if MIXER_EXTERNAL_BITWISE is set to 1, the relevant bits are
passed as individual INTENA values, where the set/clear bit is set as
appropriate Note: this is a separate routine from mxicb_set_irq_bits
because disabling interrupts should also make sure to reset the
corresponding bits in INTREQ</p></li>
<li><p>mxicb_acknowledge_irq Function pointer to routine that
acknowledges audio interrupt.</p>
<p>This function has a parameter:</p>
<ul>
<li>D0 = INTREQ value</li>
</ul>
<p>Note: this will always pass the INTREQ value for a single
channel.</p></li>
<li><p>mxicb_set_dmacon Function pointer to routine that enables audio
DMA.</p>
<p>This function has a parameter:</p>
<ul>
<li>D0 = DMACON value</li>
</ul>
<p>Note: if MIXER_EXTERNAL_BITWISE is set to 1, the relevant bits are
passed as individual DMACON values, where the set/clear bit is set as
appropriate</p></li>
</ul></li>
</ul>
<h4 id="routine-info-follows">Routine info follows:</h4>
<p><em>MixerSetup(A0=buffer, A1=plugin_buffer, A2=plugin_data,
D0=video_system.w, D1=plugin_data_length.w)</em><br />
This routine prepares the mixer structure for use by the mixing routines
and sets mixer playback volume to the maximum hardware volume of 64. The
routine must be called prior to any other mixing routines. The routine
has two parameters:</p>
<ul>
<li><p>A0 - must point to a block of memory in Chip RAM at least
<em>mixer_buffer_size</em> bytes in size.<br />
Note: on 68020+ systems, it is advisable to align the Chip RAM buffer to
a 4 byte boundary for optimal performance.</p></li>
<li><p>D0 - must contain either <em>MIX_PAL</em> if running on a PAL
system, or <em>MIX_NTSC</em> when running on a NTSC system. If the video
system is unknown, set D0 to <em>MIX_PAL</em>.</p>
<p>If MIXER_ENABLE_PLUGINS is set to one, A1, A2 and D1 also need to be
set. If not, they can be omitted / left to 0.</p></li>
<li><p>A1 - must point to a block of memory (any RAM type) at least
<em>mixer_plugin_buffer_size bytes in size.</em><br />
Note: on 68020+ systems, it is advisable to align this buffer to a 4
byte boundary for optimal performance.</p></li>
<li><p>A2 - must point to a block of memory sized the maximum size of
any of any plugin data entry (see D1 for more details) multiplied by
mixer_total_channels from mixer.i.<br />
Note: on 68020+ systems, it is advisable to align this buffer to a 4
byte boundary for optimal performance.</p></li>
<li><p>D1 - must be set to the maximum size of any of the possible
plugin data structures. If no custom plugins are used, this size is
equal to the value of mxplg_max_data_size, found in plugins.i.<br />
If custom plugins are used, this value must be either the largest data
size of the custom plugins, or mxplg_max_data_size, whichever is
larger.</p></li>
</ul>
<p><em>MixerInstallHandler(A0=VBR, D0=save_vector.w)</em><br />
This routine sets up the mixer interrupt handler. <em>MixerSetup()</em>
must have been called prior to calling this routine. The routine has two
parameters:</p>
<ul>
<li><p>A0 - Set to the VBR or zero (if running on a 68000).</p></li>
<li><p>D0 - Set to 0 to save the interrupt vector the handler uses for
future restoring, set to 1 to not save the interrupt vector.</p></li>
</ul>
<p><em>MixerRemoveHandler()</em><br />
This routine removes the mixer interrupt handler.
<em>MixerInstallHandler()</em> and <em>MixerStop()</em> should be called
prior to calling this routine to make sure audio DMA is stopped.</p>
<p><em>MixerStart()</em><br />
This routine starts mixer playback (initially playing back silence).
<em>MixerSetup()</em> and <em>MixerInstallHandler()</em> must have been
called prior to calling this routine.</p>
<p>Note: if <em>MIXER_CIA_TIMER</em> is set to 1 in mixer_config.i, this
routine also starts the CIA timer to measure performance metrics.</p>
<p><em>MixerStop()</em><br />
This routine stops mixer playback. Both <em>MixerSetup()</em> and
<em>MixerInstallHandler()</em> must have been called prior to calling
this routine.</p>
<p>Note: if <em>MIXER_CIA_TIMER</em> is set to 1 in mixer_config.i, this
routine also stops the CIA timer used to measure performance metrics.
The results are of any performance measuring are found in
<em>mixer_ticks_last</em>, <em>mixer_ticks_best</em> and
<em>mixer_ticks_worst</em> (these variables are not available if
<em>MIXER_CIA_TIMER</em> is set to 0 in mixer_config.i).</p>
<p><em>MixerVolume(D0=volume.w)</em><br />
This routine sets the desired hardware output volume used by the mixer
(valid values are 0 to 64).</p>
<p><em>D0=MixerPlayFX(A0=effect_structure,
D0=hardware_channel)</em><br />
This routine adds a sample to the given hardware channel, using the
MXEffect structure as described earlier. The routine automatically
determines the best mixer channel to play back on based on priority and
age. If no applicable channel is free (for instance due to higher
priority samples playing), the routine will not play the sample.</p>
<p>The routine has two parameters:</p>
<ul>
<li><p>A0 - Points to an instance of the <em>MXEffect</em>
structure</p></li>
<li><p>D0 - Hardware channel to use (DMAF_AUD0..DMAF_AUD3)</p>
<p>Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the
hardware channel given is ignored.<br />
Note: if <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em> are set to
1 in mixer_confi.i and the given channel is not part of the channels set
in <em>mixer_output_channels</em> the sample will not play.<br />
Note: if <em>MIXER_MULTI_PAIRED</em> is set to 1 in mixer_config.i,
DMAF_AUD2 and DMAF_AUD3 are paired. Add samples intended for the paired
channel to DMAF_AUD2 only, samples added to DMAF_AUD3 will be
ignored.</p></li>
</ul>
<p>The routine has a return value:</p>
<ul>
<li>D0 - returns the hardware &amp; mixer channel the sample will play
on, or -1 if no free channel could be found.</li>
</ul>
<p><em>D0=MixerPlayChannelFX(A0=effect_structure,
D0=mixer_channel)</em><br />
This routine adds a sample to the given hardware/mixer channel
combination, using the <em>MXEffect</em> structure as described earlier.
The routine uses the selected hardware/mixer channel to play back on. It
checks for priority to see if the sample can be played. If the selected
channel isn't free (due to a higher priority sample playing), the
routine will not play the sample.</p>
<p>The routine has two parameters:</p>
<ul>
<li><p>A0 - Points to an instance of the <em>MXEffect</em>
structure</p></li>
<li><p>D0 - Hardware/mixer channel to use (DMAF_AUD0..DMAF_AUD3 |
MIX_CH0..MIX_CH3).</p>
<p>Note: The routine requires setting exactly one hardware &amp; mixer
channel in D0.<br />
Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the
hardware channel given is ignored.<br />
Note: if <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em> are set to
1 in mixer_confi.i and the given channel is not part of the channels set
in <em>mixer_output_channels</em> the sample will not play.<br />
Note: if <em>MIXER_MULTI_PAIRED</em> is set to 1 in mixer_config.i,
DMAF_AUD2 and DMAF_AUD3 are paired. Add samples intended for the paired
channel to DMAF_AUD2 only, samples added to DMAF_AUD3 will be
ignored.</p></li>
</ul>
<p>The routine has a return value:</p>
<ul>
<li>D0 - returns the hardware &amp; mixer channel the sample will play
on, or -1 if no free channel could be found.</li>
</ul>
<p><em>MixerStopFX(D0=mixer_channel_mask)</em><br />
This routine stops sample playback on the given hardware/mixer channel
mask. Multiple hardware/mixer channels can be set at the same time,
samples on all given channels will be stopped. This routine has one
parameter:</p>
<ul>
<li><p>D0 - Hardware/mixer channel mask DMAF_AUD0..DMAF_AUD3 |
MIX_CH0..MIX_CH3).</p>
<p>Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the
hardware channel given is ignored.</p></li>
</ul>
<p><em>D0=MixerGetBufferSize()</em><br />
This routine returns the size of the Chip RAM buffer size that needs to
be allocated and passed to <em>MixerSetup()</em>. Note that this routine
merely returns the value of <em>mixer_buffer_size</em>, which is defined
in mixer.i. The primary function of this routine is to offer a method
for C programs to gain access to this value without needing access to
mixer.i.</p>
<p><em>D0=MixerGetSampleMinSize()</em><br />
This routine returns the minimum sample size. This is the minimum sample
size the mixer can play back correctly. Samples must always be a
multiple of this value in length.</p>
<p>Normally this value is 4, but optimisation options in mixer_config.i
can can increase this.</p>
<p>Note: this routine is usually not needed as the minimum sample size
is implied by the mixer_config.i setup. Its primary function is to give
the correct value in case <em>MIXER_SIZEXBUF</em> has been set to 1 in
mixer_config.i, in which case the minimum sample size will depend on the
video system selected when calling <em>MixerSetup()</em> (PAL or
NTSC).<br />
Note: <em>MixerSetup()</em> must have been called prior to calling this
routine.</p>
<p><em>D0=MixerGetChannelStatus()</em><br />
This routine returns whether or not the hardware/mixer channel given in
D0 is in use for sample playback. If <em>MIXER_SINGLE</em> is set to 1,
the hardware channel does not need to be given in D0. If the channel is
not used, the routine will return <em>MIX_CH_FREE</em>. If the channel
is in use, the routine will return <em>MIX_CH_BUSY</em>.</p>
<p><em>D0=MixerGetTotalChannelCount()</em><br />
This routine returns the total number of internal channels the mixer
supports for sample playback. That is to say, the value of
<em>mixer_sw_channels</em> multiplied by the number of assigned HW audio
channels.</p>
<p><em>D0=MixerGetChannelBufferSize()</em><br />
This routine returns the value of the internal mixer buffer size. This
is the size of the buffer the mixer uses per HW audio channel assigned
to it. Its primary purpose is to give plugins a way to get this value
without needing access to the internal mixer structure.</p>
<p><em>MixerSetReturnVector(A0=return_function_ptr)</em><br />
This routine sets the optional vector the mixer can call at to at the
end of interrupt execution.</p>
<p>Note: this vector should point to a standard routine ending in
RTS.</p>
<p><em>MixerSetIRQDMACallbacks(A0=callback_structure)</em><br />
This routine sets up the vectors used for callback routines to manage
setting up interrupt vectors and DMA flags. This routine and associated
callbacks are only required if MIXER_EXTERNAL_IRQ_DMA is set to 1 in
mixer_config.i.</p>
<p>The function has a parameter:</p>
<ul>
<li>A0 - Points to an instance of the <em>MXIRQDMACallbacks</em>
structure</li>
</ul>
<p>Note: MixerSetup should be run before calling this routine</p>
<p>Note: if MIXER_C_DEFS is set to 0, all callback routines should save
&amp; restore all registers they use. If MIXER_C_DEFS is set to 1,
registers d0,d1,a0 and a1 will be pushed to and popped from the stack by
the mixer. All callback routines should save &amp; restore all other
registers they use.</p>
<p>Note: this routine is only available if MIXER_EXTERNAL_IRQ_DMA is set
to 1.</p>
<h4
id="the-following-two-routines-are-deprecated-and-will-no-longer-receive-new-functionality-when-the-mixer-is-updated-they-are-still-available-for-backwards-compatibility-purposes-and-have-been-updated-with-the-new-offset-loop-mode">The
following two routines are deprecated and will no longer receive new
functionality when the mixer is updated. They are still available for
backwards compatibility purposes and have been updated with the new
offset loop mode.</h4>
<p><em>D0=MixerPlaySample(A0=sample, D0=hardware_channel, D1=length,
D2=signed_priority.w, D3=loop_indicator.w, D4=loop_offset)</em><br />
This routine adds a sample to the given hardware channel, using values
in registers passed to it. The routine automatically determines the best
mixer channel to play back on based on priority and age. If no
applicable channel is free (for instance due to higher priority samples
playing), the routine will not play the sample.</p>
<p>The routine has five parameters:</p>
<ul>
<li><p>A0 - Pointer to the pre-processed sample to play</p></li>
<li><p>D0 - Hardware channel to use (DMAF_AUD0..DMAF_AUD3)</p></li>
<li><p>D1 - Length of the sample in bytes (signed long unless
<em>MIXER_WORDSIZED</em> is set to 1 in mixer_config.i, in which case
the length is an unsigned word)</p></li>
<li><p>D2 - Signed priority value, higher priority samples can overwrite
lower priority samples.<br />
Note that looping samples (once playing) can never be
overwritten.</p></li>
<li><p>D3 - Either <em>MIX_FX_ONCE</em> to play back the sample once,
<em>MIX_FX_LOOP</em> to play the sample on a loop, or
<em>MIX_FX_LOOP_OFFSET</em> to play back the sample on a loop,
restarting from the offset given in D4.</p></li>
<li><p>D4 - Either 0, or the desired offset into the sample to restart
looping at if D3 is set to <em>MIX_FX_LOOP_OFFSET</em>.</p>
<p>Note: this routine is deprecated, use <em>MixerPlayFX()</em>
instead<br />
Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the
hardware channel given is ignored.<br />
Note: if <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em> are set to
1 in mixer_confi.i and the given channel is not part of the channels set
in <em>mixer_output_channels</em> the sample will not play.<br />
Note: if <em>MIXER_MULTI_PAIRED</em> is set to 1 in mixer_config.i,
DMAF_AUD2 and DMAF_AUD3 are paired. Add samples intended for the paired
channel to DMAF_AUD2 only, samples added to DMAF_AUD3 will be
ignored.</p></li>
</ul>
<p>The routine has a return value:</p>
<ul>
<li>D0 - returns the hardware &amp; mixer channel the sample will play
on, or -1 if no free channel could be found.</li>
</ul>
<p><em>D0=MixerPlayChannelSample(A0=sample, D0=mixer_channel, D1=length,
D2=signed_priority.w, D3=loop_indicator.w, D4=loop_offset)</em><br />
This routine adds a sample to the given hardware/mixer channel
combination, using values in registers passed to it. The routine uses
the selected hardware/mixer channel to play back on. It checks for
priority to see if the sample can be played. If the selected channel
isn't free (due to a higher priority sample playing), the routine will
not play the sample. The routine has five parameters:</p>
<ul>
<li><p>A0 - Pointer to the pre-processed sample to play</p></li>
<li><p>D0 - Hardware channel to use (DMAF_AUD0..DMAF_AUD3)</p></li>
<li><p>D1 - Length of the sample in bytes (signed long unless
<em>MIXER_WORDSIZED</em> is set to 1 in mixer_config.i, in which case
the length is an unsigned word)</p></li>
<li><p>D2 - Signed priority value, higher priority samples can overwrite
lower priority samples.<br />
Note that looping samples (once playing) can never be
overwritten.</p></li>
<li><p>D3 - Either <em>MIX_FX_ONCE</em> to play back the sample once,
<em>MIX_FX_LOOP</em> to play the sample on a loop, or
<em>MIX_FX_LOOP_OFFSET</em> to play back the sample on a loop,
restarting from the offset given in D4.</p></li>
<li><p>D4 - Either 0, or the desired offset into the sample to restart
looping at if D3 is set to <em>MIX_FX_LOOP_OFFSET</em>.</p>
<p>Note: this routine is deprecated, use <em>MixerPlayFX()</em>
instead<br />
Note: The routine requires setting exactly one hardware &amp; mixer
channel in D0.<br />
Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the
hardware channel given is ignored.<br />
Note: if <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em> are set to
1 in mixer_confi.i and the given channel is not part of the channels set
in <em>mixer_output_channels</em> the sample will not play. Note: if
<em>MIXER_MULTI_PAIRED</em> is set to 1 in mixer_config.i, DMAF_AUD2 and
DMAF_AUD3 are paired. Add samples intended for the paired channel to
DMAF_AUD2 only, samples added to DMAF_AUD3 will be ignored.</p></li>
</ul>
<p>The routine has a return value:</p>
<ul>
<li>D0 - returns the hardware &amp; mixer channel the sample will play
on, or -1 if no free channel could be found.</li>
</ul>
<h3 id="callback-api">Callback API</h3>
<p>In order to support callback routines, the mixer provides several
routines and a common calling convention for callback routines. Note
that callback routines are only supported if
<em>MIXER_ENABLE_CALLBACK</em> is set to 1.</p>
<p>When enabled and a callback is set using
<em>MixerEnableCallback()</em>, the given callback routine is called
whenever a sample ends. Samples that loop, are stopped by calling
<em>MixerStopFX()</em> or by calling <em>MixerStop()</em> do not result
in a callback routine being called.</p>
<h4 id="routine-info-follows-1">Routine info follows:</h4>
<ul>
<li><p><em>MixerEnableCallback(A0=callback_function_ptr)</em><br />
This routine enables the callback function and sets it to the given
function pointer in A0.</p></li>
<li><p><em>MixerDisableCallback()</em><br />
This routine disables the callback function.</p></li>
</ul>
<h4 id="callback-routine-conventions-follow">Callback routine
conventions follow:</h4>
<ul>
<li><p>Callback functions take two parameters, the HW channel/mixer
channel combination and the pointer to the start of the sample that just
finished playing.</p></li>
<li><p>Callback functions are not allowed to change any registers, apart
from D0. They are called during the mixer interrupt and as therefore
should be as frugal as possible with the amount of CPU time
used.</p></li>
<li><p>Callback functions can start playback of new samples using the
standard mixer functions to play back samples, but only on the same
mixer channel as the sample that just finished playback. If a callback
function is used to start playing a new sample, the function should set
its return value in D0 to 1.</p>
<p>New samples played back by callback functions will start immediately
after the end of the sample that just finished playback. This allows for
seamless playback of one sample after the other.</p></li>
</ul>
<h4 id="callback-parametersreturn-value-follow">Callback
parameters/return value follow:</h4>
<ul>
<li><p>A0 - Pointer to the callback function to use.</p></li>
<li><p>D0 - the HW/mixer channel combination of the sample that just
finished playing.</p></li>
</ul>
<p>Return value:</p>
<ul>
<li>D0 - set to 0 if no new sample started playing, or to 1 if a new
sample started playing.</li>
</ul>
<h3 id="plugin-api">Plugin API</h3>
<p>The plugin API is split into four parts. The first part describes the
basics of the plugin system, including how it's split up into an
initialisation part and a plugin part. The second part describes the
plugin configurarion file, plugins_config.i. The third part describes
the main API, which is dealt with directly by the mixer and thus part of
mixer.asm. The last part describes the plugins themselves, which are
found in plugins.asm and how to make custom plugins.</p>
<h4 id="plugin-basics">Plugin basics</h4>
<p>Mixer plugins are routines that allow for several things:</p>
<ul>
<li>Changing sample output data for a specific mixer channel (for
instance, changing the pitch of a sound)</li>
<li>Communicating status with the program code outside of the mixer
interrupt (for instance, setting an address in memory to 1 when a sample
has finished playback)</li>
<li>Starting a new sample when certain conditions occur (for instance,
playing the same sample again after a short delay)</li>
</ul>
<p>Plugin routines are called by the mixer during mixer interrupts using
a specific API. They are not meant to be called outside of the mixer
interrupt. They are not allowed to change sample source data, any
changes in data required for the desired effect has to be written into a
intermediate buffer, which is then used by the mixer for playback.
Plugin routines can run in a special mode where they do not output any
data to the intermediate buffer, which makes it possible to use plugins
to communicate with the program code outside of the mixer interrupts at
a low cost in performance.</p>
<p>Plugins consist of up to three routines:</p>
<ul>
<li><p>Plugin initialisation (required)<br />
This routine does setup for the plugin prior to playing back the sample.
These routines are called when calling the various
<em>MixerPlayFX()</em> routines.</p>
<p>Plugin initialisation routines also set up any data required by
plugin routines and get passed initilisation data via the
<em>MXPlugin</em> structure.</p></li>
<li><p>Plugin routine (required)<br />
This routine does the actual work of the plugin. These routines are
called every mixer interrupt for samples playing using a plugin.
Depending on plugin type, they either need to fill an output buffer with
the audio data to play, or not.</p>
<p>Note: plugin routines are not allowed to call any mixer playback
function, such as <em>MixerPlayFX()</em> or <em>MixerPlaySample()</em>.
Doing so can cause the mixer interrupt to crash.</p></li>
<li><p>Deferred plugin routine (optional)<br />
This routine is called at the end of every mixer interrupt for samples
playing using a plugin. These routines are required only when playing
back entirely new samples is needed for the plugin, as calling
<em>MixerPlaySample()</em>/<em>MixerPlayFX()</em> type routines during
the mixing loop is not supported.</p></li>
</ul>
<p>Apart from deferred plugin routines (which are set up directly by
plugin routines themselves), all these routines and any data they need
are passed to the mixer using the MXPlugin structure, and passing this
via the MXEffect structure to the playback routines. See <a
href="#mixer-api">Mixer API</a> for more information about MXEffect or
the playback functions.</p>
<p>For more details on calling conventions and the like, see plugins.asm
part below.</p>
<h4 id="plugin-configuration">Plugin configuration</h4>
<ul>
<li><p>Like the mixer, the plugins also have a configuration file which
defines how the code gets assembled. Items configured via the
configuration file can't be changed at runtime. The plugins are
configured via the file plugins_config.i</p>
<p>In addition, the plugins also make use of the <em>MIXER_C_DEFS</em>
and <em>MIXER_68020</em> settings from mixer_config.i</p>
<p>The following options exist:</p>
<ul>
<li>MXPLUGIN_REPEAT<br />
Set this option to 1 to enable the use of the repeat plugin, or to zero
to disable it.</li>
</ul>
<pre><code>MXPLUGIN_REPEAT             EQU 1</code></pre>
<ul>
<li>MXPLUGIN_SYNC<br />
Set this option to 1 to enable the use of the sync plugin, or to zero to
disable it.</li>
</ul>
<pre><code>MXPLUGIN_SYNC               EQU 1</code></pre>
<ul>
<li>MXPLUGIN_VOLUME<br />
Set this option to 1 to enable the use of the volume plugin, or to zero
to disable it.</li>
</ul>
<pre><code>MXPLUGIN_VOLUME             EQU 1</code></pre>
<ul>
<li>MXPLUGIN_PITCH Set this option to 1 to enable the use of the pitch
plugin, or to zero to disable it.</li>
</ul>
<pre><code>MXPLUGIN_PITCH              EQU 1</code></pre>
<ul>
<li>MXPLUGIN_68020_ONLY<br />
If this option is set to 1 and MIXER_68020 is set to 1, the plugins use
a small amount of 68020+ code to offer a tiny improvement in
performance.</li>
</ul>
<pre><code>MXPLUGIN_68020_ONLY         EQU 1</code></pre>
<ul>
<li>MXPLUGIN_NO_VOLUME_TABLES<br />
If this option is set to 1 and MXPLUGIN_VOLUME is set to 1, the volume
tables are not included, saving 3,5KB of RAM.</li>
</ul>
<pre><code>MXPLUGIN_NO_VOLUME_TABLES         EQU 1</code></pre></li>
</ul>
<h4 id="mixerasm-part">mixer.asm part</h4>
<ul>
<li><p>The main plugin API is found in mixer.asm, as the mixer is
responsible for dealing with plugins. This part of the documentation
describes how to set up the <em>MXPlugin</em> structure for use in the
<em>MXEffect</em> structure passed to <em>MixerPlayFX()</em> &amp;
<em>MixerPlayChannelFX()</em> and the support routines for plugins that
are available.</p>
<p>Note: all use of plugins requires <em>MIXER_ENABLE_PLUGINS</em> to be
set to 1 and <em>MixerSetup()</em> has to have been called with the
relevant parameters for plugins set correctly.</p>
<p>Constant info follows:</p>
<ul>
<li><p>MIX_PLUGIN_STD / MIX_PLUGIN_NODATA<br />
These two constants are used in the filling of <em>MXPlugin</em> to
indicate the type of plugin that is being configured.
<em>MIX_PLUGIN_STD</em> is used to denote a standard plugin, one which
outputs an altered version of the source sample into an indirect buffer
to allow changes in the audio heard.</p>
<p><em>MIX_PLUGIN_NODATA</em> on the other hand denotes a plugin that
does not change sample data, but is used for other purposes - such as
communication with other code, synchronisation or starting new samples
when certain situations occur.</p></li>
</ul>
<p>Variable info follows:</p>
<ul>
<li>mixer_plugin_buffer_size<br />
This variable denotes the total size in RAM needed for the indirect
buffers that are used by the mixer to store the results of plugins that
change the data of the input sample.</li>
</ul>
<p>Structure info follows:</p>
<ul>
<li><p>MXPlugin<br />
This structure defines a plugin for use with a mixer sound effect.</p>
<p>The MXPlugin structure has the following members:</p>
<ul>
<li><p>mpl_plugin_type<br />
Determines the type of plugin. Either <em>MIX_PLUGIN_STD</em> for
standard plugins, or <em>MIX_PLUGIN_NODATA</em> for plugins that do not
alter sample buffer data.</p></li>
<li><p>mpl_init_ptr<br />
Pointer to the plugin initialisation routine to use.</p></li>
<li><p>mpl_plugin_ptr<br />
Pointer to the plugin routine to use.</p></li>
<li><p>mpl_init_data_ptr<br />
Pointer to the plugin initialisation data to use.</p></li>
</ul></li>
</ul>
<p>Routine info follows:</p>
<ul>
<li><p>D0=MixerGetPluginsBufferSize()<br />
This routine returns the value of <em>mixer_plugin_buffer_size</em>, the
required size of the RAM buffer that needs to be allocated and passed to
<em>MixerSetup()</em> if <em>MIXER_ENABLE_PLUGINS</em> is set to 1.</p>
<p>Note: this routine is usually not needed as the plugin buffer size is
given in mixer.i. Its primary function is to expose this value to C
programs.</p></li>
<li><p>MixerSetPluginDeferredPtr(A0=deferred_function_ptr,
A2=mxchannel)<br />
This routine is called by a plugin whenever it needs to do a deferred
(=post mixing loop) action. This is useful in case a plugin needs to
start playback of a new sample, as this cannot be done during the mixing
loop to prevent race conditions.</p>
<p>Note: this routine should <strong>only</strong> be used by plugin
routines and never in other situations as that will likely crash the
mixer interrupt handler.</p>
<ul>
<li>A0 - Pointer to the deferred plugin to use.</li>
<li>A2 - Pointer to the internal mixer channel structure, as provided by
the mixer when a plugin function is called.</li>
</ul></li>
</ul></li>
</ul>
<h4 id="pluginsasm-part">plugins.asm part</h4>
<p>The files plugins.asm and plugins.i contain the actual plugins, as
well as support routines and the requires structures for use by the
plugins. Depending on plugin configuration, plugins.asm also contains
lookup tables for real time volume changes.</p>
<p>Constant info follows:</p>
<ul>
<li><p>MXPLG_MULTIPLIER_4 / MXPLG_MULTIPLIER_32 /
MXPLG_MULTIPLIER_BUFSIZE<br />
These three constants are the three possible return values for the
support routine <em>MixPluginGetMultiplier()</em>.</p>
<ul>
<li>MXPLG_MULTIPLIER_4<br />
Mixer sample size multiplier is 4 bytes</li>
<li>MXPLG_MULTIPLIER_32<br />
Mixer sample size multiplier is 32 bytes</li>
<li>MXPLG_MULTIPLIER_BUFSIZE<br />
Mixer sample size multiplier is equal to the internal mixer channel
buffer size</li>
</ul></li>
<li><p>MXPLG_PITCH_STANDARD / MXPLG_PITCH_LOWQUALITY<br />
These two constants determine the type of pitch change is to be used by
the pitch change plugin.</p>
<ul>
<li>MXPLG_PITCH_STANDARD<br />
Use the standard (slower, but higher quality) pitch change
mechanism</li>
<li>MXPLG_PITCH_LOWQUALITY<br />
Use the faster, but lower quality pitch change mechanism</li>
</ul></li>
<li><p>MXPLG_PITCH_NO_PRECALC / MXPLG_PITCH_PRECALC<br />
These two constants determine whether or not the pitch plugin
initialisation function has to calculate the new length of the sample to
have its pitch changed, or that this value has been pre-calculated.</p>
<ul>
<li>MXPLG_PITCH_NO_PRECALC<br />
Pitch plugin initialisation calculated the new sample length in real
time</li>
<li>MXPLG_PITCH_PRECALC<br />
Pitch plugin initialisation assumes new sample length has been
pre-calculated</li>
</ul></li>
<li><p>MXPLG_VOL_TABLE / MXPLG_VOL_SHIFT<br />
These two constants determine whether the volume plugin uses lookup
tables, or real time shifting to change volume.</p>
<ul>
<li>MXPLG_VOL_TABLE<br />
The volume plugin uses lookup tables to change sample playback
volume</li>
<li>MXPLG_VOL_SHIFT<br />
The volume plugin uses real time shifts to change sample playback
volume</li>
</ul></li>
<li><p>MXPLG_SYNC_DELAY / MXPLG_SYNC_DELAY_ONCE / MXPLG_SYNC_START /
MXPLG_SYNC_END / MXPLG_SYNC_LOOP / MXPLG_SYNC_START_AND_LOOP<br />
These six constants determine which mode the synchronisation plugin
uses.</p>
<ul>
<li>MXPLG_SYNC_DELAY<br />
Synchronisation counts mixer interrupts until the given delay value is
reached, then triggers. The counter is then reset and the process
continues.</li>
<li>MXPLG_SYNC_DELAY_ONCE<br />
Synchronisation counts mixer interrupts until the given delay value is
reached, then triggers.</li>
<li>MXPLG_SYNC_START<br />
Synchronisation triggers at the start of sample playback.</li>
<li>MXPLG_SYNC_END<br />
Synchronisation triggers at the end of sample playback.</li>
<li>MXPLG_SYNC_LOOP<br />
Synchronisation triggers every time sample playback loops.</li>
<li>MXPLG_SYNC_START_AND_LOOP<br />
Synchronisation triggers at the start of sample playback and every time
sample playback loops.</li>
</ul></li>
<li><p>MXPLG_SYNC_ONE / MXPLG_SYNC_INCREMENT / MXPLG_SYNC_DECREMENT /
MXPLG_SYNC_DEFERRED<br />
These four constants determine the type of synchronisation used by the
synchronisation plugin.</p>
<ul>
<li>MXPLG_SYNC_ONE<br />
When synchronisation triggers, the address associated with the
synchronisation plugin is set to the word value 1.</li>
<li>MXPLG_SYNC_INCREMENT<br />
When synchronisation triggers, the address associated with the
synchronisation plugin is increased by the word value 1.</li>
<li>MXPLG_SYNC_DECREMENT<br />
When synchronisation triggers, the address associated with the
synchronisation plugin is decreased by the word value 1.</li>
<li>MXPLG_SYNC_DEFERRED<br />
When synchronisation triggers, the address associated with the
synchronisation plugin is called as a deferred plugin routine.</li>
</ul></li>
</ul>
<p>Variable info follows:</p>
<ul>
<li><p>mxplg_max_idata_size<br />
This variable contains the maximum size of any of the built-in plugin's
initialisation data structure.</p></li>
<li><p>mxplg_max_data_size<br />
This variable contains the maximum size of any of the built-in plugin's
data structure.</p></li>
</ul>
<p>Structure info follows:</p>
<ul>
<li><p>MXPDPitchInitData<br />
This structure contains the initialisation data for the pitch change
plugin</p>
<p>The MXPDPitchInitData structure has the following members:</p>
<ul>
<li><p>mpid_pit_mode<br />
The mode to use for the pitch plugin. Either
<em>MXPLG_PITCH_STANDARD</em> or <em>MXPLG_PITCH_LOWQUALITY</em>. The
latter is much faster, but also results in lower quality
output.</p></li>
<li><p>mpid_pit_precalc<br />
Whether or not the values in the <em>MXEffect</em> structure contain
pre-calculated values for the altered pitch sample's new length and loop
offset. Set using either <em>MXPLG_PITCH_NO_PRECALC</em> or
<em>MXPLG_PITCH_PRECALC</em>. If set to the former, the initialisation
routine will calculate the new length &amp; loop offset for the
<em>MXEffect</em> structure in real time, which costs extra CPU time.
(note that the plugin routine itself is unaffected)</p></li>
<li><p>mpid_pit_ratio_fp8<br />
The ratio to change the pitch by, given as a 8.8 fixed point math
number. The new sample pitch will be multiplied so a ratio of 0.5 will
halve the sample's pitch, while a ratio of 2.0 will double the pitch
(etc).</p></li>
<li><p>mpid_pit_length<br />
If <em>MXPLG_PITCH_PRECALC</em> is set, this field has to contain the
original length of the sample, without pitch shift.</p></li>
<li><p>mpid_pit_loop_offset<br />
If <em>MXPLG_PITCH_PRECALC</em> is set, this field has to contain the
original loop offset of the sample, without pitch shift.</p></li>
</ul></li>
<li><p>MXPDVolumeInitData<br />
This structure contains the initialisation data for the volume change
plugin</p>
<p>The MXPDVolumeInitData structure has the following members:</p>
<ul>
<li><p>mpid_vol_mode<br />
The mode to use for the volume plugin. Either <em>MXPLG_VOL_TABLE</em>
or <em>MXPLG_VOL_SHIFT</em>. The former uses a lookup table (byte based)
to change the volume, the latter uses shift instructions.</p></li>
<li><p>mpid_vol_volume<br />
The desired volume. For table lookups, this ranges from 0 (silence) to
15 (maximum volume). In case of shifts, this ranges from 0 (maximum
volume) to 8 (silence)</p>
<p>Note that the shift value for silence is dependent on the mixer mode
and the number of channels the mixer can mix (as set in
mixer_config.i)</p>
<pre><code>               Shift value for silence
HQ Mode/1-4 channels      8
Normal/1 channel          8
Normal/2 channels         7
Normal/3 channels         7
Normal/4 channels         6</code></pre></li>
</ul></li>
<li><p>MXPDRepeatInitData<br />
This structure contains the initialisation data for the repeat
plugin</p>
<p>The MXPDRepeatInitData structure has the following members:</p>
<ul>
<li>mpid_rep_delay<br />
The desired delay in mixer ticks. Mixer ticks occur roughly once per
frame, when the mixer interrupt triggers.</li>
</ul></li>
<li><p>MXPDSyncInitData<br />
This structure contains the initialisation data for the synchronisation
plugin</p>
<p>The MXPDSyncInitData structure has the following members:</p>
<ul>
<li><p>mpid_snc_address<br />
Set to the location in memory to use as output for the synchronisation
plugin. This location has to be 1 word wide.</p></li>
<li><p>mpid_snc_mode<br />
Set to the desired synchronisation mode. Several modes are available</p>
<ul>
<li>MXPLG_SYNC_DELAY<br />
Triggers every mpid_snc_delay ticks</li>
<li>MXPLG_SYNC_DELAY_ONCE<br />
Triggers once, after mpid_snc_delay ticks</li>
<li>MXPLG_SYNC_START<br />
Triggers once, at the start of playback</li>
<li>MXPLG_SYNC_END<br />
Triggers once, at the end of playback</li>
<li>MXPLG_SYNC_LOOP<br />
Triggers every time playback loops</li>
<li>MXPLG_SYNC_START_AND_LOOP<br />
Triggers at the start of playback and again every time playback
loops</li>
</ul></li>
<li><p>mpid_snc_type<br />
Set to the desired synchronisation type. Several types are available</p>
<ul>
<li>MXPLG_SYNC_ONE<br />
Writes the value one to the target address</li>
<li>MXPLG_SYNC_INCREMENT<br />
Increments the contents of the word at the target address by one</li>
<li>MXPLG_SYNC_DECREMENT<br />
Decrements the contents of the word at the target address by one</li>
<li>MXPLG_SYNC_DEFERRED<br />
Instead of changing the word at <em>mpid_snc_address</em>, this mode
uses the address in <em>mpid_snc_address</em> as the address of a
deferred plugin function, which will be called at the end of any
interrupt in which the chosen sync mode triggers.</li>
</ul></li>
<li><p>mpid_snc_delay<br />
The desired delay in mixer ticks. Mixer ticks occur roughly once per
frame, when the mixer interrupt triggers.</p></li>
</ul></li>
</ul>
<p>Support routine info follows:</p>
<ul>
<li><p><em>D0=MixerPluginGetMaxInitDataSize()</em> This routine returns
the maximum size of any of the built in plugin initialisation data
structures.</p></li>
<li><p><em>D0=MixerPluginGetMaxDataSize()</em> This routine returns the
maximum size of any of the built in plugin data structures.</p></li>
<li><p><em>D0=MixPluginGetMultiplier()</em><br />
This routine returns the type of sample size multiple the mixer expects.
This can be used instead of <em>MixerGetSampleMinSize()</em> if the
actual value is not relevant, only whether or not it's 4x, 32x or
(buffer_size)x.</p>
<p>Returns either <em>MXPLG_MULTIPLIER_4</em>,
<em>MXPLG_MULTIPLIER_32</em> or
<em>MXPLG_MULTIPLIER_BUFSIZE</em>.</p></li>
<li><p><em>MixPluginRatioPrecalc(A0=effect_structure, D0=pitch_ratio,
D1=shift_value)</em><br />
This routine can be used to pre-calculate length and loop offset values
for plugins that need these values divided by a FP8.8 ratio. The routine
calculates the values using a pointer to a filled <em>MXEffect</em>
structure in A0, the ratio value in D0 and the shift value in D1.</p>
<p>Currently this routine is only used by/for
<em>MixPluginPitch()</em>.</p>
<p>Note: the shift value passed to the routine is used to scale the
input to create a greater range than would normally be allowed. At a
shift of zero, the routine supports input &amp; output values of up to
65535. Increasing the shift value will increase these limits by a factor
of 2^shift factor, at a cost of an ever increasing inaccuracy.</p></li>
</ul>
<p>Built in plugin info follows:</p>
<ul>
<li><p>Because each plugin uses both an initialisation routine and a
plugin routine and the calling convention of each of these routines is
always the same, the initialisation and plugin routines will be
described without function prototypes and instead show the correct way
to set up the <em>MXPlugin</em> structure for the mixer instead, as well
as describe the functionality of the plugin, which initialisation data
structure to use and how to fill it.</p>
<ul>
<li><p><em>MixPluginInitDummy()</em> / <em>MixPluginDummy()</em><br />
This plugin performs no function and changes no data. It can be used in
place of calling an actual plugin to test plugin functionality, or as a
NO-OP plugin if the code written to call <em>MixerPlayFX()</em> or
<em>MixerPlayChannelFX()</em> in a specific program always wants to pass
a plugin, even if this is not required for the sample to be played.</p>
<p>MXPlugin setup</p>
<ul>
<li>mpl_plugin_type<br />
Determines the type of plugin. Either <em>MIX_PLUGIN_STD</em> or
<em>MIX_PLUGIN_NODATA</em></li>
<li>mpl_init_ptr<br />
Pointer to <em>MixPluginInitDummy()</em></li>
<li>mpl_plugin_ptr<br />
Pointer to <em>MixPluginDummy()</em></li>
<li>mpl_init_data_ptr<br />
contents of this field are ignored</li>
</ul></li>
<li><p><em>MixPluginInitRepeat()</em> / <em>MixPluginRepeat()</em><br />
This plugin repeats playback of the sample specified after a given
delay. It makes use of the <em>MXPDRepeatInitData</em> structure to pass
its parameter.</p>
<p>See the section Structures above for information how to set up this
structure.</p>
<p>MXPlugin setup</p>
<ul>
<li>mpl_plugin_type<br />
Set to <em>MIX_PLUGIN_NODATA</em></li>
<li>mpl_init_ptr<br />
Pointer to <em>MixPluginInitRepeat()</em></li>
<li>mpl_plugin_ptr<br />
Pointer to <em>MixPluginRepeat()</em></li>
<li>mpl_init_data_ptr<br />
Pointer to instance of structure <em>MXPDRepeatInitData</em></li>
</ul></li>
<li><p><em>MixPluginInitSync()</em> / MixPluginSync()<br />
This plugin is used to give synchronisation/timing information to the
program playing back samples using the mixer. If offers various modes
and types of this information. When the mode/type of the synchronisation
plugin triggers, it either writes a value to a given address, or calls
the routine at this address as a deferred plugin routine. The plugin
makes use of the <em>MXPDSyncInitData</em> structure to pass its
parameters.</p>
<p>See the section Structures above for information how to set up this
structure.</p>
<p>See the section Deferred plugin routine conventions for information
on how to use deferred plugin routines.</p>
<p>MXPlugin setup</p>
<ul>
<li>mpl_plugin_type<br />
Set to <em>MIX_PLUGIN_NODATA</em></li>
<li>mpl_init_ptr<br />
Pointer to <em>MixPluginInitSync()</em></li>
<li>mpl_plugin_ptr<br />
Pointer to <em>MixPluginSync()</em></li>
<li>mpl_init_data_ptr<br />
Pointer to instance of structure <em>MXPDSyncInitData</em></li>
</ul></li>
<li><p><em>MixPluginInitVolume()</em> / <em>MixPluginVolume()</em></p>
<p>This plugin is used to change the playback volume of the sample
specified. It operates either by using a lookup table or by using
shifts. In case of using lookup tables, it supports 16 volume levels: 0
= silence, 15 = maximum volume. In case of using shifts, 0 represents
maximum volume and silence is represented by either 8, 7 or 6 (depending
on the configured number of software channels per hardware channel). The
plugin makes use of the <em>MXPDVolumeInitData</em> structure to pass
its parameters.</p>
<p>See the section Structures above for information how to set up this
structure.</p>
<p>MXPlugin setup</p>
<ul>
<li>mpl_plugin_type<br />
Set to <em>MIX_PLUGIN_STD</em></li>
<li>mpl_init_ptr<br />
Pointer to <em>MixPluginInitVolume()</em></li>
<li>mpl_plugin_ptr<br />
Pointer to <em>MixPluginVolume()</em></li>
<li>mpl_init_data_ptr<br />
Pointer to instance of structure <em>MXPDVolumeInitData</em></li>
</ul></li>
<li><p><em>MixPluginInitPitch()</em> / <em>MixPluginPitch()</em></p>
<p>This plugin changes the pitch of the specified sample by a given
ratio. It offers two modes (standard and low quality) and has an option
to speed up the initialisation phase by using some pre-calculated
values. The ratio is given as a fixed point 8.8 value and represents the
value to use to multiply the original pitch value (so, 0.5 means playing
back at half pitch, 2.0 means playing back at double pitch, etc). The
plugin makes use of the <em>MXPDPitchInitData</em> structure to pass its
parameters.</p>
<p>See the section Structures above for information how to set up this
structure.</p>
<p>Note: using pre-calculated values for length &amp; offset does not
increase performance of the actual plugin, it only speeds up the
initialisation that runs when calling <em>MixerPlayFX()</em> or
<em>MixerPlayChannelFX()</em></p>
<p>MXPlugin setup:</p>
<ul>
<li>mpl_plugin_type<br />
Set to <em>MIX_PLUGIN_STD</em></li>
<li>mpl_init_ptr<br />
Pointer to <em>MixPluginInitPitch()</em></li>
<li>mpl_plugin_ptr<br />
Pointer to <em>MixPluginPitch()</em></li>
<li>mpl_init_data_ptr<br />
Pointer to instance of structure <em>MXPDPitchInitData</em></li>
</ul></li>
</ul></li>
</ul>
<p>Custom plugin routine conventions follow:</p>
<ul>
<li><p>Custom plugins, like regular plugins, consist of up to three
routines. These are plugin initialisation routines, plugin routines and
optionally deferred plugin routines. For more information on deferred
plugin routines, see the section "Deferred plugin routine conventions"
further down.</p></li>
<li><p>Custom plugin initialisation routine conventions:</p>
<ul>
<li>Initialisation routines have the following parameters:
<ul>
<li><p>A0 - Pointer to <em>MXEffect</em> structure as passed by
<em>MixerPlayFX()</em> or <em>MixerPlayChannelFX()</em></p></li>
<li><p>A1 - Pointer to plugin initialisation data structure, as passed
by <em>MixerPlayFX()</em> or <em>MixerPlayChannelFX()</em></p></li>
<li><p>A2 - Pointer to plugin data structure, as passed by
<em>MixerPlayFX()</em> or <em>MixerPlayChannelFX()</em>. This block of
memory is set up by the initialisation routine to contain the data the
plugin requires to work</p></li>
<li><p>D0 - Hardware channel/mixer channel (f.ex.
<em>DMAF_AUD0</em>|<em>MIX_CH1</em>)</p></li>
</ul></li>
<li>Depending on what the plugin itself needs, these parameters can be
omitted / left blank.</li>
<li>Initialisation routines have to preserve all registers</li>
<li>Initialisation routines should limit themselves to setting up the
data required for use by the plugin and any calculations (etc) to
achieve this. They should not be used for other purposes.</li>
<li>Initialisation routines can have any name, though following the
convention in plugins.i of naming them <em>MixPluginInit&lt;plugin
name&gt;</em> is suggested.</li>
</ul></li>
<li><p>Custom plugin routine conventions:</p>
<ul>
<li><p>Plugin routines have the following parameters:</p>
<ul>
<li><p>A0 - Pointer to the output buffer to use</p></li>
<li><p>A1 - Pointer to the plugin data</p></li>
<li><p>A2 - Pointer to the <em>MXChannel</em> structure for the current
channel (see note below)</p></li>
<li><p>D0 - Number of bytes to process</p></li>
<li><p>D1 - Loop indicator. Set to 1 if the sample has restarted at the
loop offset (or at its start in case the loop offset is not
set)</p></li>
</ul>
<h4
id="note-the-structure-passed-in-a2-is-an-internal-mixer-structure-which-may-change-between-versions-do-not-alter-its-contents-with-any-plugin-routines-it-is-provided-solely-to-enable-calling-mixersetplugindeferredptr-if-needed">Note:
the structure passed in A2 is an internal mixer structure which may
change between versions. Do not alter its contents with any plugin
routines. It is provided solely to enable calling
<em>MixerSetPluginDeferredPtr()</em>, if needed.</h4></li>
</ul></li>
<li><p>Depending on what the plugin itself needs, these parameters can
be omitted / left blank.</p></li>
<li><p>Plugin routines have to preserve all registers</p></li>
<li><p>Plugin routines are not allowed to call any mixer routine that
causes a new sample to be played. If this is needed, create a separate
deferred plugin routine that does call this/these routine(s). Then, in
the plugin routine call <em>MixerSetPluginDeferredPtr()</em> with the
function pointer for the deferred plugin routine instead.</p></li>
<li><p>Plugin routines should limit themselves to actions required for
the plugin and attempt to be a frugal as possible with the amount of CPU
time they use, as they run during the mixer interrupt.</p></li>
<li><p>Plugin routines can have any name, though following the
convention in plugins.i of naming them <em>MixPlugin&lt;plugin
name&gt;</em> is suggested.</p></li>
</ul>
<p>Deferred plugin routine conventions follow:</p>
<ul>
<li><p>Deferred plugin routines can be used to play back new samples
from plugins, without causing issues with the mixing loop. These
routines are sometimes needed by custom plugins.</p></li>
<li><p>Deferred plugin routine conventions</p>
<ul>
<li>Deferred plugin routines have the following parameters:
<ul>
<li><p>A0 - Pointer to the output buffer in use</p></li>
<li><p>A1 - Pointer to the plugin data</p></li>
</ul></li>
<li>Depending on what the plugin itself needs, these parameters can be
omitted / left blank.</li>
<li>Deferred plugin routines have to preserve all registers</li>
<li>Unlike plugin routines, deferred plugin routines are allowed to call
any mixer routine that causes a new sample to be played.</li>
<li>Deferred plugin routines should limit themselves to actions required
to play back new samples / after mixing is done and attempt to be as
frugal as possible with the amount of CPU time they use, as they run
during the mixer interrupt.</li>
<li>Deferred plugin routines can have any name, though following the
convention in plugins.asm of naming them <em>MixPlugin&lt;plugin
name&gt;Deferred</em> is suggested.</li>
</ul></li>
</ul>
<h3 id="converter-api">Converter API</h3>
<p>The mixer provides an assembly routine to help with converting
samples for use with the mixer at runtime. While this routine does use a
lookup table to improve division speed, it's still relatively slow and
thus not recommended for use with large amounts of sample data.</p>
<p>If large quantities of sample data need to be converted, consider
using the SampleConverter tool provided to deal with the conversion
before runtime instead.</p>
<h4 id="routine-info-follows-2">Routine info follows:</h4>
<ul>
<li><p><em>ConvertSampleDivide(A0=source_sample,A1=destination_sample,D0=length,
D1=number_of_channels)</em><br />
This routine converts the given sample to ensure enough headroom exists
to mix the sample using the mixer. It has four parameters:</p>
<ul>
<li><p>A0 - pointer to the start of the source sample</p></li>
<li><p>A1 - pointer to the start of the destination sample (this can be
identical to the source sample if desired)</p></li>
<li><p>D0 - length of the sample in bytes (note the limitations for
sample length used by the mixer apply, but are not checked for)</p></li>
<li><p>D1 - the number of channels to be mixed (this is the value of
<em>mixer_sw_channels</em> from mixer_config.i)</p></li>
</ul>
<p>The conversion routine will work with anywhere from 1 to 4 channels.
Note that conversion is not needed when running the mixer with
<em>mixer_sw_channels</em> set to 1 (the routine will simply copy data
when it's set to 1 channel).</p></li>
</ul>
<h3 id="performance-measuring-api">Performance measuring API</h3>
<p>If <em>MIXER_CIA_TIMER</em> is set to 1 in mixer_config.i, the mixer
provides several variables and a routine to measure the performance of
the mixer using the CIA-A timer A of the Amiga. In order to correctly
measure performance, the CIA-A timer A has to be available and no
interrupts of level 5+ must run, as those will interrupt the mixer
routines and skew the measured results.</p>
<p>Additionally, if <em>MIXER_COUNTER</em> is set to 1 in
mixer_config.i, the mixer provides two new routines to measure the
number of mixer interrupts that have fired since the last counter
reset.</p>
<p>In order to measure performance, the mixer interrupt handler must be
running and <em>MixerStart()</em> must have been called. This routine
also starts the CIA timer when it starts the Mixer.</p>
<p>Once <em>MixerStart()</em> has been called, the variables for storing
performance will start to get filled and the interrupt counter starts
running.</p>
<h4 id="variable-info-follows-1">Variable info follows:</h4>
<ul>
<li><p>mixer_ticks_last<br />
This variable contains the number of CIA timer ticks the last mixer
interrupt took to complete. It will be filled after at least one such
interrupt has occurred.</p></li>
<li><p>mixer_ticks_best<br />
This variable contains the lowest number of CIA timer ticks a mixer
interrupt has taken to complete to date. In most cases this will
represent the result of an idle interrupt (i.e. the mixer not playing
any samples). It will start being updated after at least one mixer
interrupt has occurred.</p></li>
<li><p>mixer_ticks_worst<br />
This variable contains the highest number of CIA timer ticks a mixer
interrupt has taken to complete to date. This is useful to see if mixer
CPU use causes performance issues. Mixer CPU use varies based on the
number of samples being mixed together as well as whether or not (many)
small* samples are playing/looping. This value will start being updated
after at least one mixer interrupt has occurred.</p>
<p>*) A sample is considered small when its length is (much) smaller
than the size of the mixer's playback buffer (either
<em>mixer_PAL_buffer_size</em> or <em>mixer_NTSC_buffer_size</em>
depending on selected video system).</p>
<p>This effectively means samples that last less than either 1/50th or
1/60th of a second.</p></li>
<li><p>mixer_ticks_average<br />
This variable initially contains no data. It can be filled with the
average time the mixer interrupt took over the last 128 frames by
calling the <em>MixerCalcTicks()</em> routine. Once filled, this value
gives an indication of the number of cycles the mixer takes in normal
use in the given program. The underlying values to be able to fill this
value start being updated in a circular buffer after at least one mixer
interrupt has occurred.</p>
<p>Note that this value can also be useful to measure performance of
playing back a certain combination of (looping) samples over time.
Simply run the mixer playing back this combination for at least 128
frames, stop the mixer using <em>MixerStop()</em> and then call
<em>MixerCalcTicks()</em> to see the average performance.</p></li>
</ul>
<h4 id="routine-info-follows-3">Routine info follows:</h4>
<ul>
<li><p><em>MixerCalcTicks()</em><br />
This routine calculates the average time the mixer interrupts took over
the last 128 frames by using a circular buffer. It adds the results of
the last 128 frames together and divides it by 128 to get the average
and store this value in <em>mixer_ticks_average</em>.</p></li>
<li><p><em>MixerResetCounter()</em><br />
This routine resets the mixer interrupt counter to 0.</p></li>
<li><p><em>D0=MixerGetCounter()</em><br />
This routine gets the current value of the mixer interrupt counter. The
counter is word sized.</p></li>
</ul>
<h3 id="using-the-mixer-in-c-programs">Using the mixer in C
programs</h3>
<p>In order to use the Mixer in C programs, several steps need to be
followed:</p>
<ul>
<li><p>The mixer configuration must be set up in mixer_config.i
(<em>MIXER_C_DEFS</em> must be set to 1)</p></li>
<li><p>mixer.asm must be assembled into an object file</p></li>
<li><p>mixer.o must be linked into the C program which is to use the
mixer</p></li>
<li><p>mixer.h must be included into the C program which is to use the
mixer</p>
<p>Note: mixer.h is designed for VBCC, Bebbo's GCC compiler and
Bartman's GCC compiler. Other compilers will need a different method for
calling the functions. It should be possible to make the mixer work with
other compilers, but only VBCC, Bebbo and Bartman are officially
supported.</p></li>
</ul>
<p>If the above is done, the mixer API (as described in <a
href="#mixer-api">"Mixer API"</a>) becomes available to the C program.
The C program will now need to follow the steps in <a
href="#using-the-mixer">"Using the mixer"</a> to enable mixing.</p>
<p>The complete function prototypes that can be used by C programs can
be found in mixer.h (note that this is the same set of routines that are
offered through mixer.i for assembly programs).</p>
<p>As pointed out above, the supplied mixer.h file is designed for use
with VBCC, Bebbo and Bartman. To use the mixer using other GCC based
compilers, a set of calling routines needs to be constructed. (these are
not provided in this package)</p>
<h4 id="two-examples-of-how-to-make-these-routines-follows">Two examples
of how to make these routines follows:</h4>
<pre><code>  // Assumes exec/types.h is available.
  // Example for calling MixerGetBufferSize
  inline UWORD call_MixerGetBufferSize()
  {
     register volatile UWORD _return_value __asm(&quot;d0&quot;);
     __asm__ volatile
     (
        &quot;jsr MixerGetBufferSize\n&quot;
        // OutputOperands
           : &quot;=d&quot; (_return_value)
        // InputOperands
           : /* no inputs */
        // Clobbers
           : &quot;cc&quot;, &quot;memory&quot;
      );
      return _return_value;
  }

  // Assumes exec/types.h is available.
  // Example for calling MixerSetup
  inline void call_MixerSetup(void *buffer, UWORD vidsys)
  {
     register volatile void *_buffer __asm(&quot;a0&quot;) = buffer;
     register volatile UWORD _vidsys __asm(&quot;d0&quot;) = vidsys;
     __asm__ volatile
     (
        &quot;jsr MixerSetup\n&quot;
        // OutputOperands
           : /* no outputs */
        // InputOperands
           : &quot;a&quot; (_buffer), &quot;d&quot; (_vidsys)
        // Clobbers
           : &quot;cc&quot;, &quot;memory&quot;
      );
      return ;
  }</code></pre>
<p>Examples courtesy of nivrig and Jobbo over at the AmigaGameDev
Discord.</p>
<p>Note that the examples above are provided merely as a starting point.
As pointed out earlier, C integration with other compilers than VBCC or
Bebbo's GCC compiler is not officially supported.</p>
<h3 id="troubleshooting">Troubleshooting</h3>
<p>This section of the documentation lists some possible problems when
using the mixer and potential solutions to them. In many cases, it can
be useful to set <em>MIXER_TIMING_BARS</em> to 1 in mixer_config.i when
troubleshooting as it helps identify whether or not the interrupt is
running correctly.</p>
<ol type="1">
<li><h4
id="issues-with-startup-or-shutdown-of-the-mixer-or-programs-using-it">Issues
with startup or shutdown of the mixer or programs using it</h4>
<ul>
<li><p>Calling <em>MixerInstallHandler()</em> immediately crashes the
system<br />
This is usually caused by setting a non-zero VBR value on 68000/68010
based systems (in particular an odd value). Try setting the VBR to 0 if
running on a 68000 or correct the VBR value if running on a 68010.</p>
<p>Note that some music players do not restore all registers after
calling their setup routines, which can result in the wrong VBR being
passed if the <em>MixerInstallHandler()</em> routine is called directly
after setting up or starting a music player.</p></li>
<li><p>Calling <em>MixerStart()</em> does not start the mixer, no
interrupts fire<br />
This is normally caused by setting an incorrect value of the VBR when
calling <em>MixerInstallHandler()</em>. Check to make sure the correct
value is passed.</p>
<p>Note that some music players do not restore all registers after
calling their setup routines, which can result in the wrong VBR being
passed if the <em>MixerInstallHandler()</em> routine is called directly
after setting up or starting a music player.</p></li>
<li><p>Calling <em>MixerInstallHandler()</em> causes many (hundreds) of
interrupts per frame<br />
This is usually caused by starting a music player that sets the audio
registers to an initial value even on channels which remain empty. Often
this is a one word loop, which can cause issues with the mixer as this
will cause the audio interrupts to trigger extremely frequently.</p>
<p>This can sometimes be solved by disabling the channel for music
playback using features of the music player chosen. In other cases it
can also be fixed by manually writing a volume of 0 and a length of
several hundred bytes in the audio channel(s) used by the mixer
immediately prior to calling <em>MixerInstallHandler()</em>.</p>
<p>Calling <em>MixerStart()</em> can also fix this, but in some cases so
many interrupts are generated that this is not possible.</p></li>
<li><p>Calling <em>MixerStart()</em> causes random audio glitches and
playing samples through the mixer does not work<br />
This is usually caused by a music player setting or resetting registers
on channels reserved for use by the mixer. If the channel configuration
for the mixer is set correctly, the music track used does not use the
channel(s) reserved for the mixer and the problem persists:</p>
<ul>
<li><p>try disabling the music channels in the player</p></li>
<li><p>if the player does not support this, it may be required to patch
the music player to not touch the audio channels used by the
mixer.</p></li>
<li><p>if all else fails, try using one of the two music players that
have been verified to work with the mixer: Frank Wille's PTPlayer 6.3+
or Arnaud Carr's LSP.</p></li>
</ul></li>
<li><p>Calling <em>MixerStart()</em> after interrupting the mixer using
<em>MixerStop()</em> does not restart samples/loops that were playing
before<br />
This is a known limitation of the mixer, calling <em>MixerStop()</em>
clears all mixer samples still in progress.</p></li>
<li><p>Exiting a program that uses the mixer to the OS does not stop
looping / playing samples<br />
This is caused by the mixer still running when the program exists. Call
<em>MixerStop()</em> and <em>MixerRemoveHandler()</em> prior to exiting
the program.</p></li>
<li><p>Exiting a program that uses the mixer to the OS causes a crash or
unexpected behaviour when another program is used later to play back
sound<br />
This is caused by not resetting the previously used interrupt vector for
the audio interrupt to it's original vector (i.e. the one in use prior
to starting the program the uses the mixer). Normally this can be fixed
by calling <em>MixerInstallHandler()</em> with D0 set to 0 to make sure
interrupt vector is saved for restoring by <em>MixerRemoveHandler()</em>
later.</p>
<p>If having the mixer save/restore the vector in this way is not
desired, it can also be fixed by manually saving/restoring the audio
interrupt vector.</p></li>
<li><p>Exiting a program that uses the mixer to the OS causes the
keyboard to stop working<br />
This is caused by setting <em>MIXER_CIA_TIMER</em> to 1 in
mixer_config.i, but not setting <em>MIXER_CIA_KBOARD_RES</em> to 1 in
mixer_config.i. Alternatively, it can also be caused by setting both
these values to 1 in mixer_config.i, but either not calling
<em>MixerRemoveHandler()</em> or calling it too early.</p>
<p>If OS keyboard restoring is desired in this case,
<em>MixerRemoveHandler()</em> needs to be called as late as possible.
Preferably as one of the last things prior to exiting the program and
certainly within 2-3 frames before the program exits.</p></li>
</ul></li>
<li><h4 id="issues-with-sample-playback">Issues with sample
playback</h4>
<ul>
<li><p>Playing back a sample through the mixer causes the system to
crash<br />
This is caused by running on a 68000/68010 based system and playing a
sample stored on an odd address in memory.</p></li>
<li><p>Playing a single sample back through the mixer sounds fine,
playing multiple samples through the mixer at the same time results in
heavily distorted audio<br />
This is caused by not properly pre-processing the samples. See <a
href="#pre-processing-samples">"Pre-processing samples"</a> for more
information.</p></li>
<li><p>Samples played back through the mixer are very quiet<br />
This can be caused by pre-processing the samples more than once, or by
using samples that were quiet to begin with. Note that apparent sample
playback volume using the mixer will always be lower than not using the
mixer due to the way the mixer works, but it can be made worse by using
samples that themselves are quiet to begin with.</p>
<p>For more information on generating/choosing samples for use with the
mixer in such a way that this problem is minimized, see <a
href="#best-practices-for-source-samples">"Best practices for source
samples"</a>.</p></li>
<li><p>Samples played back through the mixer are cut off prematurely or
have an audible pop/tick/glitch at the end<br />
The mixer plays back samples in blocks. These blocks are either 4 bytes,
32 bytes or <em>mixer_PAL_buffer_size</em>
(<em>mixer_NTSC_buffer_size</em> when running on a NTSC system) in
length. The length of the block is determined by how the mixer_config.i
file is set up.</p>
<p>The consequence of the mixer using blocks of bytes is that samples
themselves must also be multiples of this block size. To fix the audio
glitches, make sure that the samples are a multiple of this block size
in length by padding them to the nearest multiple with bytes filled with
0.</p>
<p>Note that the supplied SampleConverter tool automatically pads
samples with zeroes to a multiple of 4 bytes.</p></li>
<li><p>Samples played back in a loop don't loop seamlessly or have odd
repetition timing<br />
The mixer plays back samples in blocks. These blocks are either 4 bytes,
32 bytes or <em>mixer_PAL_buffer_size</em>
(<em>mixer_NTSC_buffer_size</em> when running on a NTSC system) in
length. The length of the block is determined by how the mixer_config.i
file is set up.</p>
<p>The consequence of the mixer using blocks of bytes is that loops are
also played back in multiples of this block size. This means that a
seamless loop must be an exact multiple of the block size in length. If
the samples are padded with zeroes to a multiple of the block size,
those empty bytes will still get played, which can alter the timing of
the loop.</p></li>
<li><p>Playing back very short samples in loops uses a lot of CPU
time<br />
Very short* looping samples require the mixer to potentially run the
mixing loop in smaller increments and/or more often. This increases CPU
overhead. To solve this issue, either play back longer loops or set
<em>MIXER_SIZEX32</em> to 1. This forces the mixer to always mix in
blocks of 32 bytes, which is faster than looping smaller amounts.</p>
<p>Note however that this setting does also imply that samples have to
be multiples of 32 bytes in size.</p>
<p>*) for this purpose, "very short" is technically any sample that is
less long than the amount of bytes played per frame by the mixer. The
shorter samples get below this threshold, the more CPU time they will
use to play back in a loop.</p></li>
<li><p>When playing back multiple looping samples at the same time, no
other samples will play<br />
The mixer will not overwrite looping samples with other samples, even if
they are of higher priority. To stop a looping sample, use the
<em>MixerStopFX()</em> routine with the hardware/mixer channel
combination the loop is playing on.</p>
<p>If all mixer channels are playing looping samples, stopping one or
more of them will allow other samples to play again.</p></li>
</ul></li>
<li><h4 id="callback-issues">Callback issues</h4>
<ul>
<li><p>The callback function set does not fire when samples end<br />
This is usually caused by not having enabled callback functionality in
mixer_config.i. To enable callback functionality, set
<em>MIXER_ENABLE_CALLBACK</em> to 1 in mixer_config.i</p></li>
<li><p>The callback function does not trigger when samples loop, nor
when <em>MixerStop()</em> or <em>MixerStopFx()</em> is called<br />
Callbacks only trigger when a sample stops playback by reaching its end,
they do not trigger when samples loop, or are ended by calling
<em>MixerStop()</em> or <em>MixerStopFx()</em>.</p></li>
<li><p>The callback function does trigger, but new samples played back
by it do not seamlessly follow the end of the old sample<br />
This is caused by not playing back the new sample correctly. In order to
get seamless playback, the callback routine has to play the new sample
on the same mixer channel as the old sample just ended on. Then, it
needs to set D0 to 1 as a return value prior to returning.</p></li>
<li><p>When a callback triggers, the mixer either crashes or starts
behaving in a weird way<br />
This is either caused by not properly saving and restoring all registers
other than D0, or by setting D0 to a non-zero value prior to returning
while not starting a new sample on the channel of the sample that just
ended playback.</p></li>
</ul></li>
<li><h4 id="plugin-issues">Plugin issues</h4>
<ul>
<li><p>Plugins attached to samples do not activate<br />
This is either caused by not having plugin support enabled in
mixer_config.i, by setting the <em>mfx_plugin_ptr</em> to 0 (or NULL in
C programs) or by not filling the MXPlugin structure correctly.</p></li>
<li><p>When a plugin is attached to a sample, the mixer plays silence
for that sample<br />
This is caused by setting <em>mpl_plugin_type</em> to
<em>MIX_PLUGIN_STD</em> for plugins that do not output data. Set
<em>mpl_plugin_type</em> to <em>MIX_PLUGIN_NODATA</em> for these type of
plugins.</p>
<p>Alternatively, this can also be caused by setting the plugin
initialisation data to values that cause silent output, such as setting
the volume plugin to table lookup with volume 0.</p></li>
<li><p>When a built-in plugin is attached to a sample, the mixer
crashes, the plugin behaves weirdly or the mixer behaves weirdly<br />
This is usually caused by setting up the <em>MXPlugin</em> structure
incorrectly.</p>
<p>Here are some possible problems:</p>
<ul>
<li>the pointer set in <em>mfx_plugin_ptr</em> is not pointing to the
correct location</li>
<li>the pointer(s) set in either <em>mpl_init_ptr</em>,
<em>mpl_plugin_ptr</em> or <em>mpl_init_data_ptr</em> are not
correct</li>
</ul></li>
<li><p>When a custom plugin is attached to a sample, the mixer crashes,
the plugin behaves weirdly or the mixer behaves weirdly<br />
This can have various reasons, the most common ones are:</p>
<ul>
<li>There are issues in the set up of the <em>MXPlugin</em> structure,
such as the ones named in the problem above</li>
<li>The custom plugin attempts to play back new samples without using a
a deferred plugin routine</li>
<li>The custom plugin does not correctly save and restore registers</li>
<li>The custom plugin initialisation data was not correct</li>
<li>The custom plugin inadvertently takes so much CPU time that the
mixer interrupt starts to overrun the starting time of the next
interrupt</li>
<li>The custom plugin routine might require a 68020 or better and is
being used on a 68000</li>
</ul></li>
<li><p>CPU use goes up dramatically when playing back (several) samples
using the Volume or Pitch plugins<br />
These plugins use a lot of CPU time, especially on a 7MHz
68000.</p></li>
<li><p>When using the Pitch plugin, the sample's pitch does not sound
correct or it has odd distortions<br />
The Pitch plugin resamples the sample data to a new pitch given a ratio.
This is unlike module players or manually playing back samples, in which
case changing pitch means changing the playback period. Resampling can
introduce aliasing, which is the cause behind the incorrect pitch or odd
distortions heard.</p>
<p>To limit aliasing, make sure that the period of the mixer is set high
enough to correctly play back the highest frequency sample post pitch
change. This can be done by either limiting the ratio of pitch change
applied, or by doing spectrum analysis of the sample in audio processing
software and adjusting the mixer playback period based on that.</p>
<p>Note that the low quality Pitch change mode is much more likely to
cause these kind of distortions.</p></li>
</ul></li>
<li><h4 id="other-issues">Other issues</h4>
<ul>
<li><p>The makefile does not work / gives errors<br />
The makefile was created to work on Windows based systems, on other OS's
the paths need to be changed to use the correct slash type. Similarly,
the makefile was created to work using VASM, VLINK and VBCC and expects
them in the path. If the makefile is changed to use a different
assembler, linker or compiler is chosen, the makefile might need further
changes.</p>
<p>Note that a makefile_unix.mak file is provided that does use the
correct slashes and uses standard Unix commands for file access. Try
using this file, editting it as needed.</p></li>
<li><p>Assembling the mixer generates messages and results in a
non-working object file<br />
This is caused by a non-valid configuration in mixer_config.i. Check the
number of channels selected, the output channels selected and whether
only one mixer type has been configured.</p></li>
<li><p>Assembling the mixer generates assembler errors<br />
This can be caused by using a different assembler than VASM. In
particular, the mixer.asm file uses the echo directive and many macro's.
The use of the echo directive can be disabled in mixer_config.i, the
macro's are integral to the mixer.</p>
<p>In case of issues, it's recommended to use VASM &amp; VLINK to
assemble and link the mixer instead of other
assemblers/linkers.</p></li>
<li><p>On a 68020+ system, performance is much lower than expected<br />
This is caused by either not setting <em>MIXER_68020</em> to 1 in
mixer_config.i, or by having either the mixer buffers or sample source
data not aligned on 4 byte boundaries.</p>
<p>For optimal performance on 68020+ systems, set <em>MIXER_68020</em>
to 1 in mixer_config.i and make sure the mixer buffers and all samples
used are aligned on 4 byte boundaries.</p></li>
<li><p>The mixer does not work correctly on a highly expanded system
and/or causes issues on FPGA based systems / emulators<br />
The mixer has been designed to enable fast mixing on low end Amiga
systems. It should be compatible across a large number of
configurations, but certain setups may cause issues.</p>
<p>In particular, highly expanded Amiga's might contain expansions that
are incompatible with disabling the OS. In this case, disable the
expansions or try using a wrapper such as WHDLoad. In case of hardware
CPU emulators such as the PiStorm, make sure it is set up to be as
compatible as possible.</p>
<p>Another possible issue can arise with emulators or FPGA systems. On
such environments, it is required that the Amiga chipset and 68000 must
be emulated/implemented in a compatible manner. Try setting the emulator
or FPGA system used to the most compatible settings possible (for
instance, the mixer will run just fine on WinUAE when it is set to cycle
exact mode and does not have JIT active).</p>
<p>If setting your FPGA system/emulator of choice to its most compatible
settings does not solve the issue, contact the creator of the emulator /
FPGA system for support.</p></li>
</ul></li>
</ol>
<h3 id="performance-data">Performance data</h3>
<p>The performance of the mixer depends on the chosen configuration and
target system. To give an idea of what performance to expect, results
for several period values and other settings have been compiled into a
table, which is included below. The value given is the percentage of CPU
time used per frame.</p>
<p>Note that performance figures for <em>MIXER_MULTI=1</em> also apply
to <em>MIXER_MULTI_PAIRED=1</em> and are the results for playing back on
a single hardware channel. Adding extra hardware channels basically
scales linearly.</p>
<p>For reference, the results of the previous version of the mixer (2.0)
are also included. Note that these are slightly worse than reported on
the website or in the example program for mixer version 2.0. The
difference is due to a new method for measuring performance. The old
method incorrectly excluded part of the overhead involved in dealing
with the interrupt and setting hardware registers.</p>
<h4 id="about-the-used-configurations--systems">About the used
configurations &amp; systems:</h4>
<ul>
<li><p>Standard = no optimisations enabled</p></li>
<li><p>Optimised = <em>MIXER_SIZEXBUF</em>=1 and
<em>MIXER_WORDSIZED</em>=1</p>
<p>Note that on systems with a 68020+, optimised has MIXER_68020=1 set
instead</p></li>
<li><p>A500/slow = 68000@7MHz, 512KB Chip RAM / 512KB Slow RAM*</p></li>
<li><p>A500/fast = 68000@7MHz, 512KB Chip RAM / 512KB Fast RAM</p></li>
<li><p>A1200/chip = 68020@14MHz, 2MB Chip RAM</p></li>
<li><p>A1200/fast = 68020@14MHz, 2MB Chip RAM / 8MB Fast RAM</p></li>
<li><p>A1200/030 = 68030@50MHz, 2MB Chip RAM / 16MB Fast RAM</p>
<p>*) i.e. a standard trapdoor RAM expansion</p></li>
</ul>
<h4 id="results-for-mixer-without-callback-or-plugin-support">Results
for mixer without callback or plugin support</h4>
<h4 id="8khz-period--443">8KHz (period = 443):</h4>
<table>
<thead>
<tr>
<th>Standard</th>
<th>A500/slow</th>
<th>A1200/chip</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single 3 chan</td>
<td>2,5%</td>
<td>1,3%</td>
</tr>
<tr>
<td>Single 4 chan</td>
<td>3,0%</td>
<td>1,5%</td>
</tr>
<tr>
<td>Single 3 chan (HQ)</td>
<td>8,4%</td>
<td>3,6%</td>
</tr>
<tr>
<td>Single 4 chan (HQ)</td>
<td>9,9%</td>
<td>4,4%</td>
</tr>
<tr>
<td>Multi 3 chan</td>
<td>2,6%</td>
<td>1,3%</td>
</tr>
<tr>
<td>Multi 4 chan</td>
<td>3,1%</td>
<td>1,6%</td>
</tr>
<tr>
<td>Multi 3 chan (HQ)</td>
<td>8,5%</td>
<td>3,7%</td>
</tr>
<tr>
<td>Multi 4 chan (HQ)</td>
<td>10,0%</td>
<td>4,4%</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Optimised</th>
<th>A500/slow</th>
<th>A1200/chip</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single 3 chan</td>
<td>2,2%</td>
<td>1,3%</td>
</tr>
<tr>
<td>Single 4 chan</td>
<td>2,7%</td>
<td>1,5%</td>
</tr>
<tr>
<td>Multi 3 chan</td>
<td>2,3%</td>
<td>1,3%</td>
</tr>
<tr>
<td>Multi 4 chan</td>
<td>2,8%</td>
<td>1,6%</td>
</tr>
</tbody>
</table>
<h4 id="11khz-period--322">11KHz (period = 322):</h4>
<table>
<thead>
<tr>
<th>Standard</th>
<th>A500/slow</th>
<th>A1200/chip</th>
<th>A500/fast</th>
<th>A1200/fast</th>
<th>A1200/030</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single 3 chan</td>
<td>3,0%</td>
<td>1,5%</td>
<td>2,9%</td>
<td>0,9%</td>
<td>0,5%</td>
</tr>
<tr>
<td>Single 4 chan</td>
<td>3,7%</td>
<td>1,9%</td>
<td>3,7%</td>
<td>1,0%</td>
<td>0,5%</td>
</tr>
<tr>
<td>Single 3 chan (HQ)</td>
<td>11,1%</td>
<td>4,7%</td>
<td>11,1%</td>
<td>4,0%</td>
<td>1,4%</td>
</tr>
<tr>
<td>Single 4 chan (HQ)</td>
<td>13,1%</td>
<td>5,7%</td>
<td>3,5%</td>
<td>1,0%</td>
<td>0,5%</td>
</tr>
<tr>
<td>Multi 3 chan</td>
<td>3,1%</td>
<td>1,6%</td>
<td>3,0%</td>
<td>0,9%</td>
<td>0,5%</td>
</tr>
<tr>
<td>Multi 4 chan</td>
<td>3,8%</td>
<td>1,9%</td>
<td>3,7%</td>
<td>1,0%</td>
<td>0,6%</td>
</tr>
<tr>
<td>Multi 3 chan (HQ)</td>
<td>11,2%</td>
<td>4,8%</td>
<td>10,9%</td>
<td>4,0%</td>
<td>1,5%</td>
</tr>
<tr>
<td>Multi 4 chan (HQ)</td>
<td>13,2%</td>
<td>5,8%</td>
<td>12,9%</td>
<td>4,7%</td>
<td>1,7%</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Optimised</th>
<th>A500/slow</th>
<th>A1200/chip</th>
<th>A500/fast</th>
<th>A1200/fast</th>
<th>A1200/030</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mixer 2.0 4ch</td>
<td>3,4%</td>
<td>n.a.</td>
<td>n.a.</td>
<td>n.a.</td>
<td>n.a.</td>
</tr>
<tr>
<td>Single 3 chan</td>
<td>2,7%</td>
<td>1,5%</td>
<td>2,7%</td>
<td>0,8%</td>
<td>0,4%</td>
</tr>
<tr>
<td>Single 4 chan</td>
<td>3,4%</td>
<td>1,9%</td>
<td>3,4%</td>
<td>1,0%</td>
<td>0,5%</td>
</tr>
<tr>
<td>Multi 3 chan</td>
<td>2,8%</td>
<td>1,6%</td>
<td>2,7%</td>
<td>0,8%</td>
<td>0,5%</td>
</tr>
<tr>
<td>Multi 4 chan</td>
<td>3,5%</td>
<td>1,9%</td>
<td>3,4%</td>
<td>0,9%</td>
<td>0,5%</td>
</tr>
</tbody>
</table>
<p>Entries marked as n.a. were not measured (but can be
configured/work).</p>
<h4 id="22khz-period--161">22KHz (period = 161):</h4>
<table>
<thead>
<tr>
<th>Standard</th>
<th>A500/slow</th>
<th>A1200/chip</th>
<th>A500/fast</th>
<th>A1200/fast</th>
<th>A1200/030</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single 3 chan</td>
<td>4,9%</td>
<td>2,5%</td>
<td>4,9%</td>
<td>1,4%</td>
<td>0,7%</td>
</tr>
<tr>
<td>Single 4 chan</td>
<td>6,2%</td>
<td>3,2%</td>
<td>6,2%</td>
<td>1,6%</td>
<td>0,8%</td>
</tr>
<tr>
<td>Single 3 chan (HQ)</td>
<td>20,7%</td>
<td>8,8%</td>
<td>20,8%</td>
<td>7,6%</td>
<td>2,6%</td>
</tr>
<tr>
<td>Single 4 chan (HQ)</td>
<td>24,8%</td>
<td>10,6%</td>
<td>24,8%</td>
<td>9,0%</td>
<td>3,6%</td>
</tr>
<tr>
<td>Multi 3 chan</td>
<td>5,0%</td>
<td>2,6%</td>
<td>4,8%</td>
<td>1,5%</td>
<td>0,9%</td>
</tr>
<tr>
<td>Multi 4 chan</td>
<td>6,3%</td>
<td>3,1%</td>
<td>6,1%</td>
<td>1,6%</td>
<td>0,9%</td>
</tr>
<tr>
<td>Multi 3 chan (HQ)</td>
<td>20,8%</td>
<td>8,8%</td>
<td>20,3%</td>
<td>7,6%</td>
<td>2,6%</td>
</tr>
<tr>
<td>Multi 4 chan (HQ)</td>
<td>25,0%</td>
<td>10,7%</td>
<td>24,3%</td>
<td>9,0%</td>
<td>3,6%</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Optimised</th>
<th>A500/slow</th>
<th>A1200/chip</th>
<th>A500/fast</th>
<th>A1200/fast</th>
<th>A1200/030</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single 3 chan</td>
<td>4,7%</td>
<td>2,5%</td>
<td>4,7%</td>
<td>1,3%</td>
<td>0,7%</td>
</tr>
<tr>
<td>Single 4 chan</td>
<td>5,9%</td>
<td>3,2%</td>
<td>5,6%</td>
<td>1,6%</td>
<td>0,8%</td>
</tr>
<tr>
<td>Multi 3 chan</td>
<td>4,8%</td>
<td>2,6%</td>
<td>4,6%</td>
<td>1,3%</td>
<td>0,7%</td>
</tr>
<tr>
<td>Multi 4 chan</td>
<td>6,0%</td>
<td>3,3%</td>
<td>5,8%</td>
<td>1,6%</td>
<td>0,8%</td>
</tr>
</tbody>
</table>
<h4 id="results-for-mixer-with-callback-andor-plugin-support">Results
for mixer with callback and/or plugin support</h4>
<table>
<thead>
<tr>
<th>Standard</th>
<th>A500/slow</th>
<th>A1200/chip</th>
<th>A500/fast</th>
<th>A1200/fast</th>
<th>A1200/030</th>
</tr>
</thead>
<tbody>
<tr>
<td>Callback (idle)</td>
<td>3,7%</td>
<td>2,0%</td>
<td>3,7%</td>
<td>1,0%</td>
<td>0,5%</td>
</tr>
<tr>
<td>Plugin (idle)</td>
<td>4,1%</td>
<td>2,3%</td>
<td>4,0%</td>
<td>1,1%</td>
<td>0,6%</td>
</tr>
<tr>
<td>Callback + plugin (idle)</td>
<td>4,1%</td>
<td>2,3%</td>
<td>4,0%</td>
<td>1,1%</td>
<td>0,6%</td>
</tr>
</tbody>
</table>
<p>Tests done @11KHz, 4 mixer channels, 1 hardware channel</p>
<h4 id="results-for-supplied-plugins">Results for supplied plugins</h4>
<table>
<thead>
<tr>
<th>Standard</th>
<th>A500/slow</th>
<th>A1200/chip</th>
<th>A500/fast</th>
<th>A1200/fast</th>
<th>A1200/030</th>
</tr>
</thead>
<tbody>
<tr>
<td>Repeat</td>
<td>4,4%</td>
<td>2,5%</td>
<td>4,4%</td>
<td>1,2%</td>
<td>0,7%</td>
</tr>
<tr>
<td>Sync</td>
<td>4,8%</td>
<td>2,8%</td>
<td>4,8%</td>
<td>1,3%</td>
<td>0,7%</td>
</tr>
<tr>
<td>Volume (table)</td>
<td>24,9%</td>
<td>11,1%</td>
<td>24,8%</td>
<td>7,1%</td>
<td>2,9%</td>
</tr>
<tr>
<td>Volume (shift)</td>
<td>25,4%</td>
<td>10,8%</td>
<td>25,4%</td>
<td>6,9%</td>
<td>2,7%</td>
</tr>
<tr>
<td>Pitch (Low Quality)</td>
<td>17,0%</td>
<td>6,1%</td>
<td>17,0%</td>
<td>3,8%</td>
<td>1,8%</td>
</tr>
<tr>
<td>Pitch (Standard)</td>
<td>32,6%</td>
<td>11,1%</td>
<td>32,6%</td>
<td>6,9%</td>
<td>2,7%</td>
</tr>
</tbody>
</table>
<p>Tests done @11KHz, 4 mixer channels, 1 hardware channel. Plugins
active on all 4 channels</p>
<h3 id="best-practices-for-source-samples">Best practices for source
samples</h3>
<p>In order to get the best possible results out of the mixer, the
samples used by the mixer should be chosen/designed around the way the
mixer works. The primary issue when playing back sounds through the
mixer is that the apparent volume of samples that are played back goes
down due to the required pre- processing.</p>
<p>Note: running the mixer in HQ mode resolves these issues without
needing to deal with special audio quality requirements for samples.
This does use much more CPU time, though.</p>
<h4 id="there-are-two-ways-to-deal-with-this-issue">There are two ways
to deal with this issue:</h4>
<ol type="1">
<li><p>lower the maximum number of samples mixed together by lowering
<em>mixer_sw_channels</em> in mixer_config.i. This will allow
pre-processing samples for fewer voices, which will increase the
apparent volume. The obvious drawback of this approach is that the mixer
will support playing back fewer samples at the same time.</p></li>
<li><p>use audio processing software to lower the dynamic range of the
samples and push them as close as possible to maximum volume. This can
be done using both compressors, limiters and
"loudness-normalising"*.</p>
<p>*) Note that this is not the same as "normalising", which doesn't
change perceived loudness.</p></li>
</ol>
<p>Other than the above methods, the best practice is to generate/choose
source samples that are "as loud as possible" and have fairly low
dynamic range. This does not mean that samples can't have dynamic range,
but be aware that the mixer works best with samples that do not have
large swings in volume.</p>
<p>A second issue that is faced by samples played back by the mixer is
that the signal to noise ratio will be worse due to the lower number of
effective bits the mixer has available for samples, while the output
hardware and it's limits have not changed. As such, it's recommended to
avoid using samples that require a very low signal to noise ratio to
sound well.</p>
<h3 id="acknowledgements">Acknowledgements</h3>
<p>The mixer examples use some code made by others and use music and
samples made by others as well. In addition to that, several people have
helped me during the development of the mixer. In this section, I show
my appreciation for the help and free resources offered by these
people.</p>
<h4
id="thanks-for-advice-help-and-support-during-my-coding-efforts-go-to">Thanks
for advice, help and support during my coding efforts go to:</h4>
<ul>
<li>h0ffman at the AmigaGameDev Discord for testing an early version of
the mixer and providing feedback and suggestions</li>
<li>nivrig, KaiN and Jobbo at the AmigaGameDev Discord for help
integrating the mixer in C programs</li>
<li>agermose at the AmigaGameDev discord for providing unsigned 32 to 32
bit long division code for use in the plugins</li>
<li>McGeezer for providing the AmigaGameDev Discord</li>
<li>And undoubtedly others I've forgotten!</li>
</ul>
<h4
id="thanks-for-resources-and-code-ive-been-able-to-use-in-this-project-go-to">Thanks
for resources and code I've been able to use in this project go to:</h4>
<ul>
<li><p>The mixer examples use the module SneakyChick.mod, which was
kindly provided to me on a freeware/non-commercial use basis by Roald
Strauss @ IndieGameMusic.com. Further distribution/use of this module
requires a license. Visit <a
href="https://indiegamemusic.com/">IndieGameMusic.com</a> to license
this or one of the many other tracks they provide for use in your own
productions.</p></li>
<li><p>The mixer examples uses several samples provided on freesound.org
under the Creative Commons CC0 license. These samples are:</p>
<ul>
<li><a
href="https://freesound.org/people/egomassive/sounds/536741/">https://freesound.org/people/egomassive/sounds/536741/</a></li>
<li><a
href="https://freesound.org/people/Daleonfire/sounds/376694/">https://freesound.org/people/Daleonfire/sounds/376694/</a></li>
<li><a
href="https://freesound.org/people/GameAudio/sounds/220173/">https://freesound.org/people/GameAudio/sounds/220173/</a></li>
<li><a
href="https://freesound.org/people/derplayer/sounds/587196/">https://freesound.org/people/derplayer/sounds/587196/</a></li>
<li><a
href="https://freesound.org/people/Latranz/sounds/520200/">https://freesound.org/people/Latranz/sounds/520200/</a></li>
<li><a
href="https://freesound.org/people/NovaSoundTechnology/sounds/118750/">https://freesound.org/people/NovaSoundTechnology/sounds/118750/</a></li>
<li><a
href="https://freesound.org/people/aunrea/sounds/495658/">https://freesound.org/people/aunrea/sounds/495658/</a></li>
<li><a
href="https://freesound.org/people/skymary/sounds/412017/">https://freesound.org/people/skymary/sounds/412017/</a></li>
</ul>
<p>The full text of the CC0 license can be found here: <a
href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">https://creativecommons.org/publicdomain/zero/1.0/legalcode</a></p></li>
<li><p>The mixer examples use PT Player 6.3 by Frank Wille, who has
released this ProTracker player under a public domain license.</p></li>
<li><p>The mixer examples use LSP 1.10 by Arnaud Carr, who has released
this ProTracker converter/player under the MIT license.</p></li>
<li><p>The mixer plugins use unsigned 32 to 32 bit long division code by
agermose on the AmigaGameDev discord.</p></li>
<li><p>The mixer examples use startup code by Henrik Erlandsson, who has
released this code under the MIT license.</p></li>
<li><p>The mixer examples use Joystick reading code based on a forum
thread on eab.abime.net (<a
href="https://eab.abime.net/showpost.php?p=986196&amp;postcount=2">https://eab.abime.net/showpost.php?p=986196&amp;postcount=2</a>).</p></li>
</ul>
<p>Full license information for the PT Player, LSP converter/player and
startup code can be found in LICENSE files included in their respective
directories.</p>
<h3 id="licensedisclaimer">License/Disclaimer</h3>
<p>With exception of the items listed in the <a
href="#acknowledgements">"Acknowledgements"</a> section of this
document, all code, documentation and other files fall under the
following license:</p>
<p>Copyright (c) 2023-2024 Jeroen Knoester</p>
<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
Software), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>
<p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
