<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* 
{
  box-sizing: border-box;
}

body 
{
  font-family: Arial, Helvetica, sans-serif;
}

/* Style the header */
header 
{
  background-color: #666;
  padding: 1px;
  text-align: center;
  font-size: 35px;
  color: white;
}

/* Style the footer */
footer 
{
  background-color: #777;
  padding: 10px;
  text-align: center;
  color: white;
}

table {
  font-family: arial, sans-serif;
  border-collapse: collapse;
  width: 100%;
}

td, th {
  border: 1px solid #777777;
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {
  background-color: #dddddd;
}

/* Create two unequal columns that float next to each other */
.column 
{
  float: left;
  padding: 10px;
}

.left 
{
  width: 25%;
}

.right 
{
  width: 75%;
}

/* Clear floats after the columns */
.row:after 
{
  content: "";
  display: table;
  clear: both;
}
</style>
</head>
<body>

<header>
<h3>Audio Mixer 3.6 documentation</h2>
</header>

<div class="row">
  <div class="column left" style="background-color:#aaa;">
    <h2>Table of Contents</h2>
	<p><a href="#overview">Overview</a></p>
	<p><a href="#releasenotes">Release notes</a></p>
	<p><a href="#requirements">Requirements</a></p>
	<p><a href="#configuration">Configuration</a></p>
	<p><a href="#assembling">Assembling the mixer, converter, examples &amp; tools</a></p>
	<p><a href="#pre-processing">Pre-processing samples</a></p>
	<p><a href="#using">Using the mixer</a></p>
	<p><a href="#combining">Combining the mixer and a music player</a></p>
	<p><a href="#examples">Examples</a></p>
	<p><a href="#tools">Tools</a></p>
	<p><a href="#api_changes">API Changes between version 3.1/3.2 and 3.6</a></p>
	<p><a href="#mixer_api">Mixer API</a></p>
	<p><a href="#callback_api">Callback API</a></p>
	<p><a href="#plugin_api">Plugin API</a></p>
	<p><a href="#converter_api">Converter API</a></p>
	<p><a href="#performance_api">Performance measuring API</a></p>
	<p><a href="#using_c">Using the mixer in C programs</a></p>
	<p><a href="#troubleshooting">Troubleshooting</a></p>
	<p><a href="#performance_data">Performance data</a></p>
	<p><a href="#best_practices">Best practices for source samples</a></p>
	<p><a href="#acknowledgements">Acknowledgments</a></p>
	<p><a href="#license">License/Disclaimer</a></p>
  </div>
  <div class="column right" style="background-color:#bbb;">
<h3 id="overview">Overview</h3>
<p>The Audio Mixer is a configurable SFX engine designed to play back multiple 
samples at the same time on a single hardware channel. It achieves a high 
level of performance on even low end Amiga's (such as the A500) by making use
of optimised code and pre-processed samples. It is designed to be able to 
co-exist with music playback routines, as long as the music playback routine 
supports disabling access/playback to the hardware channel(s) the Audio Mixer
uses.</p>

<p>If desired, multiple hardware channels can be assigned to the Audio Mixer,
allowing for even more samples to be played at the same time. The Audio Mixer
supports native Amiga audio through Paula only and is designed for use in
programs that disable the OS.</p>

<p><h4>Features:</h4>
   <UL>
   <LI>Up to four samples can be mixed onto a single hardware channel.</LI>
   <LI>High performance: mixing four samples onto a single channel at 11KHz 
       takes only 3.7% CPU time on a 7MHz 68000 without Fast RAM.</LI>
   <LI>Optional high quality mode that uses much more CPU time, but plays full
       8-bit samples, rather than lower quality pre-processed ones.</LI>
   <LI>Can be run while a music playback routine is running, as long as the 
       music routine does not access the hardware channel(s) used by the Audio
       Mixer.</LI>
   <LI>Up to four hardware channels can be assigned to the Audio Mixer, allowing 
       up to 16 samples being played back at the same time.</LI>
   <LI>Sample playback is priority based, so that drowning out of important 
       effects can be prevented.</LI>
   <LI>Samples can be stored anywhere in RAM, including in Fast RAM and Slow
       RAM.</LI>
   <LI>Samples can be set to loop from either sample start, or from a given 
       offset into the sample and both looping/non-looping samples can be
       stopped on request.</LI>
   <LI>Samples can be assigned to one of the virtual channels the mixer uses (up 
       to 4 per hardware channel), allowing fine-grained control of SFX 
       playback.</LI>
   <LI>Supports the use of optional plugins via a plugin system. These plugins
       can either be used as control/communication mechanism to other code, or
       to alter sample data in real time. There are several plugins included and
       custom plugins are also supported.<br>

       The included plugins are:
	   <UL>
       <LI><em>MixPluginRepeat()</em><UL>
           <LI>Plays the sample sample again after a given delay.</LI></UL></LI>
       <LI><em>MixPluginSync()</em><UL>
           <LI>Allows various ways to synchronise sample playback with the
           code that calls the mixer.</LI></UL></LI>
       <LI><em>MixPluginVolume()</em><UL>
           <LI>Allows changing of the playback volume of the sample being
           played.</LI></UL></LI>
       <LI><em>MixPluginPitch()</em><UL>
           <LI>Allows changing of the pitch of the sample being played.</LI></UL></LI></UL>
   <LI>Supports the use of a callback routine whenever sample playback ends, to
       allow custom code to be executed on sample end. The callback routine can
       immediately play back another sample if desired, which allows for 
       seamless sample-to-sample playback using this method.</LI>
   <LI>Supports playback of samples of any size that will fit in RAM*.</LI>
   <LI>Sample rate used can be configured at assembly time, using standard Paula
       period values.</LI>
   <LI>Fully PC relative code is used to make relocation as easy as possible.</LI>
   </UL>
</p>

<p>*) in practice, this is limited by the largest maximum single block of free 
   RAM that exists. A system with multiple memory expansions will be limited 
   to a much smaller maximum sample size than the total RAM size would seem to
   indicate.</p>


<h3 id="releasenotes">Release Notes</h3>
<p>Release notes for the Audio Mixer</p>

<p><u>v3.6</u></p>
<UL>
<LI>(NEW) The mixer now supports a high quality mixing mode, which does not
          require pre-processed samples, but rather uses standard 8-bit samples.
          Note that this mode uses significantly more CPU time.</LI>
<LI>(NEW) The mixer now supports the use of plugin routines which will be called
          during sample playback. These routines can alter the data being played
          back, or work as synchronisation/control routines for timing and other
          purposes. There are several plugins provided by default. It is also
          possible to create custom plugins for use with the mixer.<br><br>

          The following plugins are provided:
		  <UL>
          <LI>MixPluginRepeat - repeats a sample after a given delay</LI>
          <LI>MixPluginSync - sets a trigger when a given condition occurs</LI>
          <LI>MixPluginVolume - changes the volume of the sample playing back</LI>
          <LI>MixPluginPitch - changes the pitch of the sample playing back</LI></UL></LI>
<LI>(NEW) The mixer now has the option of calling a callback function whenever a
          non-looping sample ends playing.</LI>
<LI>(NEW) New loop mode added, MIX_FX_LOOP_OFFSET, which allows samples to loop
          from an offset into the sample rather than from the start of the 
          sample.</LI>
<LI>(NEW) Added function MixerGetChannelStatus(), which returns whether or not
          the given channel is in use by the mixer.</LI>
<LI>(NEW) Added an optional counter of number of mixer interrupts that have
          executed since the counter started. Counter can be reset with 
          <em>MixerResetCounter()</em> and read using <em>MixerGetCounter()</em>.</LI>
<LI>(NEW) A new example has been added to show HQ mode. The example is named
          SingleMixerHQExample.</LI>
<LI>(NEW) New examples have been added to show callback and plugin use. The 
          examples are named CallbackExample and PluginExample.</LI>
<LI>(NEW) The CMixerExample has been updated to also show callback and plugin
          use.</LI>
<LI>(NEW) The PerformanceTest has been updated to also measure performance of
          callback and plugin use.</LI>
<LI>(DEPRECATED) The routines <em>MixerPlaySample()</em> and <em>MixerPlayChannelSample()</em> are
                 deprecated. They have been updated for 3.6 with the new loop 
                 offset mode, but will not support plugins or potential other 
                 changes in future versions of the mixer.<br><br>
			   
                 Replacement routines to use are <em>MixerPlayFX()</em> and 
                 <em>MixerPlayChannelFX()</em>.<br><br>
			   
                 For compatibility with previous versions, the old functions
                 will remain existing as is for the forseeable future.</LI>
<LI>(MAINTENANCE) The source directories for all examples have been renamed to
                  &lt;example&gt;Source and all binary examples now have a name ending
                  in 'Example'.</LI>
<LI>(MAINTENANCE) The MinimalMixer example now uses <em>MixerPlayFX()</em> instead of 
                  <em>MixerPlaySample()</em></LI>
<LI>(MAINTENANCE) The code for CMixerExample has been updates to use 
                  <em>MixerPlayFX()</em> instead of MixerPlaySample()</LI>
<LI>(MAINTENANCE) The code for the various functions to play samples through the
                  mixer has been adjusted so that most of the functionality is 
                  handled by one shared function to increase maintainability.</LI>
<LI>(BUGFIX) The performance test tool now supports combined mixer routine sizes
             above 64KB.</LI>
<LI>(BUGFIX) The performance test tool now no longer uses more sample space than
             needed.</LI>
<LI>(BUGFIX) The performance test tool now uses samples of addequate length, no
             matter the selected period.</LI>
<LI>(BUGFIX) The performance test tool now correctly runs 132 mixer interrupt
             executions per test, rather than 132 detected vblanks as the mixer
             interrupt could delay those and cause them to not be detected.</LI>
<LI>(BUGFIX) The performance test tool now correctly uses the 68020 optimised
             interrupt handler when MIXER_68020 is set to 1</LI>
<LI>(BUGFIX) The various functions added to return information (such as
             MixerGetBufferSize()) now always return a longword value.</LI>
<LI>(BUGFIX) The functions <em>MixerPlaySample()</em>, <em>MixerPlayChannelSample()</em>, <em>MixerPlayFX()</em>
             and <em>MixerPlayChannelFX()</em> now correctly save and restore register D1
             to the stack.</LI>
<LI>(BUGFIX) If MIXER_WORDSIZED is set to 1, the mixer now correctly uses the 
             2nd word of mfx_length and mfx_loop_offset in the MXEffect
             structure.</LI>
<LI>(BUGFIX) If MIXER_SIZEXBUF is set to 1, the mixer no longer skips the first
             frame of sample playback.</LI>
<LI>(BUGFIX) If MIXER_68020 is set to 1, the mixer no longer selects channels
             above the mixer_sw_channels limit to play back samples on when 
             using <em>MixerPlayFX()</em> or <em>MixerPlaySample()</em>.</LI>
<LI>(BUGFIX) The linux/unix version of the makefile now has the correct commands
             for make install & make clean to work</LI>
<LI>(BUGFIX) The mixer makefile will no longer give a "Could not find" error
             when using make clean.</LI>
<LI>(BUGFIX) The mixer makefile will no longer give a "1 file copied" message
             when using make install.</LI>
<LI>(BUGFIX) The HTML version of the documentation no longer contains any broken
             links.</LI>
</UL>

<p><u>v3.2</u></p>
<UL>
<LI>(MAINTENANCE) updated mixer.h to be more compliant with the C standard.</LI>
<LI>(BUGFIX) updated the way XREF and XDEF references are handled for 
             compatibility with vasm 1.9d and other assemblers that don't 
             support XREF's in the same file as the symbol definitions they
             reference.</LI>
</UL>

<p><u>v3.1</u></p>
<UL>
<LI>initial release of the Audio Mixer project</LI>
</UL>
<h3 id="requirements">Requirements</h3>
<p>There are three parts to the requirements for using the Audio Mixer. The first
are the requirements for assembling (and optionally compiling) the Audio Mixer
(plus examples &amp; tools), the second are the requirements for running the mixer
in a program. Both of these requirements are listed below. Lastly, there are 
the requirements for the examples and tools.</p>

<p><h4>Requirements for assembling the mixer:</h4>
   <UL>
   <LI>A macro assembler &amp; linker compatible with VASM style macro's and VASM
       style directives (preferably VASM/VLINK).</LI>
   <LI>The Amiga Native Development Kit (NDK). Version 1.3 or higher is 
       required.</LI>
   <LI>A system with enough disk space and RAM to run the chosen assembler and 
       linker for the project. (note: assembly has only been tested on a PC 
       using cross assembly)</LI>
   <LI>Optional, but highly recommended: make</LI>
   </UL>
</p>
<p><h4>Optional requirements for compiling the included C programs:</h4>
   <UL>
   <LI>All requirements for assembling the mixer.</LI>
   <LI>A C compiler capable of generating Amiga OS executables for systems based
       on the 68000 series of processors.</LI>
   </UL>
</p>

<p>If you require an assembler, linker or compiler to assemble/compile the 
provided source, VASM/VLINK and VBCC can be found here:
   <UL>
   <LI>VASM  - <a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a></LI>
   <LI>VLINK - <a href="http://sun.hasenbraten.de/vlink/">http://sun.hasenbraten.de/vlink/</a></LI>
   <LI>VBCC  - <a href="http://sun.hasenbraten.de/vbcc/">http://sun.hasenbraten.de/vbcc/</a></LI>
   </UL></p>
<p>Note that VBCC includes VASM/VLINK, as well as make and the Amiga NDK 3.9.</p>

<p>Also note that other assemblers, linkers and compilers should also be capable
of assembling/compiling the provided source, though some changes to the 
makefile and/or assembler options might be needed.</p>

<p><h4>Requirements for running the mixer:</h4>
   <UL>
   <LI>An Amiga* with at least Kickstart 1.3 and some Chip Memory**</LI>
   </UL>
</p>

<p><h4>Requirements for running the examples &amp; tools:</h4>
   <UL>
   <LI>An Amiga* with at least Kickstart 1.3, 512KB of Chip RAM and an 
       additional 512KB of any RAM (Chip, Fast or Slow RAM).</LI>
   </UL>
</p>

<p>Note that the Audio Mixer is designed for programs that disable the OS and
directly access the custom chip set. The code is compatible with both 68000 
and higher processors*. Keep in mind that certain systems*** can have issues 
running code that disables the OS.</p>

<p>For reference, the mixer has successfully been tested on the following:</p>
<UL>
   <LI>WinUAE emulating various systems, all running in Cycle Exact mode
     <br>(not tested using JIT or "fastest possible" configurations)</LI>
   <LI>A500/A600 with 68000@7MHz and varying amounts of Chip/Slow/Fast RAM</LI>
   <LI>A600 with 68030@25MHz and 32MB of Fast RAM</LI>
   <LI>A1200 with 68020@14MHz</LI>
   <LI>A1200 with 68020@14MHz/8MB Fast RAM</LI>
   <LI>A1200 with 68030@50MHz/16MB Fast RAM</LI>
</UL>
<p>Further, the mixer has been reported to successfully work on:</p>
<UL>
   <LI>A500 with ACA+@42MHz</LI>
   <LI>Various 68030 based systems</LI>
   <LI>An A1200 with a TF1260 accelerator</LI>
</UL>
   
<p>*) This should include emulators &amp; FPGA systems, as long as these systems
   include accurate emulation/re-creation of the Amiga Chip Set, 68000 and
   certain Kickstart functionality. Compatibility with FPGA systems is not 
   guaranteed.</p>
<p>**) Exact required amount depends on the size of the samples and rest of the
    program. The mixer itself requires about 4-8KB of any RAM for code &amp;
    variables and about 0.5-8KB of Chip RAM for mixing buffers (these values
    depends on the number of hardware channels configured and the chosen 
    period value)</p>
<p>***) In particular, Amiga systems that are highly expanded sometimes include
     expansions that are incompatible with software that takes over the 
     system, such as network cards that rely on the NMI interrupt. On such 
     systems, extra steps might be needed. Such as disabling the network prior
     to running the code or using a wrapper such as WHDLoad.</p>


<h3 id="configuration">Configuration</h3>
<p>In order to reach high performance, the Audio Mixer needs to be configured at
assembly time, rather than at runtime. This is done using the mixer_config.i
file, which contains all but one of the configurable options for the mixer.
Options in this file can't be changed at runtime. The only option that can be
changed at runtime is the system's video type (PAL/NTSC).</p>

<p>The configuration consists of six sections. In the first section, the mixer
type is selected. In the second, the playback mode is selected. In the third 
section, the mixer playback settings are selected. In the fourth section 
various optimisation settings can be enabled or disabled. The fifth section
selects performance measurement options and the sixth section sets advanced
options.</p>

<OL>
<LI><h4>Mixer type</h4>
   <UL>
   <p>The mixer can run in one of three ways. In the mixer type selection
   section, the desired playback type is selected. The three types are:</p>
   <UL>
   <LI>MIXER_SINGLE</LI>
   <LI>MIXER_MULTI</LI>
   <LI>MIXER_MULTI_PAIRED</LI>
   </UL>
   <p>The first type, <em>MIXER_SINGLE</em>, uses a single hardware channel to play back
   mixer output on. It allows up to 4 samples to be mixed at the same time 
   onto the selected channel.</p>

   <p>The second type, <em>MIXER_MULTI</em>, uses multiple hardware channels to play back
   mixer output on. Each of these hardware channels can have its own set of
   samples mixed onto it. In total, this mode allows up to four hardware
   channels to be selected, each of which can play back up to 4 samples mixed
   together (for a total of up to 16 samples played back at the same time).</p>

   <p>The third type, <em>MIXER_MULTI_PAIRED</em>, is similar to <em>MIXER_MULTI</em> in that it
   uses multiple hardware channels to play back mixer output on. However,
   unlike <em>MIXER_MULTI</em>, two of the four hardware channels are paired. The 
   paired channels will always play back the same output from the mixer. The
   result is that the paired channel is effectively playing back on both the
   left and the right speaker at the same time, creating a centred output.</p>

   <p>In <em>MIXER_MULTI_PAIRED</em> type AUD2 and AUD3 are used to create the centred
   channel. As such both of these channels must always be selected. The other
   two hardware channels can optionally also be selected and will act as 
   though running in <em>MIXER_MULTI type</em>.</p>

   <p>To select which type to use, change the desired equate to 1 and set the
   others to 0. For example, to set up for <em>MIXER_SINGLE</em> type, set up this
   section of the mixer_config.i file as follows:</p>
   <UL><PRE><LI>MIXER_SINGLE         EQU 1</LI><LI>MIXER_MULTI          EQU 0</LI><LI>MIXER_MULTI_PAIRED   EQU 0</LI></PRE></UL>
   </UL></LI>
   
<LI><h4>Mixer mode</h4>
   <UL>
   <p>The mixer supports two modes of playback. In the mixer mode selection
   section, the desired mode is selected.</p>
   
   <UL><PRE><LI>MIXER_HQ_MODE        EQU 0</LI></PRE></UL>
   
   <p>Setting the value for <em>MIXER_HQ_MODE</em> to 1 enables the high quality playback
   mode. This mode does not require pre-processed samples, but rather plays
   back standard 8-bit samples. Enabling this mode costs much more CPU time,
   but does allow higher quality playback.</p>
   </UL></LI>
<LI><h4>Mixer playback settings</h4>
   <UL><p>In order to correctly play back samples, the mixer playback settings need 
   to be configured. The values that need to be set up are:</p>
   <UL>
   <LI>mixer_output_channels</LI>
   <LI>mixer_sw_channels</LI>
   <LI>mixer_period</LI>
   <LI>MIXER_PER_IS_NTSC</LI>
   </UL>
   <p><em>mixer_output_channels</em> configures which hardware channel(s) the mixer will
   use for output. When <em>MIXER_SINGLE</em> is set to 1, only one channel can be
   selected, otherwise multiple channels can be selected. Channel selection is
   done using the standard DMA flag indicators: DMAF_AUD0...DMAF_AUD3.</p>

   <p>Note that when <em>MIXER_MULTI_PAIRED</em> is set to 1, at least DMAF_AUD2 and
   DMAF_AUD3 must be selected.</p>

   <p>To select which channels to use, change the equate to the desired hardware
   channels, combining multiple channels using the or operator. For example:</p>

   <UL><pre>mixer_output_channels   EQU DMAF_AUD2|DMAF_AUD3</pre></UL>

   <p><em>mixer_sw_channels</em> selects the maximum number of software mixed voices the
   mixer will use. This can be set at any value in the range of 1 to 4.
   Selecting fewer channels will reduce the maximum number of samples that can
   be mixed together. It will also lower CPU overhead of the mixer and will
   allow for samples with higher maximum / minimum amplitude values to be used
   (this in turn makes the samples sound less quiet/have a higher dynamic
   range).</p>

   <p>See <a href="#pre-processing">"Pre-processing samples"</a> for more information on the topic of maximum /
   minimum amplitude values.</p>

   <p>To select the number of software mixed voices, change the equate to the
   desired number. For example:</p>

   <UL><pre>mixer_sw_channels   EQU 4</pre></UL>

   <p><em>mixer_period</em> sets the period value used by Paula for playing back the mixer
   output. The value is limited by the normal limits for Paula for 15KHz
   display modes. The supported range is 124* to 65535. For completeness, a
   lower value corresponds to a higher sample rate.</p>

   <p>Selecting a lower period will increase mixer CPU overhead compared to a 
   higher period. To select the period, change the equate to the desired 
   period value. For example, to set the mixer to play back at ~11KHz set the
   value to:</p>

   <UL><pre>mixer_period   EQU 322</pre></UL>

   <p>*) PAL limit. The NTSC limit is 123.</p>

   <p><em>MIXER_PER_IS_NTSC</em> is a flag that can be set if the period value set in 
   <em>mixer_period</em> assumes an NTSC system. This flag is separate from the runtime
   video system selection that can be provided during mixer setup. It is only
   used to determine in which direction the PAL/NTSC period value conversion
   should operate.</p>
   </UL>
</LI>

<LI><h4>Optimisation options</h4>
   <UL><p>The mixer offers a variety of different optimisation options that can be set
   to improve the performance of the mixer (usually in exchange for one or more
   tradeoffs). Some of these options have a larger effect, some have a 
   smaller effect and some only change the performance in certain edge cases.</p>

   <p>By default all these options are disabled. Unless otherwise noted, options
   can be combined for potentially greater gains. The available options are:</p>
   <UL>
   <LI>MIXER_68020</LI>
   <LI>MIXER_WORDSIZED</LI>
   <LI>MIXER_SIZEX32</LI>
   <LI>MIXER_SIZEXBUF</LI>
   </UL>
   <p>The option <em>MIXER_68020</em> can be set to 1 to change code generation to be
   optimised for 68020+ based systems. It improves performance on such 
   systems, by making more effective use of the cache. Setting it also reduces
   object size and significantly reduces performance on 68000/68010 based 
   systems.</p>
   <p>(note that the mixer will still run on 68000 based systems even when this 
       option is set to 1).</p>

   <p>To enable the option, set the equate to 1:</p>

   <UL><pre>MIXER_68020   EQU 1</pre></UL>

   <p>NOTE: Setting this option to 1 disables *all* other optimisation options.</p>

   <p>The option <em>MIXER_WORDSIZED</em> can be set to 1 to limit the maximum sample size
   to be one unsigned word (64KB). If set to 0, sample length is limited to a
   signed long value (~2GB). Setting this option to 1 provides a small increase
   in performance by changing some operations to be word sized.</p>

   <p>To enable the option, set the equate to 1:</p>

   <UL><pre>MIXER_WORDSIZED   EQU 1</pre></UL>

   <p>The option <em>MIXER_SIZEX32</em> can be set to 1 to force the mixer to only process
   samples in blocks of 32 bytes. This can provide a small performance boost
   when playing several small looping samples at the same time. In normal use
   the performance increase is negligible.</p>

   <p>To enable the option, set the equate to 1:</p>

   <UL><pre>MIXER_SIZEX32   EQU 1</pre></UL>

   <p>NOTE: setting this option to 1 requires all samples to be a multiple of 32
            bytes in length, rather than the standard 4 bytes.</p>

   <p>The option <em>MIXER_SIZEXBUF</em> can be set to 1 to force the mixer to only 
   process samples in blocks of the <em>mixer_PAL_buffer_size</em> or 
   <em>mixer_NTSC_buffer_size</em> (depending on which video system is selected at
   runtime. This value is calculated in mixer.i), which is to say in blocks of
   1/50th or 1/60th of a second. Setting this option to 1 results in an 
   increase in performance at the cost of sample size flexibility.</p>

   <p>To enable the option, set the equate to 1:</p>

   <UL><pre>MIXER_SIZEXBUF   EQU 1</pre></UL>

   <p>NOTE: setting this option to 1 requires all samples to be a multiple of
            <em>mixer_PAL_buffer_size</em> or <em>mixer_NTSC_buffer_size</em> in length (depending
            on the selected video system), rather than the standard 4 bytes.</p>
   </UL>
</LI>

<LI><h4>Performance measurement options</h4>
   <UL><p>The mixer has several options to help programmers to measure the 
   performance of the chosen settings. The available options are:</p>
   <UL>
   <LI>MIXER_TIMING_BARS</LI>
   <LI>MIXER_DEFAULT_COLOUR</LI>
   <LI>MIXER_CIA_TIMER</LI>
   <LI>MIXER_CIA_KBOARD_RES</LI>
   <LI>MIXER_COUNTER</LI>
   </UL>
   <p>Setting <em>MIXER_TIMING_BARS</em> to 1 changes the behaviour of the mixer to show
   CPU time used by changing colour 0 to various different colours based on
   what the mixer is currently doing. This allows programmers to visualise the
   impact of the mixer on the system.</p>

   <p>The colours used are:</p>
   <UL>
   <LI>$B0B (bright magenta) => Interrupt handler
          <br>This colour denotes the overhead for the interrupt handler, such as
          stack operations, interrupt acknowledgement and Paula register 
          writes.</LI><br>

   <LI>$909 (magenta)        => Channel update
          <br>This colour denotes the overhead for the selection of samples to be
          mixed during the current interrupt.</LI><br>

   <LI>$707 (dark magenta)   => Mixing
          <br>This colour denotes the time spent on mixing the samples.</LI><br>

   <LI>$099 (cyan)           => Other
          <br>This colour is used for mixer routines that are expected to be 
          called frequently, but are not part of the interrupt handler. This
          includes the various routines to play back and/or stop samples.</LI>
   </UL>
   <p>To enable this option, set the equate to 1:</p>

   <UL><pre>MIXER_TIMING_BARS   EQU 1</pre></UL>

   <p>The setting <em>MIXER_DEFAULT_COLOUR</em> changes which colour the mixer will use
   when it reaches the end of a routine or interrupt. Changing this allows for
   better integration with existing graphics.</p>

   <p>To select a colour, set the equate to the desired hexadecimal colour value:</p>

   <UL><pre>MIXER_DEFAULT_COLOUR   EQU $456</pre></UL>

   <p>Note that this option only has an effect if <em>MIXER_TIMING_BARS</em> is set to 1.</p>

   <p>Setting <em>MIXER_CIA_TIMER</em> to 1 enables the use of CIA-A timer A to measure 
   performance of the mixer interrupt handler (which includes the mixing of
   samples). Note that for correct measuring of performance, it's recommended
   no higher priority* interrupts are allowed to fire, otherwise the results
   will be skewed.</p>

   <p>*) The mixer uses audio interrupts, which run at level 4. This means 
      interrupts at level 5+ can interrupt the mixer and skew results of the
      measurements.</p>

   <p>The CIA timer will be used to generate several values (include via 
   mixer.i):</p>
   <UL>
   <LI><em>mixer_ticks_last</em>
     <br>This word will contain the number of CIA timer ticks the last mixer
     interrupt took to complete.</LI><br>

   <LI><em>mixer_ticks_best</em>
     <br>This word will contain the best (=lowest) number of CIA timer ticks the
     mixer interrupt took to complete since start. In most cases, this
     represents the time an idle interrupt takes (one where no sample is
     playing)</LI><br>

   <LI><em>mixer_ticks_worst</em>
     <br>This word will contain the worst (=highest) number of CIA timer ticks the
     mixer interrupt took since start.</LI><br>

   <LI><em>mixer_ticks_average</em>
     <br>This word is initially filled with 0, but can be updated by calling the
     routine <em>MixerCalcTicks()</em> (included from mixer.i). After this routine is
     called, this word will contain the average number of CIA timer ticks the
     mixer interrupt took over the last 128 frames.</LI>
   </UL>
   <p>To enable this option, set the equate to 1:</p>

   <UL><pre>MIXER_CIA_TIMER   EQU 1</pre></UL>

   <p>NOTE: setting this option to 1 assumes CIA-A timer A is available for use.
   <br>NOTE: the routine <em>MixerCalcTicks()</em> and the values mixer_ticks_last/best/
         worst/average are only available if this option is set to 1.</p>

   <p>The option <em>MIXER_CIA_KBOARD_RES</em> is used to restore the keyboard for Amiga
   OS if <em>MIXER_CIA_TIMER</em> is set to one and <em>MixerRemoveHandler()</em> is called. If
   this option is not set, the CIA-A timer will merely be stopped. If this 
   option is set, the CIA-A timer registers and control register A will be set
   such that the keyboard will function correctly in the OS.</p>

   <p>To correctly use this feature, call <em>MixerRemoveHandler()</em> as the last thing
   prior to re-enabling the OS.</p>

   <p>To enable this option, set the equate to 1:</p>

   <UL><pre>MIXER_CIA_KBOARD_RES   EQU 1</pre></UL>

   <p>NOTE: this option is only valid if <em>MIXER_CIA_TIMER</em> is set to one.
   <br>NOTE: if this option is not set, but <em>MIXER_CIA_TIMER</em> is set to one and the
         program returns to the OS, the keyboard may lose functionality
         (depending on the OS version and Amiga keyboard type).</p>

         <p>If the program never returns to the OS, or runs via WHDLoad, this
         setting is not required.</p>

   <p>The option <em>MIXER_COUNTER</em> can be used to enable a built in counter, which
   counts the number of mixer interrupts that has been executed. This can be
   useful, since mixer interrupts occur at roughly 1/50th or 1/60th of a 
   second, but not quite once per frame. The counter maintained is word sized
   and can be accessed using the functions <em>MixerResetCounter()</em> and 
   <em>MixerGetCounter()</em></p>
   
   To enable the counter, set the equate to 1:<br>
   
   <UL><PRE><LI>MIXER_COUNTER          EQU 1</LI></PRE></UL>
   </UL>
</LI>

<LI><h4>Advanced options</h4>
   <UL><p>The mixer provides three advanced settings which may be of use for some 
   users. Options provided are:</p>
   <UL>
   <LI>MIXER_ENABLE_CALLBACK</LI>
   <LI>MIXER_ENABLE_PLUGINS</LI>
   <LI>MIXER_SECTION</LI>
   <LI>MIXER_NO_ECHO</LI>
   <LI>MIXER_C_DEFS</LI>
   </UL>
   <p>The option <em>MIXER_ENABLE_CALLBACK</em> can be used to enable support for callback
   routines. Callback routines are automatically called whenever any sample
   ends playback naturally (but not when playback is stopped manually). 
   Enabling this option has a small CPU overhead cost.</p>
   
   <p>The routines <em>MixerEnableCallback()</em> and <em>MixerDisableCallback()</em> are used to
   set and remove a callback function respectively. See the <a href="#callback_api">Callback API</a> for 
   more information about callback routines.</p>
   
   <p>To enable callback routine support, set the equate to 1:</p>
   
   <UL><PRE><LI>MIXER_ENABLE_CALLBACK   EQU 1</LI></PRE></UL>
   
   <p>The option <em>MIXER_ENABLE_PLUGINS</em> can be used to enable support for running
   plugins. Plugins are routines that are executed by the mixer whenever a 
   mixer interrupt occurs and a sample with an attached plugin is being mixed.
   Plugin routines can be used to non-destructively alter sample contents to 
   change what is played back, to play back new samples when certain 
   situations occur and to communicate information (such as timing 
   information) to code outside of the mixer. See the <a href="#plugin_api">Plugin API</a> for more information.</p>
   
   <p>Enabling plugin support has a small CPU overhead cost. The plugin routines
   themselves can add significant CPU overhead if they non-destructively alter
   sample contents. Apart from built-in plugins, the system also supports 
   custom plugins.</p>
   
   <p>To enable plugin support, set the equate to 1:</p>
   
   <UL><PRE><LI>MIXER_ENABLE_PLUGINS    EQU 1</LI></PRE></UL>

   <p>The option <em>MIXER_SECTION</em> can be used to disable adding the mixer to section
   code,code. By default this option is set to 1 and the mixer is added to
   section code,code. If set to 0, the mixer is not added to any section.</p>

   <p>To enable this option, set the equate to 1:</p>

   <UL><pre>MIXER_SECTION   EQU 1</pre></UL>

   <p>NOTE: normally, this setting should not be changed. But in certain
         situations it can be useful to not utilise sections. In those cases,
         set the value to 0.</p>

   <p>The option <em>MIXER_NO_ECHO</em> can be set to 1 to disable the use of the "echo"
   directive to display certain messages during assembly. Not all assemblers
   support the use of the "echo" directive and with this option such 
   assemblers might still be usable.</p>

   <p>To enable this option, set the equate to 1:</p>

   <UL><pre>MIXER_NO_ECHO   EQU 1</pre></UL>

   <p>The option <em>MIXER_C_DEFS</em> can be set to 1 to enable C style function
   definition aliases. This allows C compilers to link the mixer.o file
   correctly. If disabled, these aliases are not created and linking mixer.o
   in C programs will likely fail.</p>
   
   <p>To enable this option, set the equate to 1:</p>
   
   <UL><PRE><LI>MIXER_C_DEFS            EQU 1</LI></PRE></UL>
   </UL>
</LI>
</OL>


<h3 id="assembling">Assembling/compiling the mixer, converter, examples &amp; tools</h3>
<p>The Audio Mixer consists of the mixer itself, an example sample conversion
routine, plus examples and tools. All of these are provided in the form of the
source code in 68000 assembly. The source code has been written for use with
VASM/VLINK or assemblers/linkers that are compatible with VASM/VLINK 
directives. The Audio Mixer also comes with two C programs, one to show how
integration with the assembly routines works and one tool to pre-process samples. The C source code
has been compiled and tested using VBCC with an Amiga OS 1.3 target.</p>

<p>For convenience, the package is distributed with binary versions of the
examples and tools. These binary versions have been made using the default
configuration of 4 channel mixing (per hardware channel) and an 11KHz sample
rate. No optimisation options have been enabled.</p>

<p>In order to assemble, compile and/or link the provided source code, a makefile
has been supplied. Before using the makefile, four variables in the makefile
must be configured. These variables are:</p>
   <UL>
   <LI>INSTLOC
     <br>Set this variable to the directory you wish to install the examples and
     the mixer/converter objects to. The makefile will attempt to create this
     directory if it doesn't exist. It will do the same for one or more 
     subdirectories in this directory.</LI><br>

   <LI>LIBS
     <br>Set this variable to the directory that contains the Amiga library from
     the Amiga NDK (v1.3+)</LI><br>

   <LI>SYSTEMDIR
     <br>Set this variable to the directory that contains the Amiga NDK (1.3+)
     assembly include files.</LI><br>

   <LI>COMPILE_C
     <br>Set this variable to 1 to enable compiling the C programs</LI>
   </UL>
<p>This makefile has several different options:</p>
   <UL>
   <LI>make
     <br>assembles all objects and links the examples/tools</LI><br>

   <LI>make install
     <br>assembles all objects and links the examples/tools. Also copies the 
     result to the configured installation directory</LI><br>

   <LI>make mixer
     <br>assembles only the mixer &amp; converter object files</LI>
   </UL>
<p>Note that the makefile uses VASM &amp; VLINK and assumes both are in the current
path (as vasmm68k_mot and vlink respectively). Also note that the makefile 
uses VBCC as it's C compiler.</p>

<p>For those who wish to manually assemble/compile, make sure to keep in mind 
that the examples/tools have a variety of dependencies you'll have to also 
assemble. On top of the internal dependencies, the mixer, examples and tools
also have the Amiga NDK (1.3+) as a dependency.</p>

<p>The order of linking for the assembly examples/tools should be 
PhotonsMiniWrapper.o first, everything else after that (this goes for each
assembly language example/tool).</p>

<p>Assembling the mixer &amp; converter object files should be simpler as the list of
dependencies is limited to the NDK (1.3+) and the files in the mixer or
converter directory itself.</p>

<p>When assembling (parts) of the mixer code manually, it's important to note 
that various files require a specific symbol to be set when assembling them.
This symbol should not be set when assembling different files. The full list
of symbols and what file needs which symbol can be found in the makefile.</p>

<p>Setting these symbols can normally be done as a (command line) option for the
assembler.</p>

<p>As an example, assembling mixer.asm requires the symbol BUILD_MIXER to be set.
If VASM is being used, this is done by specifying -DBUILD_MIXER as one of the
command line parameters. For reference, the full VASM command line used to 
build the mixer object file is as follows:</p>

<UL>
<pre>vasmm68k_mot -nowarn=62 -kick1hunks -Fhunk -m68000 -allmp -I. 
             -IC:\Development\AmigaDev\NDK13\INCLUDES1.3\INCLUDE.I -I.\Mixer 
             -DBUILD_MIXER .\Mixer\mixer.asm -o .\Mixer\mixer.o</pre>
</UL>
<p>The supplied makefile has been created for use under Windows. A version for
systems using UNIX style commands and directories is also supplied, as 
makefile_unix.mak.</p>


<h3 id="pre-processing">Pre-processing samples</h3>
<p>The mixer requires pre-processed samples in order to play back mixed sound
correctly*. The pre-processing consists of two steps: making sure the samples
are of the correct length to be mixed and making sure the sample data does not
exceed minimum/maximum values for the number of samples to be mixed at the 
same time.</p>

<p>*) when the mixer is run in the high quality mode, sample pre-processing
      is limited to merely making sure the samples meet the length
      requirements. No limits on sample data values exist. In this case, 
      step "Sample data minimum/maximum values" of the steps below can be skipped.</p>

<p>A detailed description of both steps follows.</p>
<OL>
<LI><p><h4>Sample length requirements</h4></p>
   The mixer will always process samples in a multiple of a minimum number of
   bytes. The consequence of this is that samples provided to the mixer must
   also be a multiple of that minimum number of bytes in length. The minimum
   length multiple required depends on the configuration as set up in 
   mixer_config.i.
   <UL>
   <LI>If no optimisation options are enabled, samples must be a multiple of 4
     bytes in length.</LI>
   <LI>If <em>MIXER_68020</em> is set to 1, samples must be a multiple of 4 bytes in 
     length. Setting <em>MIXER_68020</em> to 1 overrides all other optimisation flags,
     so this value will not change depending on other set flags.</LI>
   <LI>If <em>MIXER_SIZEX32</em> is set to 1, samples must be a multiple of 32 bytes in
     length.</LI>
   <LI>If <em>MIXER_SIZEXBUF</em> is set to 1, samples must be a multiple of either
     <em>mixer_PAL_buffer_size</em> or <em>mixer_NTSC_buffer_size</em> in length, depending on
     the video system selected during <em>MixerSetup()</em>.</LI>
   <LI><em>MIXER_SIZEX32</em> and <em>MIXER_SIZEXBUF</em> can be selected at the same time, in
     which case both limitations apply (i.e. the <em>mixer_PAL_buffer_size</em> /
     <em>mixer_NTSC_buffer_size</em> must now also be a multiple of 32 bytes).</LI>
   </UL>
   <p>The mixer offers a routine (<em>MixerGetSampleMinSize()</em>) to get the minimum
   number of bytes that samples must be a multiple in length of.</p>

   <p>The easiest way to make sure samples are of the correct length is to pad
   them with zeroes to the required minimum multiple length. Note that this 
   will work even in the case of <em>MIX_SIZEXBUF</em> and supporting both PAL and
   NTSC, as <em>mixer_PAL_buffer_size</em> will always be larger than 
   <em>mixer_NTSC_buffer_size</em> for any possible configuration.</p>

   <p>This means that the easiest way to deal with <em>MIXER_SIZEXBUF</em> in a program
   that supports both PAL and NTSC is to pad the samples with zeroes to a
   multiple of <em>mixer_PAL_buffer_size</em>.</p></LI>

<LI><p><h4>Sample data minimum/maximum values</h4></p>
   <p>For performance reason, the mixer does no range or overflow checking on any
   samples it adds. This means that samples that are not limited to a certain
   range of values can create over/underflows. These over/underflows create 
   very audible and very ugly distortions of sound. To prevent this, the mixer
   requires all sample data points to be kept in a range that allows them to 
   be added together under all circumstances without generating over/
   underflow.</p>

   <p>The limits are based directly on the maximum number of samples mixed 
   together (as set in mixer_config.i):</p>
   <UL>
   <LI>if <em>mixer_sw_channels</em>=1, the range is -128 to +127 (sample bytes/1)</LI>
   <LI>if <em>mixer_sw_channels</em>=2, the range is  -64 to  +63 (sample bytes/2)</LI>
   <LI>if <em>mixer_sw_channels</em>=3, the range is  -43 to  +42 (sample bytes/3)</LI>
   <LI>if <em>mixer_sw_channels</em>=4, the range is  -32 to  +32 (sample bytes/4)</LI>
   </UL>

   <p>All samples used by the mixer should only have data points in the value
   ranges given above. It should be pointed out that this pre-processing will
   have an effect on the volume of the samples played back. The higher the 
   number of channels that can be mixed, the quieter the samples will sound.</p>

   <p>It is highly recommended to keep this in mind for both the samples to be
   used and any/all music that will be played alongside the samples played
   back using the mixer. Choosing the correct HW volume for any module playing
   back is an important part of making the mixer output sound best.</p>

   <p>For more information on how to get good quality samples for use with the 
   mixer, see <a href="#best_practices">"Best practices for source samples"</a>.</p></LI>
</OL>
<p>The mixer provides both a tool (SampleConverter) and an assembly routine
(<em>ConvertSampleDivide()</em>) to aid in pre-processing samples. Both of these are also
described in the documentation. See <a href="#tools">"Tools"</a> and <a href="#converter_api">"Converter API"</a> for more
details.</p>

<p>Note that using these specific options is not required, it's certainly 
possible to create a separate converter (for example one that does bulk 
conversion) for this purpose, or to generate the initial samples such that
they already conform to the requirements.</p>

<p>Indeed, the assembly routine provided is quite slow due to the byte-by-byte 
lookup that it needs to do for the conversion, so pre-processing samples at or
before assembly/compile time is recommended for projects that include many 
samples.</p>


<h3 id="using">Using the mixer</h3>
<p>After configuring and assembling the mixer, the resulting object file 
(mixer.o) can be linked into other programs to provide the mixer API (as
described in <a href="#mixer_api">"Mixer API"</a>).</p>

<p>In order to use the mixer, several steps need to be taken. A basic example 
follows (in Assembly and C). The example assumes <em>MIXER_SINGLE</em> is set to 1 and
callback routines & plugins are disabled (<em>MIXER_ENABLE_CALLBACK</em> &amp; 
<em>MIXER_ENABLE_PLUGINS</em> are both set to 0).</p>

<p>Note: while initially setting up the mixer, it can be useful to set
      <em>MIXER_TIMING_BARS</em> to 1 in mixer_config.i to have a visual representation
      of the mixer working (or not working if something went wrong).</p>
<OL>
<LI><p><h4>Allocate/reserve a block of Chip RAM</h4>
   This block has to be equal in size to the value of <em>mixer_buffer_size</em> as found in mixer.i*.</p>

   <p>*) the mixer provides the support routine <em>MixerGetBufferSize()</em> to get the
      correct size if using mixer.i is not desired. <em>MixerGetBufferSize()</em>
      returns the correct size in D0.</p>

<pre>   Assembly:                                C:
   move.l   #mixer_buffer_size,d0           size = MixerGetBufferSize();
   ; allocate memory using the above size   /* allocate memory here */
   ; alternatively, use a block of memory
   ; defined in a Chip RAM section of this
   ; size.</pre></LI>

<LI><p><h4>Set up the mixer</h4>
   This is done by calling the routine <em>MixerSetup()</em>, with the current
   video system and the block of allocated Chip RAM from step one as 
   parameters.</p>

<pre>   Assembly:                                C:
   ; Pointer to Chip RAM block in A0        /* buffer points to Chip RAM
   moveq   #MIX_PAL,d0                         block */
   bsr     MixerSetup                       MixerSetup(buffer, NULL, NULL, MIX_PAL, 0);</pre></LI>

<LI><p><h4>Start the interrupt handler</h4>
   This is done by calling the routine <em>MixerInstallHandler()</em>. This
   routine requires the value of the Vector Base Register (VBR)* and a flag
   that tells the routine whether or not to save the pre-existing interrupt
   vectors to be able to restore them later when the handler is removed.</p>

   <p>Note that the value of the flag to save the vectors is 0 and to not save
   the vectors is 1.</p>

   <p>*) this is always 0 on 68000 based systems, but on systems with a 68010 or
      higher this value can be different (this is especially true on systems 
      with a 68030+, which usually remap the VBR to Fast RAM for improved
      performance).</p>

<pre>   Assembly:                                C:
   ; VBR value in A0                        /* VBR value in vbr */
   moveq   #0,d0                            MixerInstallHandler(vbr, 0);
   bsr     MixerInstallHandler</pre></LI>

<LI><p><h4>Start the mixer</h4>
    This is done by calling the routine <em>MixerStart()</em></p>

<pre>   Assembly:                                C:
   bsr      MixerStart                      MixerStart();</pre></LI>

<LI><p><h4>The mixer is now running, SFX can now be played back using one of the
   playback routines</h4>
   These routines include <em>MixerPlayFX()</em>. To use <em>MixerPlayFX()</em>
   as an example, this routine has 2 parameters:</p>
   <OL>
   <LI>Pointer to an instance of the MXEffect structure in A0</LI>
   <LI>The hardware channel to use in D0, or 0 if mixer_config.i has 
      <em>MIXER_SINGLE</em> set to 1.</LI>
   </OL>
   <p>The MXEffect structure needs to have the following members filled for
   basic sample playback:</p>
   <UL>
   <LI>mfx_length<br>
      The length of the sample to play</LI>
   <LI>mfx_sample_ptr<br>
      Pointer to the (pre-processed) sample to play</LI>
   <LI>mfx_loop<br>
      The loop indicator. Either <em>MIX_FX_ONCE</em> to play back a sample once, 
      <em>MIX_FX_LOOP</em> to play back a sample in a loop forever or 
      <em>MIX_FX_LOOP_OFFSET</em> to play back a sample looping back to a given loop
      offset forever.</LI>
   <LI>mfx_priority<br>
      The priority of the sample - higher priority samples can overwrite
      already playing lower priority samples if needed.</LI>
   <LI>mfx_loop_offset<br>
      Set to the desired offset into the sample when <em>MIX_FX_LOOP_OFFSET</em> is
      used, leave 0 otherwise.</LI>
   <LI>mfx_plugin_ptr
      leave at 0 (NULL for C programs)</LI>
   </UL>
   <p><em>MixerPlayFX()</em> returns the mixer channel used in D0, or -1 if no free
   channel can be found.</p>

<PRE>   Assembly:
   lea.l   effect_struct,a0               ; Assumed to be a block of memory
                                          ; mfx_SIZEOF bytes in length.
   move.l  #sample_length,mfx_length(a0)
   move.l  sample,mfx_sample_ptr(a0)
   move.w  #MIX_FX_ONCE,mfx_loop(a0)
   move.w  #1,mfx_priority(a0)
   clr.l   mfx_loop_offset(a0)
   clr.l   mfx_plugin_ptr(a0)
   moveq   #0,d0                          ; Channel can be left 0 when using
                                          ; MIXER_SINGLE
   
   C:
   MXEffect effect_struct;

   effect_struct.mfx_length = sample_length;
   effect_struct.mfx_sample_ptr = sample;
   effect_struct.mfx_loop = MIX_FX_ONCE;
   effect_struct.mfx_priority = 1;
   effect_struct.mfx_loop_offset = 0;
   effect_struct.mfx_plugin_ptr = NULL;

   MixerPlayFX(&amp;effect_struct, 0); /* Channel can be left 0 when using 
                                      MIXER_SINGLE */</PRE></LI>

<LI><p><h4>If desired, sample playback on a channel can be stopped</h4>
   This is done by calling the
   <em>MixerStopFx()</em> routine. This routine has one argument, a channel mask.
   The channel mask combines the hardware channel (or 0 if <em>MIXER_SINGLE</em> is
   set to 1) and the mixer channel as returned by <em>MixerPlaySample()</em> into a 
   single value. Samples playing back on this combination of channels will be
   stopped.</p>

<pre>   Assembly:                                C:
   ; MIXER_SINGLE=1, so no HW channel       /* MIXER_SINGLE=1, so no HW
   ; is needed.                                channel is needed */
   move.w   #MIX_CH0,d0                     MixerStopFX(MIX_CH0);
   bsr      MixerStopFX</pre>

   <p>For more information about mixer channels vs hardware channels, see <a href="#mixer_api">"Mixer
   API"</a>. For more information about using the mixer in C programs, see <a href="#using_c">"Using
   the mixer in C programs"</a>.</p></LI>

<LI><p><h4>To stop the mixer (and all playback on it)</h4>
    Call the routine <em>MixerStop()</em>.</p>

<pre>   Assembly:                                C:
   bsr      MixerStop                       MixerStop();</pre></LI>

<LI><p><h4>At the end of the program, or once no more mixing is required</h4>
   Call the routine <em>MixerRemoveHandler()</em>. This will remove the 
   interrupt handler and optionally restore the old interrupt vectors (if the
   flag to do so was set to 0 when calling <em>MixerInstallHandler()</em>)</p>

<pre>   Assembly:
   bsr      MixerRemoveHandler              MixerRemoveHandler();</pre></LI>
</OL>
<p>For more information on using the various mixer routines, see <a href="#mixer_api">"Mixer API"</a>
For more information of integrating the mixer in C programs, see <a href="#using_c">"Using the
mixer in C programs"</a>.</p>


<h3 id="combining">Combining the mixer and a music player</h3>
<p>It's possible to combine the mixer with an existing music player, such as the
PTPlayer 6.3* from Frank Wille or the LSP player from Arnaud Carr&eacute;. Other 
music players could also be compatible, depending on how the player deals with
channels on which no music is played.</p>

<p>*) Note that only version 6.3+ will work, version 6.2 and below miss a patch
   designed to block channels correctly for use with the mixer.</p>

   <p>Version 6.3 was released to Aminet on 26-03-2023 and can be found here:
   <a href="https://aminet.net/package/mus/play/ptplayer">https://aminet.net/package/mus/play/ptplayer</a></p>

<p>In order to combine the mixer with a music player, the music player can't 
touch any of the hardware registers of any of the channels configured to be
used by the mixer. For example, if mixer_config.i has <em>mixer_output_channels</em>
set to DMAF_AUD2, then the music player can't touch AUD2 in any way while the
mixer is running. This includes the audio interrupt for this channel, which
also can't be used.</p>

<p>This requires two things: a music track that omits the channel(s) as 
configured in mixer_config.i and a music player that doesn't touch channels 
that aren't in use.</p>

<p>The first is a matter of composition, the second needs to be supported by the
player itself. Some players support this directly (by not touching unused
channels), some support this indirectly (for instance, by having a function 
that disables one or more channels from being used). If the selected player 
does not natively support channels being disabled, it's sometimes possible to
patch the player by looking through it for instances of the audio registers
for the selected channel(s) being used and removing them from the code.</p>

<p>If both of these are taken care of, what remains is activating the mixer and 
music player in the correct order. Generally speaking, the music player should
be started first, the mixer second*. Depending on the music player, one or 
more frames may have to be waited before the mixer can be successfully 
started.</p>

<p>*) this is because many music players initialise all audio channels when they
   start, even if the channels are empty or disabled.</p>

<p>One thing to keep in mind is that some music players trash some of the 
registers used when setting them up, so be sure to initialise the registers 
used by the mixer routines correctly prior to calling any of them.</p>

<p>The mixer contains an example using Frank Wille's PTPlayer that shows how to
make use of it and the mixer together. This is the SingleMixer example. See 
<a href="#examples">"Examples"</a> for more information.</p>

<p><h4>For PTPlayer 6.3, the way to set it up is as follows:</h4></p>
<OL>
<LI>initialise PTPlayer as normal</LI>
<LI>call the routine <em>_mt_channelmask()</em> with the correct channel mask in D0</LI>
<LI>set up the mixer as described in <a href="#using">"Using the mixer"</a></LI>
<LI>both the mixer and PTPlayer should now work, allowing music and sound
   effects at the same time. Note that SFX playback should be done exclusively
   through the mixer, not using the built in SFX abilities of PTPlayer.</LI>
</OL>

<p>The SingleMixer example also shows how to integrate LSP.
<h4>For LSP, the way to set it up is as follows:</h4></p>
<OL>
<LI>initialise the LSP CIA player as normal (don't forget to enable the CIA 
   interrupt as in the LSP example)</LI>
<LI>set up the mixer as described in <a href="#using">"Using the mixer"</a></LI>
<LI>both the mixer and LSP should now work, allowing music and sound effects at
   the same time.</LI>
</OL>

<p>For other music players, try initialising the music player first, then the 
mixer. If this does not work, look in the documentation of the music player 
for ways to disable playback on one or more channels and use that. If that 
also does not work, it may be required to patch the music player to not touch
the channel(s) reserved for mixing.</p>

<p>In all cases, the music track(s) used should not use the channel(s) reserved
for mixing to play back audio. Other things (i.e. commands such as pattern 
jumps) should still work.</p>


<h3 id="examples">Examples</h3>
<p>The mixer comes with a number of example programs which show the abilities of
the mixer as well as giving working examples of how to use the mixer. The
following examples are provided:<p>
<UL>
   <LI><p><h4>MinimalMixerExample</h4>
     An example program with a minimum of extra features or support code. The
     purpose of the example is to show a simple case of using the mixer. Note
     that this example does not disable the OS, assumes the VBR is at address
     0 and that the code is running on a PAL Amiga.</p></LI>

   <LI><p><h4>SingleMixerExample</h4>
     An example program showing the abilities of the mixer when <em>MIXER_SINGLE</em>
     is set to 1. The example program shows both non-looping and looping 
     samples and has two different music players built in (PTPlayer by Frank
     Wille and LSP by Arnaud Carr&eacute;) which can be selected or disabled.</p>

     <p>The example also shows the ability to select an internal mixer channel 
     for SFX and the ability to stop SFX playback for any/all of the internal
     mixer channels on demand.</p>

     <p>This program disables the OS, automatically selects between PAL and NTSC
     and uses the VBR register to set up the interrupt.</p>

     <p>Note that switching the music on or off, or switching between the two 
     music players will cause the mixer to stop playback of any playing 
     samples due to the required reset of the interrupt handler.</p></LI>

   <LI><p><h4>SingleMixerHQExample</h4>
     An example program showing the abilities of the mixer when <em>MIXER_SINGLE</em>
     is set to 1 and <em>MIXER_HQ_MODE</em> is also set to 1.</p>
	 
	 <p>It has the same options and functionality as the SingleMixerExample, but
     uses the High Quality mixing mode for higher quality sample playback.</p></LI>

  <LI><p><h4>MultiMixerExample</h4>
     An example program that shows the ability of the mixer to run on multiple
     hardware channels. This example allows mixing of up to 16 samples at the
     same time and uses all four hardware channels to be able to do this.</p>

     <p>The example allows you to pick a hardware channel and internal mixer 
     channel to play SFX on. SFX can be both non-looping or looping. SFX can
     be stopped when desired.</p>

     <p>This program disables the OS, automatically selects between PAL and NTSC
     and uses the VBR register to set up the interrupt. It does not contain
     music playback.</p></LI>

   <LI><p><h4>MultiPairedMixerExample</h4>
     An example program that shows the ability of the mixer to create a paired
     channel which allows for seamless centred SFX to be played back. The
     example allows you to pick a hardware channel (AUD2 is paired with AUD3)
     and an internal mixer channel to play SFX on. SFX can be both non-looping
     or looping. SFX can be stopped when desired.</p>

     <p>This program disables the OS, automatically selects between PAL and NTSC
     and uses the VBR register to set up the interrupt. It does not contain
     music playback.</p></LI>
	 
   <LI><p><h4>CallbackExample</h4>
     An example program that shows the ability of the mixer to use callback
     routines. The example runs with <em>MIXER_SINGLE</em> set to 1 and allows you to
     pick an internal mixer channel to play SFX on and set whether or not to
     loop the SFX. It also allows you to select whether or not to use a 
     callback routine.</p></LI>

   <LI><p><h4>PluginExample</h4>
     An example program that shows the ability of the mixer to use plugins.
     The example runs with <em>MIXER_SINGLE</em> set to 1 and allows you to
     pick an internal mixer channel to play SFX on and set whether or not to
     loop the SFX.</p>

     <p>It also allows you to select a plugin to use. You can select no plugin,
     an example custom plugin that replaces the sample played back by a simple
     sine wave, the built-in repeat plugin, the built-in synchronisation 
     plugin, the built-in volume plugin and the built-in pitch change plugin.</p></LI>

  <LI><p><h4>CMixerExample</h4>
     An example program that shows the ability of the mixer to be integrated 
     in C programs. Like the MinimalMixerExample, the example is kept as simple as
     possible. Note that this example does not disable the OS, assumes the VBR
     is at address 0 and that the code is running on a PAL Amiga.</p>

	 <p>Unlike the MinimalMixerExample however, it also shows the use of plugins
     and callback routines. The plugin used to showcase plugin use is the 
     pitch change plugin.</p></LI>
</UL>


<h3 id="tools">Tools</h3>
<p>Alongside the mixer, two tools have been included. These tools are:</p>
<UL>
   <LI><p><h4>PerformanceTest</h4>
     A tool to measure the performance of a given mixer configuration. This
     tool shows a detailed set of performance figures for all the various
     optimisation flags (as well as no optimisations enabled). It also shows
     results for the high quality mode, callback routines and the use of the
     various built-in plugins. In total, it runs 48 performance tests and 
     displays the results. Results pages can can be switched with the right
     mouse button. There are four pages: default/non-HQ tests in CIA ticks,
     default/non-HQ tests as a CPU use percentage, HQ/callback/plugin tests in
     CIA ticks and HQ/callback/plugins as a CPU use percentage.</p>

     <p>To use the PerformanceTest, change the mixer_config.i found in the Mixer
     subdirectory of the PerformanceTestSource directory and assemble the
     PerformanceTest program using make. Then run the resulting 
     PerformanceTest executable on the Amiga environment you wish to check the
     performance results for.</p>

     <p>Note that the PerformanceTest uses a changed version of the mixer, with 
     its own mixer_config.i/mixer.i and mixer.asm. The core routines are 
     identical, but the PerformanceTest variant has been changed to enable 
     multiple different versions of the mixer code (with different performance 
     flags enabled or disabled) to co-exist at the same time.</p>

     <p>The mixer_config.i is similarly changed to only include those parts which
     are needed to be configured for testing the performance being included.</p>

     <p>This program disables the OS, automatically selects between PAL and NTSC
     and uses the VBR register to set up the interrupt. It does not contain
     music playback. While no sound will be heard, the PerformanceTest program
     does mix and play back sample data via Paula. However, the volume is set
     to zero and therefore it results in no sound being heard.</p></LI>

   <LI><p><h4>SampleConverter</h4>
     A tool written in standard C to convert samples to the correct limits for
     use with the mixer, as described in <a href="#pre-processing">"Pre-processing samples"</a>. The 
     included binary (and makefile instructions) is for Amiga systems, but the
     code only required the C standard libraries and thus should be easily 
     recompilable on other target systems.</p>

     <p>Usage: <pre>SampleConverter &lt;number of software channels&gt; &lt;input file&gt; &lt;output file&gt;</pre></p>

     <p>Where the number of software channels is the value given for 
     <em>mixer_sw_channels</em> in mixer_config.i, input is the sample input file name
     and output file is the output file name. Note that SampleConverter 
     expects 8 bit signed raw sample data as input and will likewise output 
     this format.</p>

     <p>The output file is padded with zeroes to the nearest multiple of four
     bytes if required. If the output is to be used with a mixer configuration
     where <em>MIXER_SIZEX32</em> or <em>MIXER_SIZEXBUF</em> is set, the sample will still need
     to be padded with zeroes to a multiple of either 32 bytes or 
     <em>mixer_PAL_buffer_size</em> bytes after the conversion.</p>
	 
     <p>Note that this conversion process is only strictly needed for the 
     standard mixing mode, the high quality mode can play back normal 8-bit
     samples. However, it can still be useful to run the SampleConverter with
     the number of software channels set to 1 as a convenient way to pad the 
     samples to a multiple of 4 bytes (which is still required for the high 
     quality mode).</p></LI>
</UL>

<h3 id="api_changes">API Changes between version 3.1/3.2 and 3.6</h3>
<p>Version 3.6 of the mixer makes several changes to the existing API. These
changes are summarised in this section. For more detailed information, see
<a href="#mixer_api">Mixer API</a>, <a href="#callback_api">Callback API</a>, <a href="#plugin_api">Plugin API</a> and <a href="#performance_api">Performance Measuring API</a>.</p>

<h4>New API's</h4>
<p>There are new API's for callbacks and plugins (see <a href="#callback_api">Callback API</a> and 
<a href="#plugin_api">Plugin API</a>)</p>

<h4>Constants</h4>
<p>There are several new constants and variables defined in mixer.i/mixer.h:</p>
<UL>
   <LI>MIX_FX_LOOP_OFFSET</LI>
   <LI>MIX_CH_FREE</LI>
   <LI>MIX_CH_BUSY</LI>
   <LI>MIX_PLUGIN_STD (part of the Plugin API)</LI>
   <LI>MIX_PLUGIN_NODATA (part of the Plugin API)</LI>
   <LI>mixer_plugin_buffer_size (part of the Plugin API)</LI>
</UL>

<h4>Type definitions</h4>
<p>There are some changes surrounding the type definitions in mixer.i/mixer.h:</p>
<UL>
   <LI>The definition of MXEffect has changed</LI>
   <LI>There is a new type, MXPlugin (part of the Plugin API)</LI>
</UL>

<h4>Functions</h4>
<p>Several existing functions have their parameters changed:</p>
<UL>
   <LI><em>MixerSetup()</em></LI>
   <LI><em>MixerPlaySample()</em></LI>
   <LI><em>MixerPlayChannelSample()</em></LI>
</UL>
   
<p>Several existing functions have been deprecated and are provided solely for
backwards compatibility:</p>
<UL>
   <LI><em>MixerPlaySample()</em></LI>
   <LI><em>MixerPlayChannelSample</em>()</LI>
</UL>

<p>Note: these functions will no longer be updated with new features for new
      versions after 3.6. They do not support the use of plugins.</p>
   
<p>There are several new functions:</p>
<UL>
   <LI><em>MixerGetChannelStatus()</em></LI>
   <LI><em>MixerGetTotalChannelCount()</em></LI>
   <LI><em>MixerGetChannelBufferSize()</em></LI>
   <LI><em>MixerEnableCallback()</em> (part of the Callback API)</LI>
   <LI><em>MixerDisableCallback()</em> (part of the Callback API)</LI>
   <LI><em>MixerGetPluginsBufferSize()</em> (part of the Plugin API)</LI>
   <LI><em>MixerSetPluginDeferredPtr()</em> (part of the Plugin API)</LI>
   <LI><em>MixerResetCounter()</em> (part of the Performance Measuring API)</LI>
   <LI><em>MixerGetCounter()</em> (part of the Performance Measuring API)</LI>
</UL>
   
<p>There are several new plugins:</p>
<UL>
   <LI><em>MixPluginRepeat()</em> (part of the Plugin API)</LI>
   <LI><em>MixPluginSync()</em> (part of the Plugin API)</LI>
   <LI><em>MixPluginPitch()</em> (part of the Plugin API)</LI>
   <LI><em>MixPluginVolume()</em> (part of the Plugin API)</LI>
</UL>

<h3 id="mixer_api">Mixer API</h3>
<p>The mixer provides several routines, constants and variables* to enable mixing
samples**. It also makes use of several elements of the Amiga NDK (1.3+) for
convenience and clarity.</p>

<p>In particular, it makes use of the exec_types.i include file to have a set of
standard data types and a standardized way to define structures in assembly.
It also makes use of several constants provided by the Amiga NDK.</p>

<p>*) Note that only routines/constants/variables used to play back samples using
   the mixer will be documented. There are internal routines, constants and 
   variables that are not needed to play back samples and these are not 
   documented.</p>

<p>**) Note that samples played back by the mixer can be stored in any type of 
    RAM (not just Chip RAM). Also note that samples played back by the mixer
    must be pre-processed as described in <a href="#pre-processing">"Pre-processing samples"</a>.</p>

    <p>For 68020+ based systems, it's recommended to store samples on 4 byte 
    boundaries to get optimal performance.</p>

<p><h4>NDK constants used follow:</h4></P>
<UL>
  <LI><p>DMAF_AUD0 / DMAF_AUD1 / DMAF_AUD2 / DMAF_AUD3
     <br>These four constants refer to the four hardware audio channels the Amiga
     sound chip, Paula, provides. They are used by various mixer routines as 
     well as mixer_config.i to identify the destination hardware channel(s) to
     be used for mixed output.</p>

     <p>Note that mixer routines that require a hardware channel only require one
     of these if the mixer is running with <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em>
     set to 1. If <em>MIXER_SINGLE</em> is set instead, mixer routines that require a
     hardware channel simply ignore the hardware channel set.</p></LI>
</UL>

<p><h4>Constant info follows:</h4></p>
<UL>
   <LI><p>MIX_PAL / MIX_NTSC
     <br>These two constants are used to indicate whether the mixer should run in
     PAL or NTSC mode when calling <em>MixerSetup()</em>. The difference between these
     two modes is a very small change in the period value used and a change in
     the size of number of bytes the mixer processes. If the mixer is set to
     run in PAL mode, it will mix enough bytes to fill 1/50th of a second per
     interrupt. If it is set to run in NTSC bytes, the mixer will instead mix
     enough bytes to fill 1/60th of a second per interrupt.</p>

     <p>Effectively, this changes the frequency of the interrupts to 1/50th or
     1/60th of a second.</p></LI>

   <LI><p>MIX_FX_ONCE / MIX_FX_LOOP / MIX_FX_LOOP_OFFSET
     <br>These three constants are used to indicate whether a sample should be 
     played back once by the mixer, or be played back in a loop. They are used
     by various mixer routines that play back samples.</p>
	 
	 <UL>
	 <LI>MIX_FX_ONCE<br>
	     play back the sample once</LI>
	 <LI>MIX_FX_LOOP<br>
	     play back the sample in a loop, restarting at the 
         beginning of the sample</LI>
	 <LI>MIX_FX_LOOP_OFFSET<br>
	     play back the sample in a loop, restarting at the
	     given offset into the sample, rather than at the
         beginning</LI>
	 </UL>

     <p>Note: none of these constants has the value zero.</p>

   <LI><p>MIX_CH0 / MIX_CH1 / MIX_CH2 / MIX_CH3
     <br>These four constants are used to indicate which internal mixer channel
     should be used when calling routines that allow choosing an internal 
     mixer channel. Routines that do not allow this choice will select an 
     internal channel automatically using priority and age.</p>

     <p>Each hardware channel the mixer is configured to use in mixer_config.i 
     has between 1 and 4 internal mixer channels associated with it. How many
     of these internal channels are available depends on the value of 
     <em>mixer_sw_channels</em> in mixer_config.i.</p>

     <p>When using a routine that allows choosing an internal mixer channel, 
     these values select which of the internal channels to use. This is useful
     to have more control over what samples are being played. Note that when
     selecting an internal channel, priority still applies - a lower priority
     sample will not overwrite a higher priority one.</p></LI>

   <LI><p>MIX_CH_FREE / MIX_CH_BUSY
     <br>These two constants are used by MixerGetChannelStatus() to indicate 
     whether a given internal mixer channel is free, or busy playing back a
     sample.</p></LI>
</UL>

<p><h4>Variable info follows:</h4></p>
<UL>
   <LI><p>mixer_buffer_size
     <br>This variable contains the calculated total size of the Chip RAM buffer
     that needs to be passed to <em>MixerSetup()</em> for use by the mixer. For
     optimal performance on 68020+ systems, this buffer should be aligned on a
     four byte boundary.</p>

     <p>Note that this value is not identical to either <em>mixer_PAL_buffer_size</em> or
     <em>mixer_NTSC_buffer_size</em>, which should not be used to determine the size
     of the Chip RAM buffer.</p>

     <p>See also <em>MixerGetBufferSize()</em></p></LI>

   <LI><p>mixer_PAL_buffer_size
     <br>This variable contains the calculated size needed by the mixer to play
     back 1/50th of a second of sample data. It's mostly useful to determine
     the amount of bytes to pad samples with in case <em>MIXER_SIZEXBUF</em> is set.</p>

     <p>See also <em>MixerGetSampleMinSize()</em></p></LI>

   <LI><p>mixer_NTSC_buffer_size
     <br>This variable contains the calculated size needed by the mixer to play
     back 1/60th of a second of sample data. It's mostly useful to determine
     the amount of bytes to pad samples with in case <em>MIXER_SIZEXBUF</em> is set if
     the mixer is expected to never run in PAL mode.</p>

     <p>See also <em>MixerGetSampleMinSize()</em></p></LI>
</UL>
<p><h4>Structure info follows:</h4></p>
<UL>
   <LI><p>MXEffect
     <br>This structure defines a sample to be played back by the mixer. It is 
     used by routines that expect a pointer to the effect structure rather
     than individually set registers.</p>

     <p>The structure elements are as follows:</p>
	 <UL>
        <LI><p>mfx_length
          <br>Length of the sample in bytes (signed long unless <em>MIXER_WORDSIZED</em> is
          set to 1 in mixer_config.i, in which case the length is an unsigned 
          word)</p></LI>

        <LI><p>mfx_sample_ptr
          <br>Pointer to the pre-processed sample to play</p></LI>

        <LI><p>mfx_loop
          <br>Either <em>MIX_FX_ONCE</em> to play back the sample once, <em>MIX_FX_LOOP</em> to play
          the sample on a loop or <em>MIX_FX_LOOP_OFFSET</em> to play the sample on a
          loop that restarts at the given <em>mfx_loop_offset</em>.
</p></LI>

        <LI><p>mfx_priority
          <br>Signed priority value, higher priority samples can overwrite lower
          priority samples.</p>

          <p>Note that looping samples (once playing) can never be overwritten.</p></LI>

        <LI><p>mfx_loop_offset
          <br>Offset into the sample at which it will restart playback if the loop
          mode is set to <em>MIX_FX_LOOP_OFFSET</em>.</p>
          
        <LI><p>mfx_plugin_ptr
          <br>The value set here is only used if <em>MIXER_ENABLE_PLUGINS</em> is set to 1.</p>

          <p>Set to 0 (NULL) if no plugin is to be used for this sample, or set
          to a pointer to an instance of MXPlugin if a plugin is to be used.</p>
		  
		  <p>See <a href="#plugin_api">Plugin API</a> for more information.</p></LI>

        <LI><p>mfx_SIZEOF
          <br>Gives the length of the structure in bytes</p></LI>
	</UL>
	</LI>
</UL>
<p><h4>Routine info follows:</h4></p>
<UL>
   <LI><p><em>MixerSetup(A0=buffer, A1=plugin_buffer, A2=plugin_data, D0=video_system.w, D1=plugin_data_length.w)</em>
     <br>This routine prepares the mixer structure for use by the mixing routines
     and sets mixer playback volume to the maximum hardware volume of 64. The
     routine must be called prior to any other mixing routines. The routine
     has two parameters:</p>
     <UL>
	 <p>A0 - must point to a block of memory in Chip RAM at least 
          <em>mixer_buffer_size</em> bytes in size.
          <br>Note: on 68020+ systems, it is advisable to align the Chip RAM
                buffer to a 4 byte boundary for optimal performance.</p>
     <p>D0 - must contain either <em>MIX_PAL</em> if running on a PAL system, or <em>MIX_NTSC</em>
          when running on a NTSC system. If the video system is unknown, set
          D0 to <em>MIX_PAL</em>.</p>

     <p>If MIXER_ENABLE_PLUGINS is set to one, A1, A2 and D1 also need to be set.
     If not, they can be omitted / left to 0.</p>

     <p>A1 - must point to a block of memory (any RAM type) at least
          <em>mixer_plugin_buffer_size bytes in size.</em>
          <br>Note: on 68020+ systems, it is advisable to align this buffer to a 4
                byte boundary for optimal performance.</p>
	 <p>A2 - must point to a block of memory sized the maximum size of any of any
          plugin data entry (see D1 for more details) multiplied by
          mixer_total_channels from mixer.i.
          <br>Note: on 68020+ systems, it is advisable to align this buffer to a 4
                byte boundary for optimal performance.</p>
	 <p>D1 - must be set to the maximum size of any of the possible plugin data
          structures. If no custom plugins are used, this size is equal to the
          value of mxplg_max_data_size, found in plugins.i.

          <br>If custom plugins are used, this value must be either the largest
          data size of the custom plugins, or mxplg_max_data_size, whichever
          is larger.</p>  
		  </UL></LI>
   
   <LI><p><em>MixerInstallHandler(A0=VBR, D0=save_vector.w)</em>
     <br>This routine sets up the mixer interrupt handler. <em>MixerSetup()</em> must have
     been called prior to calling this routine. The routine has two 
     parameters:</p>
     <UL>
     <p>A0 - Set to the VBR or zero (if running on a 68000).</p>
     <p>D0 - Set to 0 to save the interrupt vector the handler uses for future
          restoring, set to 1 to not save the interrupt vector.</p></UL></LI>

   <LI><p><em>MixerRemoveHandler()</em>
     <br>This routine removes the mixer interrupt handler. <em>MixerInstallHandler()</em>
     and <em>MixerStop()</em> should be called prior to calling this routine to make
     sure audio DMA is stopped.</p></LI>

   <LI><p><em>MixerStart()</em>
     <br>This routine starts mixer playback (initially playing back silence).
     <em>MixerSetup()</em> and <em>MixerInstallHandler()</em> must have been called prior to
     calling this routine.</p>

     <p>Note: if <em>MIXER_CIA_TIMER</em> is set to 1 in mixer_config.i, this routine also
           starts the CIA timer to measure performance metrics.</p></LI>

   <LI><p><em>MixerStop()</em>
     <br>This routine stops mixer playback. Both <em>MixerSetup()</em> and
     <em>MixerInstallHandler()</em> must have been called prior to calling this
     routine.</p>

     <p>Note: if <em>MIXER_CIA_TIMER</em> is set to 1 in mixer_config.i, this routine also
           stops the CIA timer used to measure performance metrics. The 
           results are of any performance measuring are found in 
           <em>mixer_ticks_last</em>, <em>mixer_ticks_best</em> and <em>mixer_ticks_worst</em> (these
           variables are not available if <em>MIXER_CIA_TIMER</em> is set to 0 in
           mixer_config.i).</p></LI>

   <LI><p><em>MixerVolume(D0=volume.w)</em>
     <br>This routine sets the desired hardware output volume used by the mixer
     (valid values are 0 to 64).</p></LI>

   <LI><p><em>D0=MixerPlayFX(A0=effect_structure, D0=hardware_channel)</em>
     <br>This routine adds a sample to the given hardware channel, using the
     MXEffect structure as described earlier. The routine automatically 
     determines the best mixer channel to play back on based on priority and
     age. If no applicable channel is free (for instance due to higher 
     priority samples playing), the routine will not play the sample.</p>

     <p>The routine has two parameters:</p>
     <UL>
     <p>A0 - Points to an instance of the <em>MXEffect</em> structure</p>
     <p>D0 - Hardware channel to use (DMAF_AUD0..DMAF_AUD3)</p>

     <p>Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the hardware channel
           given is ignored.
     <br>Note: if <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em> are set to 1 in mixer_confi.i
           and the given channel is not part of the channels set in 
           <em>mixer_output_channels</em> the sample will not play.
     <br>Note: if <em>MIXER_MULTI_PAIRED</em> is set to 1 in mixer_config.i, DMAF_AUD2 and
           DMAF_AUD3 are paired. Add samples intended for the paired channel
           to DMAF_AUD2 only, samples added to DMAF_AUD3 will be ignored.</p>

     </UL><p>The routine has a return value:<p>
     <UL>
     <p>D0 - returns the hardware &amp; mixer channel the sample will play on, or -1
          if no free channel could be found.</p></UL></LI>

   <LI><p><em>D0=MixerPlayChannelFX(A0=effect_structure, D0=mixer_channel)</em>
     <br>This routine adds a sample to the given hardware/mixer channel 
     combination, using the <em>MXEffect</em> structure as described earlier. The 
     routine uses the selected hardware/mixer channel to play back on. It
     checks for priority to see if the sample can be played. If the selected
     channel isn't free (due to a higher priority sample playing), the routine
     will not play the sample.</p>

     <p>The routine has two parameters:</p>
     <UL>
     <p>A0 - Points to an instance of the <em>MXEffect</em> structure</p>
     <p>D0 - Hardware/mixer channel to use (DMAF_AUD0..DMAF_AUD3 |
          MIX_CH0..MIX_CH3).</p>

     <p>Note: The routine requires setting exactly one hardware &amp; mixer channel 
           in D0.
     <br>Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the hardware channel
           given is ignored.
     <br>Note: if <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em> are set to 1 in mixer_confi.i
           and the given channel is not part of the channels set in 
           <em>mixer_output_channels</em> the sample will not play.
     <br>Note: if <em>MIXER_MULTI_PAIRED</em> is set to 1 in mixer_config.i, DMAF_AUD2 and
           DMAF_AUD3 are paired. Add samples intended for the paired channel
           to DMAF_AUD2 only, samples added to DMAF_AUD3 will be ignored.</p>
     </UL>
     <p>The routine has a return value:</p>
     <UL>
     <p>D0 - returns the hardware &amp; mixer channel the sample will play on, or -1
          if no free channel could be found.</p></UL></LI>

   <LI><p><em>MixerStopFX(D0=mixer_channel_mask)</em>
     <br>This routine stops sample playback on the given hardware/mixer channel 
     mask. Multiple hardware/mixer channels can be set at the same time, 
     samples on all given channels will be stopped. This routine has one 
     parameter:<p>
     <UL>
     <p>D0 - Hardware/mixer channel mask DMAF_AUD0..DMAF_AUD3 | 
          MIX_CH0..MIX_CH3).</p>

     <p>Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the hardware channel
           given is ignored.</p></UL></LI>
		   
  <LI><p><em>D0=MixerGetBufferSize()</em>
     <br>This routine returns the size of the Chip RAM buffer size that needs to 
     be allocated and passed to <em>MixerSetup()</em>. Note that this routine merely
     returns the value of <em>mixer_buffer_size</em>, which is defined in mixer.i. The
     primary function of this routine is to offer a method for C programs to 
     gain access to this value without needing access to mixer.i.</p></LI>

   <LI><p><em>D0=MixerGetSampleMinSize()</em>
     <br>This routine returns the minimum sample size. This is the minimum sample
     size the mixer can play back correctly. Samples must always be a multiple
     of this value in length.</p>

     <p>Normally this value is 4, but optimisation options in mixer_config.i can
     can increase this.</p>

     <p>Note: this routine is usually not needed as the minimum sample size is
           implied by the mixer_config.i setup. Its primary function is to 
           give the correct value in case <em>MIXER_SIZEXBUF</em> has been set to 1 in
           mixer_config.i, in which case the minimum sample size will depend 
           on the video system selected when calling <em>MixerSetup()</em> (PAL or
           NTSC).
     <br>Note: <em>MixerSetup()</em> must have been called prior to calling this routine.</p></LI>

   <LI><p><em>D0=MixerGetChannelStatus()</em>
     <br>This routine returns whether or not the hardware/mixer channel given in
     D0 is in use for sample playback. If <em>MIXER_SINGLE</em> is set to 1, the
     hardware channel does not need to be given in D0.

     If the channel is not used, the routine will return <em>MIX_CH_FREE</em>. If the
     channel is in use, the routine will return <em>MIX_CH_BUSY</em>.</p></LI>

   <LI><p><em>D0=MixerGetTotalChannelCount()</em>
     <br>This routine returns the total number of internal channels the mixer
     supports for sample playback. That is to say, the value of
     <em>mixer_sw_channels</em> multiplied by the number of assigned HW audio channels.</p></LI>

   <LI><p><em>D0=MixerGetChannelBufferSize()</em>
     <br>This routine returns the value of the internal mixer buffer size. This is
     the size of the buffer the mixer uses per HW audio channel assigned to
     it. Its primary purpose is to give plugins a way to get this value
     without needing access to the internal mixer structure.</p></LI>

   <p><h4>The following two routines are deprecated and will no longer receive new 
   functionality when the mixer is updated. They are still available for 
   backwards compatibility purposes and have been updated with the new offset
   loop mode.</h4></p>

   <LI><p><em>D0=MixerPlaySample(A0=sample, D0=hardware_channel, D1=length, D2=signed_priority.w, D3=loop_indicator.w, D4=loop_offset)</em>
     <br>This routine adds a sample to the given hardware channel, using values in
     registers passed to it. The routine automatically determines the best 
     mixer channel to play back on based on priority and age. If no applicable
     channel is free (for instance due to higher priority samples playing), 
     the routine will not play the sample.</p>

     <p>The routine has five parameters:</p>
     <UL>
     <p>A0 - Pointer to the pre-processed sample to play</p>
     <p>D0 - Hardware channel to use (DMAF_AUD0..DMAF_AUD3)</p>
     <p>D1 - Length of the sample in bytes (signed long unless <em>MIXER_WORDSIZED</em> is
          set to 1 in mixer_config.i, in which case the length is an unsigned 
          word)</p>
     <p>D2 - Signed priority value, higher priority samples can overwrite lower
          priority samples.

     <br>Note that looping samples (once playing) can never be overwritten.</p>
     <p>D3 - Either <em>MIX_FX_ONCE</em> to play back the sample once, <em>MIX_FX_LOOP</em> to play
          the sample on a loop, or <em>MIX_FX_LOOP_OFFSET</em> to play back the sample
          on a loop, restarting from the offset given in D4.</p>
     <p>D4 - Either 0, or the desired offset into the sample to restart looping
          at if D3 is set to <em>MIX_FX_LOOP_OFFSET</em>.</p>

     <p>Note: this routine is deprecated, use <em>MixerPlayFX()</em> instead
     <br>Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the hardware channel
           given is ignored.
     <br>Note: if <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em> are set to 1 in mixer_confi.i
           and the given channel is not part of the channels set in 
           <em>mixer_output_channels</em> the sample will not play.
     <br>Note: if <em>MIXER_MULTI_PAIRED</em> is set to 1 in mixer_config.i, DMAF_AUD2 and
           DMAF_AUD3 are paired. Add samples intended for the paired channel
           to DMAF_AUD2 only, samples added to DMAF_AUD3 will be ignored.</p>
     </UL>
     <p>The routine has a return value:</p>
     <UL>
     <p>D0 - returns the hardware &amp; mixer channel the sample will play on, or -1
          if no free channel could be found.</p></UL></LI>

   <LI><p><em>D0=MixerPlayChannelSample(A0=sample, D0=mixer_channel, D1=length, D2=signed_priority.w, D3=loop_indicator.w, D4=loop_offset)</em>
     <br>This routine adds a sample to the given hardware/mixer channel 
     combination, using values in registers passed to it. The routine uses the
     selected hardware/mixer channel to play back on. It checks for priority 
     to see if the sample can be played. If the selected channel isn't free 
     (due to a higher priority sample playing), the routine will not play the
     sample. The routine has five parameters:</p>
     <UL>
     <p>A0 - Pointer to the pre-processed sample to play</p>
     <p>D0 - Hardware channel to use (DMAF_AUD0..DMAF_AUD3)</p>
     <p>D1 - Length of the sample in bytes (signed long unless <em>MIXER_WORDSIZED</em> is
          set to 1 in mixer_config.i, in which case the length is an unsigned 
          word)</p>
     <p>D2 - Signed priority value, higher priority samples can overwrite lower
          priority samples. 

     <br>Note that looping samples (once playing) can never be overwritten.</p>
     <p>D3 - Either <em>MIX_FX_ONCE</em> to play back the sample once, <em>MIX_FX_LOOP</em> to play
          the sample on a loop, or <em>MIX_FX_LOOP_OFFSET</em> to play back the sample
          on a loop, restarting from the offset given in D4.</p>
     <p>D4 - Either 0, or the desired offset into the sample to restart looping
          at if D3 is set to <em>MIX_FX_LOOP_OFFSET</em>.</p>

     <p>Note: this routine is deprecated, use <em>MixerPlayFX()</em> instead
     <br>Note: The routine requires setting exactly one hardware &amp; mixer channel 
           in D0.
     <br>Note: if <em>MIXER_SINGLE</em> is set to 1 in mixer_config.i, the hardware channel
           given is ignored.
     <br>Note: if <em>MIXER_MULTI</em> or <em>MIXER_MULTI_PAIRED</em> are set to 1 in mixer_confi.i
           and the given channel is not part of the channels set in 
           <em>mixer_output_channels</em> the sample will not play.
     </br>Note: if <em>MIXER_MULTI_PAIRED</em> is set to 1 in mixer_config.i, DMAF_AUD2 and
           DMAF_AUD3 are paired. Add samples intended for the paired channel
           to DMAF_AUD2 only, samples added to DMAF_AUD3 will be ignored.</p>
     </UL>
     <p>The routine has a return value:</p>
     <UL>
     <p>D0 - returns the hardware &amp; mixer channel the sample will play on, or -1
          if no free channel could be found.</p></UL></LI> 
</UL>

<h3 id="callback_api">Callback API</h3>
<p>In order to support callback routines, the mixer provides several routines and
a common calling convention for callback routines. Note that callback routines
are only supported if <em>MIXER_ENABLE_CALLBACK</em> is set to 1.</p>

<p>When enabled and a callback is set using <em>MixerEnableCallback()</em>, the given
callback routine is called whenever a sample ends. Samples that loop, are 
stopped by calling <em>MixerStopFX()</em> or by calling <em>MixerStop()</em> do not result in a
callback routine being called.</p>

<p><h4>Routine info follows:</h4></p>
<UL>
   <LI><p><em>MixerEnableCallback(A0=callback_function_ptr)</em>
     <br>This routine enables the callback function and sets it to the given
     function pointer in A0.</p></LI>
																			 
   <LI><p><em>MixerDisableCallback()</em>
     <br>This routine disables the callback function.</p></LI>
</UL>
<p><h4>Callback routine conventions follow:</h4></p>
<UL>
   <LI><p>Callback functions take two parameters, the HW channel/mixer channel
   combination and the pointer to the start of the sample that just finished
   playing.</p></LI>
   
   <LI><p>Callback functions are not allowed to change any registers, apart from D0.
   They are called during the mixer interrupt and as therefore should be as
   frugal as possible with the amount of CPU time used.</p></LI>
   
   <LI><p>Callback functions can start playback of new samples using the standard
   mixer functions to play back samples, but only on the same mixer channel as
   the sample that just finished playback. If a callback function is used to
   start playing a new sample, the function should set its return value in D0
   to 1.</p></LI>
   
   <p>New samples played back by callback functions will start immediately after
   the end of the sample that just finished playback. This allows for seamless
   playback of one sample after the other.</p>
</UL>   
<p><h4>Callback parameters/return value follow:</h4><p>
<UL>   
   <p>A0 - Pointer to the callback function to use.</p>
   <p>D0 - the HW/mixer  channel combination of the sample that just finished
        playing.</p>
</UL>
   <p>Return value:</p>
<UL>
   <p>D0 - set to 0 if no new sample started playing, or to 1 if a new sample
        started playing.</p>
</UL>

<h3 id="plugin_api">Plugin API</h3>
<p>The plugin API is split into four parts. The first part describes the basics
of the plugin system, including how it's split up into an initialisation part
and a plugin part. The second part describes the plugin configurarion file, 
plugins_config.i. The third part describes the main API, which is dealt with
directly by the mixer and thus part of mixer.asm. The last part describes the
plugins themselves, which are found in plugins.asm and how to make custom
plugins.</p>

<p><h4>Plugin basics</h4></p>

Mixer plugins are routines that allow for several things:
<UL>
   <LI>Changing sample output data for a specific mixer channel (for instance,
     changing the pitch of a sound)</LI>
   <LI>Communicating status with the program code outside of the mixer interrupt
     (for instance, setting an address in memory to 1 when a sample has 
	 finished playback)</LI>
   <LI>Starting a new sample when certain conditions occur (for instance, 
     playing the same sample again after a short delay)</LI>
</UL>
<p>Plugin routines are called by the mixer during mixer interrupts using a 
specific API. They are not meant to be called outside of the mixer interrupt.
They are not allowed to change sample source data, any changes in data 
required for the desired effect has to be written into a intermediate buffer,
which is then used by the mixer for playback. Plugin routines can run in a
special mode where they do not output any data to the intermediate buffer,
which makes it possible to use plugins to communicate with the program code
outside of the mixer interrupts at a low cost in performance.</p>

Plugins consist of up to three routines:
<UL>
   <LI><p>Plugin initialisation (required)
     <br>This routine does setup for the plugin prior to playing back the sample.
     These routines are called when calling the various <em>MixerPlayFX()</em> routines.</p>

     <p>Plugin initialisation routines also set up any data required by plugin
     routines and get passed initilisation data via the <em>MXPlugin</em> structure.</p></LI>

   <LI><p>Plugin routine (required)
     <br>This routine does the actual work of the plugin. These routines are
     called every mixer interrupt for samples playing using a plugin. 
     Depending on plugin type, they either need to fill an output buffer with
     the audio data to play, or not.</p>

     <p>Note: plugin routines are not allowed to call any mixer playback
           function, such as <em>MixerPlayFX()</em> or <em>MixerPlaySample()</em>. Doing so can
           cause the mixer interrupt to crash.</p></LI>

   <LI><p>Deferred plugin routine (optional)
     <br>This routine is called at the end of every mixer interrupt for samples
     playing using a plugin. These routines are required only when playing
     back entirely new samples is needed for the plugin, as calling 
     <em>MixerPlaySample()</em>/<em>MixerPlayFX()</em> type routines during the mixing loop is
     not supported.</p></LI>
</UL>

<p>Apart from deferred plugin routines (which are set up directly by plugin 
routines themselves), all these routines and any data they need are passed 
to the mixer using the MXPlugin structure, and passing this via the MXEffect
structure to the playback routines. See <a href="#mixer_api">Mixer API</a> for more information about
MXEffect or the playback functions.</p>

<p>For more details on calling conventions and the like, see plugins.asm part below.</p>

<p><h4>Plugin configuration</h4></p>
<UL>
   <p>Like the mixer, the plugins also have a configuration file which defines
   how the code gets assembled. Items configured via the configuration file
   can't be changed at runtime. The plugins are configured via the file 
   plugins_config.i</p>
   
   <p>In addition, the plugins also make use of the <em>MIXER_C_DEFS</em> and <em>MIXER_68020</em>
   settings from mixer_config.i</p>
   
   <p>The following options exist:</p>
   <UL>
   <LI><p>MXPLUGIN_REPEAT
     <br>Set this option to 1 to enable the use of the repeat plugin, or to zero
     to disable it.</p>
	 
     <UL><PRE><LI>MXPLUGIN_REPEAT             EQU 1</LI></PRE></UL></LI>
	 
   <LI><p>MXPLUGIN_SYNC
     <br>Set this option to 1 to enable the use of the sync plugin, or to zero to
     disable it.</p>
	 
     <UL><PRE><LI>MXPLUGIN_SYNC               EQU 1</LI></PRE></UL></LI>

   <LI><p>MXPLUGIN_VOLUME
     <br>Set this option to 1 to enable the use of the volume plugin, or to zero
     to disable it.</p>
	 
     <UL><PRE><LI>MXPLUGIN_VOLUME             EQU 1</LI></PRE></UL></LI>
	 
   <LI><p>MXPLUGIN_PITCH
     Set this option to 1 to enable the use of the pitch plugin, or to zero to
     disable it.</p>
	 
     <UL><PRE><LI>MXPLUGIN_PITCH              EQU 1</LI></PRE></UL></LI>

   <LI><p>MXPLUGIN_68020_ONLY
     <br>If this option is set to 1 and MIXER_68020 is set to 1, the plugins use a
     small amount of 68020+ code to offer a tiny improvement in performance.</p>
	
     <UL><PRE><LI>MXPLUGIN_68020_ONLY         EQU 1</LI></PRE></UL></LI>

   <LI><p>MXPLUGIN_NO_VOLUME_TABLES
     <br>If this option is set to 1 and MXPLUGIN_VOLUME is set to 1, the volume
     tables are not included, saving 3,5KB of RAM.</p>
	 
	 <UL><PRE><LI>MXPLUGIN_NO_VOLUME_TABLES         EQU 1</LI></PRE></UL></LI>
   </UL>
</UL>
<p><h4>mixer.asm part</h4></p>
<UL>
   <p>The main plugin API is found in mixer.asm, as the mixer is responsible for
   dealing with plugins. This part of the documentation describes how to set
   up the <em>MXPlugin</em> structure for use in the <em>MXEffect</em> structure passed to
   <em>MixerPlayFX()</em> &amp; <em>MixerPlayChannelFX()</em> and the support routines for plugins
   that are available.</p>

   <p>Note: all use of plugins requires <em>MIXER_ENABLE_PLUGINS</em> to be set to 1 and
         <em>MixerSetup()</em> has to have been called with the relevant parameters for
         plugins set correctly.</p>

   <p>Constant info follows:</p>
   <UL>
      <LI><p>MIX_PLUGIN_STD / MIX_PLUGIN_NODATA
        <br>These two constants are used in the filling of <em>MXPlugin</em> to indicate
        the type of plugin that is being configured. <em>MIX_PLUGIN_STD</em> is used to
        denote a standard plugin, one which outputs an altered version of the
        source sample into an indirect buffer to allow changes in the audio
        heard.</p>

        <p><em>MIX_PLUGIN_NODATA</em> on the other hand denotes a plugin that does not
        change sample data, but is used for other purposes - such as
        communication with other code, synchronisation or starting new samples
        when certain situations occur.</p></LI>
   </UL>
   <p>Variable info follows:</p>
   <UL>
      <LI><p>mixer_plugin_buffer_size
        <br>This variable denotes the total size in RAM needed for the indirect
        buffers that are used by the mixer to store the results of plugins
        that change the data of the input sample.</p></LI>
   </UL>   
   <p>Structure info follows:</p>
   <UL>
      <LI><p>MXPlugin
        <br>This structure defines a plugin for use with a mixer sound effect.</p>

        <p>The MXPlugin structure has the following members:</p>
		<UL>
           <LI><p>mpl_plugin_type
		     <br>Determines the type of plugin. Either <em>MIX_PLUGIN_STD</em> for standard
             plugins, or <em>MIX_PLUGIN_NODATA</em> for plugins that do not alter
			 sample buffer data.</p></LI>

           <LI><p>mpl_init_ptr
		     <br>Pointer to the plugin initialisation routine to use.</p></LI>

           <LI><p>mpl_plugin_ptr
		     <br>Pointer to the plugin routine to use.</p></LI>

           <LI><p>mpl_init_data_ptr
		     <br>Pointer to the plugin initialisation data to use.</p></LI>
		</UL></LI>
   </UL>
   <p>Routine info follows:</p>
   <UL>
      <LI><p>D0=MixerGetPluginsBufferSize()
        <br>This routine returns the value of <em>mixer_plugin_buffer_size</em>, the 
        required size of the RAM buffer that needs to be allocated and 
        passed to <em>MixerSetup()</em> if <em>MIXER_ENABLE_PLUGINS</em> is set to 1.</p>

        <p>Note: this routine is usually not needed as the plugin buffer size is
              given in mixer.i. Its primary function is to expose this value
              to C programs.</p></LI>

      <LI><p>MixerSetPluginDeferredPtr(A0=deferred_function_ptr, A2=mxchannel)
        <br>This routine is called by a plugin whenever it needs to do a deferred
        (=post mixing loop) action. This is useful in case a plugin needs to
        start playback of a new sample, as this cannot be done during the
        mixing loop to prevent race conditions.</p>

        <p>Note: this routine should <strong>only</strong> be used by plugin routines and never
              in other situations as that will likely crash the mixer
              interrupt handler.</p>

        <p>A0 - Pointer to the deferred plugin to use.</p>
		<p>A2 - Pointer to the internal mixer channel structure, as provided by
		     the mixer when a plugin function is called.</p>
   </UL>
</UL>
<p><h4>plugins.asm part</h4></p>
<UL>
   <p>The files plugins.asm and plugins.i contain the actual plugins, as well as
   support routines and the requires structures for use by the plugins.
   Depending on plugin configuration, plugins.asm also contains lookup tables
   for real time volume changes.</p>

   <p>Constant info follows:</p>
   <UL>
      <LI><p>MXPLG_MULTIPLIER_4 / MXPLG_MULTIPLIER_32 / MXPLG_MULTIPLIER_BUFSIZE
        <br>These three constants are the three possible return values for the
        support routine <em>MixPluginGetMultiplier()</em>.</p>
		<UL>
		<LI>MXPLG_MULTIPLIER_4
		<br>Mixer sample size multiplier is 4 bytes</LI>
		<LI>MXPLG_MULTIPLIER_32
		<br>Mixer sample size multiplier is 32 bytes</LI>
		<LI>MXPLG_MULTIPLIER_BUFSIZE
		<br>Mixer sample size multiplier is equal to the internal mixer channel buffer size</LI>
		</UL></LI>

      <LI><p>MXPLG_PITCH_STANDARD / MXPLG_PITCH_LOWQUALITY
        <br>These two constants determine the type of pitch change is to be used
        by the pitch change plugin.</p>
		<UL>
		<LI>MXPLG_PITCH_STANDARD
		<br>Use the standard (slower, but higher quality) pitch change mechanism</LI>
		<LI>MXPLG_PITCH_LOWQUALITY
		<br>Use the faster, but lower quality pitch change mechanism</LI>
        </UL></LI>
      <LI><p>MXPLG_PITCH_NO_PRECALC / MXPLG_PITCH_PRECALC
        <br>These two constants determine whether or not the pitch plugin
        initialisation function has to calculate the new length of the sample
        to have its pitch changed, or that this value has been pre-calculated.</p>
		<UL>
		<LI>MXPLG_PITCH_NO_PRECALC
		<br>Pitch plugin initialisation calculated the new sample length in real time</LI>
        <LI>MXPLG_PITCH_PRECALC
		<br>Pitch plugin initialisation assumes new sample length has been pre-calculated</LI>
        </UL></LI>
      <LI><p>MXPLG_VOL_TABLE / MXPLG_VOL_SHIFT
        <br>These two constants determine whether the volume plugin uses lookup
        tables, or real time shifting to change volume.</p>
		<UL>
		<LI>MXPLG_VOL_TABLE
		<br>The volume plugin uses lookup tables to change sample playback volume</LI>
		<LI>MXPLG_VOL_SHIFT
		<br>The volume plugin uses real time shifts to change sample playback volume</LI>
        </UL></LI>
      <LI><p>MXPLG_SYNC_DELAY / MXPLG_SYNC_DELAY_ONCE / MXPLG_SYNC_START /
        MXPLG_SYNC_END / MXPLG_SYNC_LOOP / MXPLG_SYNC_START_AND_LOOP
		<br>These six constants determine which mode the synchronisation plugin
        uses.</p></LI>
		<UL>
		<LI>MXPLG_SYNC_DELAY
		<br>Synchronisation counts mixer interrupts until the given delay value is reached,
            then triggers. The counter is then reset and the process continues.</LI>
        <LI>MXPLG_SYNC_DELAY_ONCE
		<br>Synchronisation counts mixer interrupts until the given delay value is reached,
            then triggers.</LI>
        <LI>MXPLG_SYNC_START
		<br>Synchronisation triggers at the start of sample playback.</LI>
        <LI>MXPLG_SYNC_END
		<br>Synchronisation triggers at the end of sample playback.</LI>
        <LI>MXPLG_SYNC_LOOP
		<br>Synchronisation triggers every time sample playback loops.</LI>
        <LI>MXPLG_SYNC_START_AND_LOOP
		<br>Synchronisation triggers at the start of sample playback and every time sample
            playback loops.</LI>
        </UL>
      <LI><p>MXPLG_SYNC_ONE / MXPLG_SYNC_INCREMENT / MXPLG_SYNC_DECREMENT /
        MXPLG_SYNC_DEFERRED
		<br>These four constants determine the type of synchronisation used by the
        synchronisation plugin.</p></LI>
        <UL>		
		<LI>MXPLG_SYNC_ONE
		<br>When synchronisation triggers, the address associated with the synchronisation plugin is
            set to the word value 1.</LI>
        <LI>MXPLG_SYNC_INCREMENT
		<br>When synchronisation triggers, the address associated with the synchronisation plugin is
            increased by the word value 1.</LI>
        <LI>MXPLG_SYNC_DECREMENT
		<br>When synchronisation triggers, the address associated with the synchronisation plugin is
            decreased by the word value 1.</LI>
        <LI>MXPLG_SYNC_DEFERRED
		<br>When synchronisation triggers, the address associated with the synchronisation plugin is
            called as a deferred plugin routine.</LI>
	    </UL>
   </UL>
   <p>Variable info follows:</p>
   <UL>
      <LI><p>mxplg_max_idata_size
        <br>This variable contains the maximum size of any of the built-in
        plugin's initialisation data structure.</p></LI>

      <LI><p>mxplg_max_data_size
        <br>This variable contains the maximum size of any of the built-in
        plugin's data structure.</p></LI>
   </UL>
   <p>Structure info follows:</p>
   <UL>
      <LI><p>MXPDPitchInitData
	  <br>This structure contains the initialisation data for the pitch change plugin</p>
	  <p>The MXPDPitchInitData structure has the following members:</p>
	  <UL>
        <LI><p>mpid_pit_mode
		<br>The mode to use for the pitch plugin. Either <em>MXPLG_PITCH_STANDARD</em> or
            <em>MXPLG_PITCH_LOWQUALITY</em>. The latter is much faster, but also results in lower quality
            output.</p></LI>
        <LI><p>mpid_pit_precalc
		<br>Whether or not the values in the <em>MXEffect</em> structure contain pre-calculated values for
            the altered pitch sample's new length and loop offset. Set using either
            <em>MXPLG_PITCH_NO_PRECALC</em> or <em>MXPLG_PITCH_PRECALC</em>. If set to the former,
            the initialisation routine will calculate the  new length & loop offset for the <em>MXEffect</em>
            structure in real time, which costs extra CPU time. (note that the plugin routine itself is
            unaffected)</p></LI>
        <LI><p>mpid_pit_ratio_fp8
		<br>The ratio to change the pitch by, given as a 8.8 fixed point math number. The new sample
            pitch will be multiplied so a ratio of 0.5 will halve the sample's pitch, while a ratio
            of 2.0 will double the pitch (etc).</p></LI>
        <LI><p>mpid_pit_length
		<br>If <em>MXPLG_PITCH_PRECALC</em> is set, this field has to contain the original length of the sample,
            without pitch shift.</p></LI>
        <LI><p>mpid_pit_loop_offset
		<br>If <em>MXPLG_PITCH_PRECALC</em> is set, this field has to contain the original loop offset of the
            sample, without pitch shift.</p></LI>
      </UL>
      </LI>

      <LI><p>MXPDVolumeInitData
	  <br>This structure contains the initialisation data for the volume change plugin</p>
	  <p>The MXPDVolumeInitData structure has the following members:</p>
	  <UL>
         <LI><p>mpid_vol_mode
		 <br>The mode to use for the volume plugin. Either <em>MXPLG_VOL_TABLE</em> or <em>MXPLG_VOL_SHIFT</em>.
             The former uses a lookup table (byte based) to change the volume, the latter uses shift
             instructions.</p></LI>
		 <LI><p>mpid_vol_volume
		 <br>The desired volume. For table lookups, this ranges from 0 (silence) to 15 (maximum 
             volume). In case of shifts, this ranges from 0 (maximum volume) to 8 (silence)</p>

             <p>Note that the shift value for silence is dependent on the mixer mode and the number
                of channels the mixer can mix (as set in mixer_config.i)</p>

             <p><PRE>               Shift value for silence
HQ Mode/1-4 channels      8
Normal/1 channel       	  8
Normal/2 channels         7
Normal/3 channels         7
Normal/4 channels         6</PRE></p></LI>
      </UL>
	  </LI>
      <LI><p>MXPDRepeatInitData
	  <br>This structure contains the initialisation data for the repeat plugin</p>
	  <p>The MXPDRepeatInitData structure has the following members:</p>
	  <UL>
         <LI><p>mpid_rep_delay
		 <br>The desired delay in mixer ticks. Mixer ticks occur roughly once per frame, when the
             mixer interrupt triggers.</p></LI>
      </UL>
	  </LI>
      <LI><p>MXPDSyncInitData
	  <br>This structure contains the initialisation data for the synchronisation plugin</p>
	  <p>The MXPDSyncInitData structure has the following members:</p>
	  <UL>
         <LI><p>mpid_snc_address
		 <br>Set to the location in memory to use as output for the synchronisation plugin. This
             location has to be 1 word wide.</p></LI>
         <LI><p>mpid_snc_mode
		 <br>Set to the desired synchronisation mode. Several modes are available</p>
		 <UL>
            <LI>MXPLG_SYNC_DELAY
            <br>Triggers every mpid_snc_delay ticks</LI>
            <LI>MXPLG_SYNC_DELAY_ONCE
            <br>Triggers once, after mpid_snc_delay ticks</LI>
            <LI>MXPLG_SYNC_START
            <br>Triggers once, at the start of playback</LI>
            <LI>MXPLG_SYNC_END
            <br>Triggers once, at the end of playback</LI>
            <LI>MXPLG_SYNC_LOOP
            <br>Triggers every time playback loops</LI>
            <LI>MXPLG_SYNC_START_AND_LOOP
            <br>Triggers at the start of playback and again every time playback loops</p></LI>
		 </UL></LI>
         <LI><p>mpid_snc_type
		 <br>Set to the desired synchronisation type. Several types are available</p>
		 <UL>
            <LI>MXPLG_SYNC_ONE
            <br>Writes the value one to the target address</LI>
            <LI>MXPLG_SYNC_INCREMENT
            <br>Increments the contents of the word at the target address by one</LI>
            <LI>MXPLG_SYNC_DECREMENT
            <br>Decrements the contents of the word at the target address by one</LI>
            <LI>MXPLG_SYNC_DEFERRED
            <br>Instead of changing the word at <em>mpid_snc_address</em>, this mode uses the
            address in <em>mpid_snc_address</em> as the address of a deferred plugin function,
            which will be called at the end of any interrupt in which the chosen sync mode
            triggers.</LI>
		 </UL></LI>
         <LI><p>mpid_snc_delay
		 <br>The desired delay in mixer ticks. Mixer ticks occur roughly once per frame, when the mixer
             interrupt triggers.</p></LI>
      </UL>
	  </LI>
   </UL>
   <p>Support routine info follows:</p>
   <UL>
      <LI><p><em>D0=MixerPluginGetMaxInitDataSize()</em>
        This routine returns the maximum size of any of the built in plugin
        initialisation data structures.</p></LI>

      <LI><p><em>D0=MixerPluginGetMaxDataSize()</em>
        This routine returns the maximum size of any of the built in plugin
        data structures.</p></LI>
        
      <LI><p><em>D0=MixPluginGetMultiplier()</em>
        <br>This routine returns the type of sample size multiple the mixer
        expects. This can be used instead of <em>MixerGetSampleMinSize()</em> if the
        actual value is not relevant, only whether or not it's 4x, 32x or 
        (buffer_size)x.</p>

        <p>Returns either <em>MXPLG_MULTIPLIER_4</em>, <em>MXPLG_MULTIPLIER_32</em> or
        <em>MXPLG_MULTIPLIER_BUFSIZE</em>.</p></LI>

      <LI><p><em>MixPluginRatioPrecalc(A0=effect_structure, D0=pitch_ratio, D1=shift_value)</em>
        <br>This routine can be used to pre-calculate length and loop offset
        values for plugins that need these values divided by a FP8.8 ratio.
        The routine calculates the values using a pointer to a filled <em>MXEffect</em>
        structure in A0, the ratio value in D0 and the shift value in D1.</p>

        <p>Currently this routine is only used by/for <em>MixPluginPitch()</em>.</p>

        <p>Note: the shift value passed to the routine is used to scale the input
              to create a greater range than would normally be allowed. At a
              shift of zero, the routine supports input & output values of up
              to 65535. Increasing the shift value will increase these limits
              by a factor of 2^shift factor, at a cost of an ever increasing
              inaccuracy.</p></LI>
   </UL>
   <p>Built in plugin info follows:</p>
   <UL>
   <p>Because each plugin uses both an initialisation routine and a plugin
   routine and the calling convention of each of these routines is always the
   same, the initialisation and plugin routines will be described without
   function prototypes and instead show the correct way to set up the <em>MXPlugin</em>
   structure for the mixer instead, as well as describe the functionality of
   the plugin, which initialisation data structure to use and how to fill it.</p>
      <UL>
   <LI><p><em>MixPluginInitDummy()</em> / <em>MixPluginDummy()</em>
     <br>This plugin performs no function and changes no data. It can be used in
     place of calling an actual plugin to test plugin functionality, or as a
     NO-OP plugin if the code written to call <em>MixerPlayFX()</em> or 
     <em>MixerPlayChannelFX()</em> in a specific program always wants to pass a plugin,
     even if this is not required for the sample to be played.</p>

     <p>MXPlugin setup</p>
	 <UL>
       <LI>mpl_plugin_type
	   <br>Determines the type of plugin. Either <em>MIX_PLUGIN_STD</em> or <em>MIX_PLUGIN_NODATA</em></LI>
	   <LI>mpl_init_ptr
	   <br>Pointer to <em>MixPluginInitDummy()</em></LI>
	   <LI>mpl_plugin_ptr
	   <br>Pointer to <em>MixPluginDummy()</em></LI>
       <LI>mpl_init_data_ptr
       <br>contents of this field are ignored</LI>
	 </UL>

   <LI><p><em>MixPluginInitRepeat()</em> / <em>MixPluginRepeat()</em>
     <br>This plugin repeats playback of the sample specified after a given delay.
     It makes use of the <em>MXPDRepeatInitData</em> structure to pass its parameter.</p>

     <p>See the section Structures above for information how to set up this
     structure.</p>

     <p>MXPlugin setup</p>
	 <UL>
	    <LI>mpl_plugin_type
		<br>Set to <em>MIX_PLUGIN_NODATA</em></LI>
	    <LI>mpl_init_ptr
		<br>Pointer to <em>MixPluginInitRepeat()</em></LI>
	    <LI>mpl_plugin_ptr
		<br>Pointer to <em>MixPluginRepeat()</em></LI>
	    <LI>mpl_init_data_ptr
		<br>Pointer to instance of structure <em>MXPDRepeatInitData</em></LI>
     </UL>

   <LI><p><em>MixPluginInitSync()</em> / MixPluginSync()</em>
     <br>This plugin is used to give synchronisation/timing information to the
     program playing back samples using the mixer. If offers various modes and
     types of this information. When the mode/type of the synchronisation 
     plugin triggers, it either writes a value to a given address, or calls
     the routine at this address as a deferred plugin routine.
     The plugin makes use of the <em>MXPDSyncInitData</em> structure to pass its
     parameters.</p>

     <p>See the section Structures above for information how to set up this
     structure.</p>
	 
	 <p>See the section Deferred plugin routine conventions for information on
     how to use deferred plugin routines.</p>

     <p>MXPlugin setup</p>
	 <UL>
	    <LI>mpl_plugin_type
		<br>Set to <em>MIX_PLUGIN_NODATA</em></LI>
	    <LI>mpl_init_ptr 
		<br>Pointer to <em>MixPluginInitSync()</em></LI>
	    <LI>mpl_plugin_ptr
		<br>Pointer to <em>MixPluginSync()</em></LI>
	    <LI>mpl_init_data_ptr
		<br>Pointer to instance of structure <em>MXPDSyncInitData</em></LI>
     </UL>

   <LI><p><em>MixPluginInitVolume()</em> / <em>MixPluginVolume()</em>
     <p>This plugin is used to change the playback volume of the sample
     specified. It operates either by using a lookup table or by using shifts.
     In case of using lookup tables, it supports 16 volume levels: 
     0 = silence, 15 = maximum volume. In case of using shifts, 0 represents
     maximum volume and silence is represented by either 8, 7 or 6 (depending
     on the configured number of software channels per hardware channel).
     The plugin makes use of the <em>MXPDVolumeInitData</EM> structure to pass its
     parameters.</p>

     <p>See the section Structures above for information how to set up this
     structure.</p>

     <p>MXPlugin setup</p>
	 <UL>
	    <LI>mpl_plugin_type
		<br>Set to <em>MIX_PLUGIN_STD</em></LI>
	    <LI>mpl_init_ptr
		<br>Pointer to <em>MixPluginInitVolume()</em></LI>
	    <LI>mpl_plugin_ptr
		<br>Pointer to <em>MixPluginVolume()</em></LI>
	    <LI>mpl_init_data_ptr
		<br>Pointer to instance of structure <em>MXPDVolumeInitData</em></LI>
     </UL>

   <LI><p><em>MixPluginInitPitch()</em> / <em>MixPluginPitch()</em>
     <p>This plugin changes the pitch of the specified sample by a given ratio.
     It offers two modes (standard and low quality) and has an option to speed
     up the initialisation phase by using some pre-calculated values. The
     ratio is given as a fixed point 8.8 value and represents the value to use
     to multiply the original pitch value (so, 0.5 means playing back at half
     pitch, 2.0 means playing back at double pitch, etc).
     The plugin makes use of the <em>MXPDPitchInitData</em> structure to pass its
     parameters.</p>

     <p>See the section Structures above for information how to set up this
     structure.</p>

     <p>Note: using pre-calculated values for length &amp; offset does not increase
           performance of the actual plugin, it only speeds up the
           initialisation that runs when calling <em>MixerPlayFX()</em> or
           <em>MixerPlayChannelFX()</em></p>

     <p>MXPlugin setup:</p>
	 <UL>
	    <LI>mpl_plugin_type
		<br>Set to <em>MIX_PLUGIN_STD</em></LI>
	    <LI>mpl_init_ptr
		<br>Pointer to <em>MixPluginInitPitch()</em></LI>
	    <LI>mpl_plugin_ptr
		<br>Pointer to <em>MixPluginPitch()</em></LI>
	    <LI>mpl_init_data_ptr
		<br>Pointer to instance of structure <em>MXPDPitchInitData</em></LI>
	 </UL>
      </UL>
   </UL>
   <p>Custom plugin routine conventions follow:</p>
   <UL>
   <p>Custom plugins, like regular plugins, consist of up to three routines.
   These are plugin initialisation routines, plugin routines and optionally
   deferred plugin routines. For more information on deferred plugin routines,
   see the section "Deferred plugin routine conventions" further down.</p>
   
   <LI><p>Custom plugin initialisation routine conventions:
     <UL>
     <LI>Initialisation routines have the following parameters:
	    <UL>
         <p>A0 - Pointer to <em>MXEffect</em> structure as passed by <em>MixerPlayFX()</em> or
              <em>MixerPlayChannelFX()</em></p>
         <p>A1 - Pointer to plugin initialisation data structure, as passed by
              <em>MixerPlayFX()</em> or <em>MixerPlayChannelFX()</em></p>
         <p>A2 - Pointer to plugin data structure, as passed by <em>MixerPlayFX()</em> or
              <em>MixerPlayChannelFX()</em>. This block of memory is set up by the
              initialisation routine to contain the data the plugin requires
              to work</p>
         <p>D0 - Hardware channel/mixer channel (f.ex. <em>DMAF_AUD0</em>|<em>MIX_CH1</em>)</p>
		</UL>
     </LI>
     <LI>Depending on what the plugin itself needs, these parameters can be
       omitted / left blank.</LI>
     <LI>Initialisation routines have to preserve all registers</LI>
     <LI>Initialisation routines should limit themselves to setting up the data
       required for use by the plugin and any calculations (etc) to achieve
       this. They should not be used for other purposes.</LI>
     <LI>Initialisation routines can have any name, though following the
       convention in plugins.i of naming them <em>MixPluginInit&lt;plugin name&gt;</em> is
       suggested.</LI>
	 </UL></p>
   </LI> 
   <LI>Custom plugin routine conventions:
      <UL>
      <LI>Plugin routines have the following parameters:
	   <UL>
        <p>A0 - Pointer to the output buffer to use</p>
        <p>A1 - Pointer to the plugin data</p>
        <p>A2 - Pointer to the <em>MXChannel</em> structure for the current channel
             (see note below)</p>
        <p>D0 - Number of bytes to process</p>
        <p>D1 - Loop indicator. Set to 1 if the sample has restarted at the
             loop offset (or at its start in case the loop offset is not
             set)</p>
      <p><h4>Note: the structure passed in A2 is an internal mixer structure which
            may change between versions. Do not alter its contents with any
            plugin routines. It is provided solely to enable calling
            <em>MixerSetPluginDeferredPtr()</em>, if needed.</h4></p>
	   </UL></LI>
      <LI>Depending on what the plugin itself needs, these parameters can be
        omitted / left blank.</LI>
      <LI>Plugin routines have to preserve all registers</LI>
      <LI>Plugin routines are not allowed to call any mixer routine that causes
        a new sample to be played. If this is needed, create a separate
        deferred plugin routine that does call this/these routine(s). Then, in
        the plugin routine call <em>MixerSetPluginDeferredPtr()</em> with the function
        pointer for the deferred plugin routine instead.</LI>
      <LI>Plugin routines should limit themselves to actions required for the
        plugin and attempt to be a frugal as possible with the amount of CPU
        time they use, as they run during the mixer interrupt.
      <LI>Plugin routines can have any name, though following the convention in
        plugins.i of naming them <em>MixPlugin&lt;plugin name&gt;</em> is suggested.</LI>
	  </UL>
   </LI>
   </UL>
   <p>Deferred plugin routine conventions follow:</p>
   <UL>
   <p>Deferred plugin routines can be used to play back new samples from plugins,
   without causing issues with the mixing loop. These routines are sometimes
   needed by custom plugins.</p>
   
   <LI>Deferred plugin routine conventions</LI>
    <UL>
      <LI>Deferred plugin routines have the following parameters:
	   <UL>
        <p>A0 - Pointer to the output buffer in use</p>
        <p>A1 - Pointer to the plugin data</p>
	   </UL>
	  </LI>
      <LI>Depending on what the plugin itself needs, these parameters can be
        omitted / left blank.</LI>
      <LI>Deferred plugin routines have to preserve all registers</LI>
      <LI>Unlike plugin routines, deferred plugin routines are allowed to call
        any mixer routine that causes a new sample to be played.</LI>
      <LI>Deferred plugin routines should limit themselves to actions required
        to play back new samples / after mixing is done and attempt to be as
        frugal as possible with the amount of CPU time they use, as they run
        during the mixer interrupt.</LI>
      <LI>Deferred plugin routines can have any name, though following the
        convention in plugins.asm of naming them
        <em>MixPlugin&lt;plugin name&gt;Deferred</em> is suggested.</LI>
	</UL>
   </UL>		
</UL>

<h3 id="converter_api">Converter API</h3>
<p>The mixer provides an assembly routine to help with converting samples for use
with the mixer at runtime. While this routine does use a lookup table to
improve division speed, it's still relatively slow and thus not recommended 
for use with large amounts of sample data.</p>

<p>If large quantities of sample data need to be converted, consider using the
SampleConverter tool provided to deal with the conversion before runtime
instead.</p>

<p><h4>Routine info follows:</h4></p>
   <UL>
   <LI><p><em>ConvertSampleDivide(A0=source_sample,A1=destination_sample,D0=length,
                         D1=number_of_channels)</em>
     <br>This routine converts the given sample to ensure enough headroom exists
     to mix the sample using the mixer. It has four parameters:</p>

     <UL>
	 <p>A0 - pointer to the start of the source sample</p>
     <p>A1 - pointer to the start of the destination sample (this can be
          identical to the source sample if desired)</p>
     <p>D0 - length of the sample in bytes (note the limitations for sample
          length used by the mixer apply, but are not checked for)</p>
     <p>D1 - the number of channels to be mixed (this is the value of
          <em>mixer_sw_channels</em> from mixer_config.i)</p></UL>

     <p>The conversion routine will work with anywhere from 1 to 4 channels. Note
     that conversion is not needed when running the mixer with
     <em>mixer_sw_channels</em> set to 1 (the routine will simply copy data when it's
     set to 1 channel).</p>
   </UL>

<h3 id="performance_api">Performance measuring API</h3>
<p>If <em>MIXER_CIA_TIMER</em> is set to 1 in mixer_config.i, the mixer provides several
variables and a routine to measure the performance of the mixer using the
CIA-A timer A of the Amiga. In order to correctly measure performance, the
CIA-A timer A has to be available and no interrupts of level 5+ must run, as
those will interrupt the mixer routines and skew the measured results.</p>

<p>Additionally, if <em>MIXER_COUNTER</em> is set to 1 in mixer_config.i, the mixer
provides two new routines to measure the number of mixer interrupts that have
fired since the last counter reset.</p>

<p>In order to measure performance, the mixer interrupt handler must be running
and <em>MixerStart()</em> must have been called. This routine also starts the CIA timer
when it starts the Mixer.</p>

<p>Once <em>MixerStart()</em> has been called, the variables for storing performance will
start to get filled and the interrupt counter starts running.</p>

<p><h4>Variable info follows:</h4></p>
   <UL>
   <LI><p>mixer_ticks_last
     <br>This variable contains the number of CIA timer ticks the last mixer
     interrupt took to complete. It will be filled after at least one such
     interrupt has occurred.</p></LI>

   <LI><p>mixer_ticks_best
     <br>This variable contains the lowest number of CIA timer ticks a mixer
     interrupt has taken to complete to date. In most cases this will
     represent the result of an idle interrupt (i.e. the mixer not playing any
     samples). It will start being updated after at least one mixer interrupt
     has occurred.</p></LI>

   <LI><p>mixer_ticks_worst
     <br>This variable contains the highest number of CIA timer ticks a mixer
     interrupt has taken to complete to date. This is useful to see if mixer
     CPU use causes performance issues. Mixer CPU use varies based on the 
     number of samples being mixed together as well as whether or not (many)
     small* samples are playing/looping. This value will start being updated 
     after at least one mixer interrupt has occurred.</p>

     <p>*) A sample is considered small when its length is (much) smaller than 
        the size of the mixer's playback buffer (either <em>mixer_PAL_buffer_size</em>
        or <em>mixer_NTSC_buffer_size</em> depending on selected video system).</p>

        <p>This effectively means samples that last less than either 1/50th or 
        1/60th of a second.</p></LI>

   <LI><p>mixer_ticks_average
     <br>This variable initially contains no data. It can be filled with the
     average time the mixer interrupt took over the last 128 frames by calling
     the <em>MixerCalcTicks()</em> routine. Once filled, this value gives an indication
     of the number of cycles the mixer takes in normal use in the given 
     program. The underlying values to be able to fill this value start being
     updated in a circular buffer after at least one mixer interrupt has
     occurred.</p>

     <p>Note that this value can also be useful to measure performance of playing
     back a certain combination of (looping) samples over time. Simply run the
     mixer playing back this combination for at least 128 frames, stop the 
     mixer using <em>MixerStop()</em> and then call <em>MixerCalcTicks()</em> to see the average
     performance.</p></LI>
   </UL>
<p><h4>Routine info follows:</h4></p>
   <UL>
   <LI><p><em>MixerCalcTicks()</em>
     <br>This routine calculates the average time the mixer interrupts took over
     the last 128 frames by using a circular buffer. It adds the results of 
     the last 128 frames together and divides it by 128 to get the average and
     store this value in <em>mixer_ticks_average</em>.</p></LI>
   <LI><p><em>MixerResetCounter()</em>
     <br>This routine resets the mixer interrupt counter to 0.</p></LI>
   <LI><p><em>D0=MixerGetCounter()</em>
     <br>This routine gets the current value of the mixer interrupt counter. The
     counter is word sized.</p></LI>
   </UL>

<h3 id="using_c">Using the mixer in C programs</h3>
<p>In order to use the Mixer in C programs, several steps need to be followed:</p>
   <UL>
   <LI>The mixer configuration must be set up in mixer_config.i (<em>MIXER_C_DEFS</em>
     must be set to 1)</LI>
   <LI>mixer.asm must be assembled into an object file</LI>
   <LI>mixer.o must be linked into the C program which is to use the mixer</LI>
   <LI>mixer.h must be included into the C program which is to use the mixer</LI>
   
   <p>Note: mixer.h is designed for VBCC &amp; Bebbo's GCC compiler. Other compilers
         will need a different method for calling the functions. It should be
         possible to make the mixer work with other compilers, but only VBCC 
         and Bebbo's GCC compiler are officially supported.</p>
   </UL>
<p>If the above is done, the mixer API (as described in <a href="#mixer_api">"Mixer API"</a>) becomes 
available to the C program. The C program will now need to follow the steps in
<a href="#using">"Using the mixer"</a> to enable mixing.</p>

<p>The complete function prototypes that can be used by C programs can be found
in mixer.h (note that this is the same set of routines that are offered 
through mixer.i for assembly programs).</p>

<p>As pointed out above, the supplied mixer.h file is designed for use with VBCC
and Bebbo's version of the GCC compiler. To use the mixer using other GCC 
based compilers, a set of calling routines needs to be constructed. 
(these are not provided in this package)</p>

<p><h4>Two examples of how to make these routines follows:</h4></p>
<UL><pre>
// Assumes exec/types.h is available.
// Example for calling MixerGetBufferSize
inline UWORD call_MixerGetBufferSize()
{
   register volatile UWORD _return_value __asm("d0");
   __asm__ volatile
   (
      "jsr MixerGetBufferSize\n"
      // OutputOperands
         : "=d" (_return_value)
      // InputOperands
         : /* no inputs */
      // Clobbers
         : "cc", "memory"
    );
    return _return_value;
}

// Assumes exec/types.h is available.
// Example for calling MixerSetup
inline void call_MixerSetup(void *buffer, UWORD vidsys)
{
   register volatile void *_buffer __asm("a0") = buffer;
   register volatile UWORD _vidsys __asm("d0") = vidsys;
   __asm__ volatile
   (
      "jsr MixerSetup\n"
      // OutputOperands
         : /* no outputs */
      // InputOperands
         : "a" (_buffer), "d" (_vidsys)
      // Clobbers
         : "cc", "memory"
    );
    return ;
}</pre></UL>

<p>Examples courtesy of nivrig and Jobbo over at the AmigaGameDev Discord.</p>

<p>Note that the examples above are provided merely as a starting point. As 
pointed out earlier, C integration with other compilers than VBCC or Bebbo's
GCC compiler is not officially supported.</p>


<h3 id="troubleshooting">Troubleshooting</h3>
<p>This section of the documentation lists some possible problems when using the
mixer and potential solutions to them. In many cases, it can be useful to set
<em>MIXER_TIMING_BARS</em> to 1 in mixer_config.i when troubleshooting as it helps 
identify whether or not the interrupt is running correctly.</p>
<OL>
<LI><p><h4>Issues with startup or shutdown of the mixer or programs using it</h4></p>
   <UL>
   <LI><p>Calling <em>MixerInstallHandler()</em> immediately crashes the system
     <br>This is usually caused by setting a non-zero VBR value on 68000/68010
     based systems (in particular an odd value). Try setting the VBR to 0 if
     running on a 68000 or correct the VBR value if running on a 68010.</p>
     
     <p>Note that some music players do not restore all registers after calling
     their setup routines, which can result in the wrong VBR being passed if
     the <em>MixerInstallHandler()</em> routine is called directly after setting up or
     starting a music player.</p></LI>
     
   <LI><p>Calling <em>MixerStart()</em> does not start the mixer, no interrupts fire
     <br>This is normally caused by setting an incorrect value of the VBR when
     calling <em>MixerInstallHandler()</em>. Check to make sure the correct value is
     passed.</p>
     
     <p>Note that some music players do not restore all registers after calling
     their setup routines, which can result in the wrong VBR being passed if
     the <em>MixerInstallHandler()</em> routine is called directly after setting up or
     starting a music player.</p></LI>
     
   <LI><p>Calling <em>MixerInstallHandler()</em> causes many (hundreds) of interrupts per 
     frame
     <br>This is usually caused by starting a music player that sets the audio
     registers to an initial value even on channels which remain empty. Often
     this is a one word loop, which can cause issues with the mixer as this
     will cause the audio interrupts to trigger extremely frequently.</p>
     
     <p>This can sometimes be solved by disabling the channel for music playback
     using features of the music player chosen. In other cases it can also be
     fixed by manually writing a volume of 0 and a length of several hundred
     bytes in the audio channel(s) used by the mixer immediately prior to 
     calling <em>MixerInstallHandler()</em>.</p>
     
     <p>Calling <em>MixerStart()</em> can also fix this, but in some cases so many
     interrupts are generated that this is not possible.</p></LI>
     
   <LI><p>Calling <em>MixerStart()</em> causes random audio glitches and playing samples
     through the mixer does not work
     <br>This is usually caused by a music player setting or resetting registers
     on channels reserved for use by the mixer. If the channel configuration
     for the mixer is set correctly, the music track used does not use the 
     channel(s) reserved for the mixer and the problem persists:</p>
     <UL>     
     <LI><p>try disabling the music channels in the player</p></LI>
     <LI><p>if the player does not support this, it may be required to patch the
       music player to not touch the audio channels used by the mixer.</p></LI>
     <LI><p>if all else fails, try using one of the two music players that have 
       been verified to work with the mixer: Frank Wille's PTPlayer 6.3+ or
       Arnaud Carr&eacute;'s LSP.</p></LI>
	 </UL>
     
   <LI><p>Calling <em>MixerStart()</em> after interrupting the mixer using <em>MixerStop()</em> does
     not restart samples/loops that were playing before
     <br>This is a known limitation of the mixer, calling <em>MixerStop()</em> clears all
     mixer samples still in progress.</p></LI>

   <LI><p>Exiting a program that uses the mixer to the OS does not stop looping /
     playing samples
     <br>This is caused by the mixer still running when the program exists. Call
     <em>MixerStop()</em> and <em>MixerRemoveHandler()</em> prior to exiting the program.</p></LI>

   <LI><p>Exiting a program that uses the mixer to the OS causes a crash or
     unexpected behaviour when another program is used later to play back
     sound
     <br>This is caused by not resetting the previously used interrupt vector for
     the audio interrupt to it's original vector (i.e. the one in use prior to
     starting the program the uses the mixer). Normally this can be fixed by
     calling <em>MixerInstallHandler()</em> with D0 set to 0 to make sure interrupt
     vector is saved for restoring by <em>MixerRemoveHandler()</em> later.</p>
     
     <p>If having the mixer save/restore the vector in this way is not desired,
     it can also be fixed by manually saving/restoring the audio interrupt 
     vector.</p></LI>
     
   <LI><p>Exiting a program that uses the mixer to the OS causes the keyboard to
     stop working
     <br>This is caused by setting <em>MIXER_CIA_TIMER</em> to 1 in mixer_config.i, but not
     setting <em>MIXER_CIA_KBOARD_RES</em> to 1 in mixer_config.i. Alternatively, it
     can also be caused by setting both these values to 1 in mixer_config.i,
     but either not calling <em>MixerRemoveHandler()</em> or calling it too early.</p>
     
     <p>If OS keyboard restoring is desired in this case, <em>MixerRemoveHandler()</em>
     needs to be called as late as possible. Preferably as one of the last
     things prior to exiting the program and certainly within 2-3 frames
     before the program exits.</p></LI></UL>

<LI><p><h4>Issues with sample playback</h4></p>
   <UL>
   <LI><p>Playing back a sample through the mixer causes the system to crash
     <br>This is caused by running on a 68000/68010 based system and playing a 
     sample stored on an odd address in memory.</p></LI>
     
   <LI><p>Playing a single sample back through the mixer sounds fine, playing
     multiple samples through the mixer at the same time results in heavily
     distorted audio
     <br>This is caused by not properly pre-processing the samples. See <a href="#pre-processing">"Pre-
     processing samples"</a> for more information.</p></LI>

   <LI><p>Samples played back through the mixer are very quiet
     <br>This can be caused by pre-processing the samples more than once, or by
     using samples that were quiet to begin with. Note that apparent sample
     playback volume using the mixer will always be lower than not using the
     mixer due to the way the mixer works, but it can be made worse by using
     samples that themselves are quiet to begin with.</p>
     
     <p>For more information on generating/choosing samples for use with the
     mixer in such a way that this problem is minimized, see <a href="#best_practices">"Best practices 
     for source samples"</a>.</p></LI>

   <LI><p>Samples played back through the mixer are cut off prematurely or have an
     audible pop/tick/glitch at the end
     <br>The mixer plays back samples in blocks. These blocks are either 4 bytes,
     32 bytes or <em>mixer_PAL_buffer_size</em> (<em>mixer_NTSC_buffer_size</em> when running on
     a NTSC system) in length. The length of the block is determined by how
     the mixer_config.i file is set up.</p>
     
     <p>The consequence of the mixer using blocks of bytes is that samples 
     themselves must also be multiples of this block size. To fix the audio
     glitches, make sure that the samples are a multiple of this block size in
     length by padding them to the nearest multiple with bytes filled with 0.</p>
     
     <p>Note that the supplied SampleConverter tool automatically pads samples
     with zeroes to a multiple of 4 bytes.</p></LI>
     
   <LI><p>Samples played back in a loop don't loop seamlessly or have odd 
     repetition timing
     <br>The mixer plays back samples in blocks. These blocks are either 4 bytes,
     32 bytes or <em>mixer_PAL_buffer_size</em> (<em>mixer_NTSC_buffer_size</em> when running on
     a NTSC system) in length. The length of the block is determined by how
     the mixer_config.i file is set up.</p>
     
     <p>The consequence of the mixer using blocks of bytes is that loops are 
     also played back in multiples of this block size. This means that a 
     seamless loop must be an exact multiple of the block size in length. If
     the samples are padded with zeroes to a multiple of the block size, those
     empty bytes will still get played, which can alter the timing of the 
     loop.</p></LI>
     
   <LI><p>Playing back very short samples in loops uses a lot of CPU time
     <br>Very short* looping samples require the mixer to potentially run the
     mixing loop in smaller increments and/or more often. This increases CPU
     overhead. To solve this issue, either play back longer loops or set
     <em>MIXER_SIZEX32</em> to 1. This forces the mixer to always mix in blocks of 32
     bytes, which is faster than looping smaller amounts.</p>
     
     <p>Note however that this setting does also imply that samples have to be
     multiples of 32 bytes in size.</p>
     
     <p>*) for this purpose, "very short" is technically any sample that is less
        long than the amount of bytes played per frame by the mixer. The
        shorter samples get below this threshold, the more CPU time they will
        use to play back in a loop.</p></LI>
     
   <LI><p>When playing back multiple looping samples at the same time, no other
     samples will play
     <br>The mixer will not overwrite looping samples with other samples, even if
     they are of higher priority. To stop a looping sample, use the 
     <em>MixerStopFX()</em> routine with the hardware/mixer channel combination the
     loop is playing on. </p>
     
     <p>If all mixer channels are playing looping samples, stopping one or more
     of them will allow other samples to play again.</p></LI></UL>
	 
<LI><p><h4>Callback issues</h4></p>
	<UL>
	<LI><p>The callback function set does not fire when samples end
     <br>This is usually caused by not having enabled callback functionality in
     mixer_config.i. To enable callback functionality, set 
     <em>MIXER_ENABLE_CALLBACK</em> to 1 in mixer_config.i</p></LI>
	<LI><p>The callback function does not trigger when samples loop, nor when 
     <em>MixerStop()</em> or <em>MixerStopFx()</em> is called
	 <br>Callbacks only trigger when a sample stops playback by reaching its end,
     they do not trigger when samples loop, or are ended by calling 
     <em>MixerStop()</em> or <em>MixerStopFx()</em>.</p></LI>
	<LI><p>The callback function does trigger, but new samples played back by it do
     not seamlessly follow the end of the old sample
	 <br>This is caused by not playing back the new sample correctly. In order to
     get seamless playback, the callback routine has to play the new sample on
     the same mixer channel as the old sample just ended on. Then, it needs to
     set D0 to 1 as a return value prior to returning.</p>
	<LI><p>When a callback triggers, the mixer either crashes or starts behaving in
     a weird way
	 <br>This is either caused by not properly saving and restoring all registers
     other than D0, or by setting D0 to a non-zero value prior to returning 
     while not starting a new sample on the channel of the sample that just
     ended playback.</p></LI>
	</UL>
<LI><p><h4>Plugin issues</h4></p>
	<UL>
	<LI><p>Plugins attached to samples do not activate
     <br>This is either caused by not having plugin support enabled in
     mixer_config.i, by setting the <em>mfx_plugin_ptr</em> to 0 (or NULL in C
     programs) or by not filling the </em>MXPlugin structure correctly.</p></LI>
	<LI><p>When a plugin is attached to a sample, the mixer plays silence for that
     sample
	 <br>This is caused by setting <em>mpl_plugin_type</em> to <em>MIX_PLUGIN_STD</em> for plugins
     that do not output data. Set <em>mpl_plugin_type</em> to <em>MIX_PLUGIN_NODATA</em> for
     these type of plugins.</p>
	 
	 <p>Alternatively, this can also be caused by setting the plugin 
     initialisation data to values that cause silent output, such as setting
     the volume plugin to table lookup with volume 0.</p></LI>
	<LI><p>When a built-in plugin is attached to a sample, the mixer crashes, the
     plugin behaves weirdly or the mixer behaves weirdly
	 <br>This is usually caused by setting up the <em>MXPlugin</em> structure incorrectly.</p>
	 <p>Here are some possible problems:</p>
		<UL>
        <LI>the pointer set in <em>mfx_plugin_ptr</em> is not pointing to the correct
          location</LI>
		<LI>the pointer(s) set in either <em>mpl_init_ptr</em>, <em>mpl_plugin_ptr</em> or 
          <em>mpl_init_data_ptr</em> are not correct</LI>
		</UL></LI>
	<LI><p>When a custom plugin is attached to a sample, the mixer crashes, the
     plugin behaves weirdly or the mixer behaves weirdly
	 <br>This can have various reasons, the most common ones are:</p>
	 <UL>
        <LI>There are issues in the set up of the <em>MXPlugin</em> structure, such as
          the ones named in the problem above</LI>
        <LI>The custom plugin attempts to play back new samples without using a
          a deferred plugin routine</LI>
        <LI>The custom plugin does not correctly save and restore registers</LI>
        <LI>The custom plugin initialisation data was not correct</LI>
        <LI>The custom plugin inadvertently takes so much CPU time that the
          mixer interrupt starts to overrun the starting time of the next
          interrupt</LI>
        <LI>The custom plugin routine might require a 68020 or better and is
          being used on a 68000</LI>
	 </UL></LI>
	<LI><p>CPU use goes up dramatically when playing back (several) samples using
     the Volume or Pitch plugins
	 <br>These plugins use a lot of CPU time, especially on a 7MHz 68000.</p></LI>
	<LI><p>When using the Pitch plugin, the sample's pitch does not sound correct or
     it has odd distortions
     <br>The Pitch plugin resamples the sample data to a new pitch given a ratio.
     This is unlike module players or manually playing back samples, in which
     case changing pitch means changing the playback period. Resampling can
     introduce aliasing, which is the cause behind the incorrect pitch or odd
     distortions heard.</p>
	 <p>To limit aliasing, make sure that the period of the mixer is set high 
     enough to correctly play back the highest frequency sample post pitch
     change. This can be done by either limiting the ratio of pitch change
	 applied, or by doing spectrum analysis of the sample in audio processing
     software and adjusting the mixer playback period based on that.</p>
	 <p>Note that the low quality Pitch change mode is much more likely to cause
     these kind of distortions.</p></LI>
	</UL>
<LI><p><h4>Other issues</h4></p>
   <UL>
   <LI><p>The makefile does not work / gives errors
     <br>The makefile was created to work on Windows based systems, on other OS's
     the paths need to be changed to use the correct slash type. Similarly,
     the makefile was created to work using VASM, VLINK and VBCC and expects 
     them in the path. If the makefile is changed to use a different 
     assembler, linker or compiler is chosen, the makefile might need further
     changes.</p>
	 <p>Note that a makefile_unix.mak file is provided that does use the correct
     slashes and uses standard Unix commands for file access. Try using this
     file, editting it as needed.</p></LI>
     
   <LI><p>Assembling the mixer generates messages and results in a non-working
     object file
     <br>This is caused by a non-valid configuration in mixer_config.i. Check the
     number of channels selected, the output channels selected and whether
     only one mixer type has been configured.</p></LI>
     
   <LI><p>Assembling the mixer generates assembler errors
     <br>This can be caused by using a different assembler than VASM. In 
     particular, the mixer.asm file uses the echo directive and many macro's.
     The use of the echo directive can be disabled in mixer_config.i, the 
     macro's are integral to the mixer.</p>
     
     <p>In case of issues, it's recommended to use VASM &amp; VLINK to assemble and
     link the mixer instead of other assemblers/linkers.</p></LI>
     
   <LI><p>On a 68020+ system, performance is much lower than expected
     <br>This is caused by either not setting <em>MIXER_68020</em> to 1 in mixer_config.i,
     or by having either the mixer buffers or sample source data not aligned on
     4 byte boundaries.</p>
     
     <p>For optimal performance on 68020+ systems, set <em>MIXER_68020</em> to 1 in
     mixer_config.i and make sure the mixer buffers and all samples used are
     aligned on 4 byte boundaries.</p></LI>
     
   <LI><p>The mixer does not work correctly on a highly expanded system and/or
     causes issues on FPGA based systems / emulators
     <br>The mixer has been designed to enable fast mixing on low end Amiga
     systems. It should be compatible across a large number of configurations,
     but certain setups may cause issues.</p>
     
     <p>In particular, highly expanded Amiga's might contain expansions that are
     incompatible with disabling the OS. In this case, disable the expansions
     or try using a wrapper such as WHDLoad. In case of hardware CPU emulators
     such as the PiStorm, make sure it is set up to be as compatible as
     possible.</p>
     
     <p>Another possible issue can arise with emulators or FPGA systems. On such
     environments, it is required that the Amiga chipset and 68000 must be 
     emulated/implemented in a compatible manner. Try setting the emulator or
     FPGA system used to the most compatible settings possible (for instance,
     the mixer will run just fine on WinUAE when it is set to cycle exact mode
     and does not have JIT active).</p>
     
     <p>If setting your FPGA system/emulator of choice to its most compatible 
     settings does not solve the issue, contact the creator of the emulator / 
     FPGA system for support.</p></LI></UL>
</OL>

<h3 id="performance_data">Performance data</h3>
<p>The performance of the mixer depends on the chosen configuration and target
system. To give an idea of what performance to expect, results for several
period values and other settings have been compiled into a table, which is
included below. The value given is the percentage of CPU time used per frame.</p>

<p>Note that performance figures for <em>MIXER_MULTI=1</em> also apply to 
<em>MIXER_MULTI_PAIRED=1</em> and are the results for playing back on a single hardware
channel. Adding extra hardware channels basically scales linearly.</p>

<p>For reference, the results of the previous version of the mixer (2.0) are also
included. Note that these are slightly worse than reported on the website or
in the example program for mixer version 2.0. The difference is due to a new
method for measuring performance. The old method incorrectly excluded part of
the overhead involved in dealing with the interrupt and setting hardware
registers.</p>

<p><h4>About the used configurations &amp; systems:</h4></p>
<UL>
<p>Standard   = no optimisations enabled
<br>Optimised  = <em>MIXER_SIZEXBUF</em>=1 and <em>MIXER_WORDSIZED</em>=1</p>
<p>Note that on systems with a 68020+, optimised has MIXER_68020=1 set instead</p>

<p>A500/slow  = 68000@7MHz, 512KB Chip RAM / 512KB Slow RAM*
<br>A500/fast  = 68000@7MHz, 512KB Chip RAM / 512KB Fast RAM
<br>A1200/chip = 68020@14MHz, 2MB Chip RAM
<br>A1200/fast = 68020@14MHz, 2MB Chip RAM / 8MB Fast RAM
<br>A1200/030  = 68030@50MHz, 2MB Chip RAM / 16MB Fast RAM</p>

<p>*) i.e. a standard trapdoor RAM expansion</p>
</UL>
<p><h4>Results for mixer without callback or plugin support</h4></p>
<ul><p><h4>8KHz (period = 443):</h4></p><table>
<tr><th>Standard</th><th>A500/slow</th><th>A1200/chip</th></tr>
<tr><td>Single 3 chan</td><td>2,5%</td><td>1,3%</td></tr>
<tr><td>Single 4 chan</td><td>3,0%</td><td>1,5%</td></tr>
<tr><td>Single 3 chan (HQ)</td><td>8,4%</td><td>3,6%</td></tr>
<tr><td>Single 4 chan (HQ)</td><td>9,9%</td><td>4,4%</td></tr>
<tr><td>Multi 3 chan</td><td>2,6%</td><td>1,3%</td></tr>
<tr><td>Multi 4 chan</td><td>3,1%</td><td>1,6%</td></tr>
<tr><td>Multi 3 chan (HQ)</td><td>8,5%</td><td>3,7%</td></tr>
<tr><td>Multi 4 chan (HQ)</td><td>10,0%</td><td>4,4%</td></tr>
</table><br><table>
<tr><th>Optimised</th><th>A500/slow</th><th>A1200/chip</th></tr>
<tr><td>Single 3 chan</td><td>2,2%</td><td>1,3%</td></tr>
<tr><td>Single 4 chan</td><td>2,7%</td><td>1,5%</td></tr>
<tr><td>Multi 3 chan</td><td>2,3%</td><td>1,3%</td></tr>
<tr><td>Multi 4 chan</td><td>2,8%</td><td>1,6%</td></tr>
</table></ul>

<ul><p><h4>11KHz (period = 322):</h4></p><table>
<tr><th>Standard</th><th>A500/slow</th><th>A1200/chip</th><th>A500/fast</th><th>A1200/fast</th><th>A1200/030</th></tr>
<tr><td>Single 3 chan</td><td>3,0%</td><td>1,5%</td><td>2,9%</td><td>0,9%</td><td>0,5%</td></tr>
<tr><td>Single 4 chan</td><td>3,7%</td><td>1,9%</td><td>3,7%</td><td>1,0%</td><td>0,5%</td></tr>
<tr><td>Single 3 chan (HQ)</td><td>11,1%</td><td>4,7%</td><td>11,1%</td><td>4,0%</td><td>1,4%</td></tr>
<tr><td>Single 4 chan (HQ)</td><td>13,1%</td><td>5,7%</td><td>3,5%</td><td>1,0%</td><td>0,5%</td></tr>
<tr><td>Multi 3 chan</td><td>3,1%</td><td>1,6%</td><td>3,0%</td><td>0,9%</td><td>0,5%</td></tr>
<tr><td>Multi 4 chan</td><td>3,8%</td><td>1,9%</td><td>3,7%</td><td>1,0%</td><td>0,6%</td></tr>
<tr><td>Multi 3 chan (HQ)</td><td>11,2%</td><td>4,8%</td><td>10,9%</td><td>4,0%</td><td>1,5%</td></tr>
<tr><td>Multi 4 chan (HQ)</td><td>13,2%</td><td>5,8%</td><td>12,9%</td><td>4,7%</td><td>1,7%</td></tr>
</table><br><table>
<tr><th>Optimised</th><th>A500/slow</th><th>A1200/chip</th><th>A500/fast</th><th>A1200/fast</th><th>A1200/030</th></tr>
<tr><td>Mixer 2.0 4ch</td><td>3,4%</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
<tr><td>Single 3 chan</td><td>2,7%</td><td>1,5%</td><td>2,7%</td><td>0,8%</td><td>0,4%</td></tr>  
<tr><td>Single 4 chan</td><td>3,4%</td><td>1,9%</td><td>3,4%</td><td>1,0%</td><td>0,5%</td></tr>
<tr><td>Multi 3 chan</td><td>2,8%</td><td>1,6%</td><td>2,7%</td><td>0,8%</td><td>0,5%</td></tr>
<tr><td>Multi 4 chan</td><td>3,5%</td><td>1,9%</td><td>3,4%</td><td>0,9%</td><td>0,5%</td></tr>
</table>
Entries marked as n.a. were not measured (but can be configured/work).</ul>

<ul><p><h4>22KHz (period = 161):</h4></p><table>
<tr><th>Standard</th><th>A500/slow</th><th>A1200/chip</th><th>A500/fast</th><th>A1200/fast</th><th>A1200/030</th></tr>
<tr><th>Single 3 chan</td><td>4,9%</td><td>2,5%</td><td>4,9%</td><td>1,4%</td><td>0,7%</td></tr>
<tr><th>Single 4 chan</td><td>6,2%</td><td>3,2%</td><td>6,2%</td><td>1,6%</td><td>0,8%</td></tr>
<tr><th>Single 3 chan (HQ)</td><td>20,7%</td><td>8,8%</td><td>20,8%</td><td>7,6%</td><td>2,6%</td></tr>
<tr><th>Single 4 chan (HQ)</td><td>24,8%</td><td>10,6%</td><td>24,8%</td><td>9,0%</td><td>3,6%</td></tr>
<tr><th>Multi 3 chan</td><td>5,0%</td><td>2,6%</td><td>4,8%</td><td>1,5%</td><td>0,9%</td></tr>
<tr><th>Multi 4 chan</td><td>6,3%</td><td>3,1%</td><td>6,1%</td><td>1,6%</td><td>0,9%</td></tr>
<tr><th>Multi 3 chan (HQ)</td><td>20,8%</td><td>8,8%</td><td>20,3%</td><td>7,6%</td><td>2,6%</td></tr>
<tr><th>Multi 4 chan (HQ)</td><td>25,0%</td><td>10,7%</td><td>24,3%</td><td>9,0%</td><td>3,6%</td></tr>
</table><br><table>
<tr><th>Optimised</th><th>A500/slow</th><th>A1200/chip</th><th>A500/fast</th><th>A1200/fast</th><th>A1200/030</th></tr>
<tr><th>Single 3 chan</td><td>4,7%</td><td>2,5%</td><td>4,7%</td><td>1,3%</td><td>0,7%</td></tr>
<tr><th>Single 4 chan</td><td>5,9%</td><td>3,2%</td><td>5,6%</td><td>1,6%</td><td>0,8%</td></tr>
<tr><th>Multi 3 chan</td><td>4,8%</td><td>2,6%</td><td>4,6%</td><td>1,3%</td><td>0,7%</td></tr>
<tr><th>Multi 4 chan</td><td>6,0%</td><td>3,3%</td><td>5,8%</td><td>1,6%</td><td>0,8%</td></tr>
</table></ul>
<p><h4>Results for mixer with callback and/or plugin support</h4></p>
<ul><table>
<tr><th>Standard</th><th>A500/slow</th><th>A1200/chip</th><th>A500/fast</th><th>A1200/fast</th><th>A1200/030</th></tr>
<tr><th>Callback (idle)</td><td>3,7%</td><td>2,0%</td><td>3,7%</td><td>1,0%</td><td>0,5%</td></tr>
<tr><th>Plugin (idle)</td><td>4,1%</td><td>2,3%</td><td>4,0%</td><td>1,1%</td><td>0,6%</td></tr>
<tr><th>Callback + plugin (idle)</td><td>4,1%</td><td>2,3%</td><td>4,0%</td><td>1,1%</td><td>0,6%</td></tr>
</table>
<p>Tests done @11KHz, 4 mixer channels, 1 hardware channel</p></ul>
<p><h4>Results for supplied plugins</h4></p>
<ul><table>
<tr><th>Standard</th><th>A500/slow</th><th>A1200/chip</th><th>A500/fast</th><th>A1200/fast</th><th>A1200/030</th></tr>
<tr><th>Repeat</td><td>4,4%</td><td>2,5%</td><td>4,4%</td><td>1,2%</td><td>0,7%</td></tr>
<tr><th>Sync</td><td>4,8%</td><td>2,8%</td><td>4,8%</td><td>1,3%</td><td>0,7%</td></tr>
<tr><th>Volume (table)</td><td>24,9%</td><td>11,1%</td><td>24,8%</td><td>7,1%</td><td>2,9%</td></tr>
<tr><th>Volume (shift)</td><td>25,4%</td><td>10,8%</td><td>25,4%</td><td>6,9%</td><td>2,7%</td></tr>
<tr><th>Pitch (Low Quality)</td><td>17,0%</td><td>6,1%</td><td>17,0%</td><td>3,8%</td><td>1,8%</td></tr>
<tr><th>Pitch (Standard)</td><td>32,6%</td><td>11,1%</td><td>32,6%</td><td>6,9%</td><td>2,7%</td></tr>
</table>
<p>Tests done @11KHz, 4 mixer channels, 1 hardware channel. Plugins active on all
4 channels</p></ul>

<h3 id="best_practices">Best practices for source samples</h3>
<p>In order to get the best possible results out of the mixer, the samples used
by the mixer should be chosen/designed around the way the mixer works. The
primary issue when playing back sounds through the mixer is that the apparent
volume of samples that are played back goes down due to the required pre-
processing.</p>
<p>Note: running the mixer in HQ mode resolves these issues without needing to
      deal with special audio quality requirements for samples. This does use
      much more CPU time, though.</p>
<p><h4>There are two ways to deal with this issue:</h4></p>
<OL>
<LI><p>lower the maximum number of samples mixed together by lowering 
   <em>mixer_sw_channels</em> in mixer_config.i. This will allow pre-processing samples
   for fewer voices, which will increase the apparent volume. The obvious
   drawback of this approach is that the mixer will support playing back fewer
   samples at the same time.</p></LI>
   
<LI><p>use audio processing software to lower the dynamic range of the samples and
   push them as close as possible to maximum volume. This can be done using 
   both compressors, limiters and "loudness-normalising"*.</p>
   
   <p>*) Note that this is not the same as "normalising", which doesn't change 
      perceived loudness.</p>
</OL>	  
<p>Other than the above methods, the best practice is to generate/choose source
samples that are "as loud as possible" and have fairly low dynamic range. This
does not mean that samples can't have dynamic range, but be aware that the 
mixer works best with samples that do not have large swings in volume.</p>

<p>A second issue that is faced by samples played back by the mixer is that the
signal to noise ratio will be worse due to the lower number of effective bits
the mixer has available for samples, while the output hardware and it's limits
have not changed. As such, it's recommended to avoid using samples that
require a very low signal to noise ratio to sound well.</p>


<h3 id="acknowledgements">Acknowledgements</h3>
<p>The mixer examples use some code made by others and use music and samples made
by others as well. In addition to that, several people have helped me during
the development of the mixer. In this section, I show my appreciation for the
help and free resources offered by these people.</p>

<p><h4>Thanks for advice, help and support during my coding efforts go to:</h4></p>
<UL>
   <LI>h0ffman at the AmigaGameDev Discord for testing an early version of the
     mixer and providing feedback and suggestions</LI>
   <LI>nivrig, KaiN and Jobbo at the AmigaGameDev Discord for help integrating
     the mixer in C programs</LI>
   <LI>agermose at the AmigaGameDev discord for providing unsigned 32 to 32 bit
     long division code for use in the plugins</LI>
   <LI>McGeezer for providing the AmigaGameDev Discord</LI>
   <LI>And undoubtedly others I've forgotten!</LI>
</UL>
<p><h4>Thanks for resources and code I've been able to use in this project go to:</h4></p>
<UL>
   <LI>The mixer examples use the module SneakyChick.mod, which was kindly
     provided to me on a freeware/non-commercial use basis by Roald Strauss @
	 IndieGameMusic.com. Further distribution/use of this module requires a
	 license. Visit <a href="https://indiegamemusic.com/">IndieGameMusic.com</a> to license this or one of the many
	 other tracks they provide for use in your own productions.</LI>
   <LI>The mixer examples uses several samples provided on freesound.org under
     the Creative Commons CC0 license. These samples are:
   <UL>
     <LI><a href="https://freesound.org/people/egomassive/sounds/536741/">https://freesound.org/people/egomassive/sounds/536741/</a></LI>
	 <LI><a href="https://freesound.org/people/Daleonfire/sounds/376694/">https://freesound.org/people/Daleonfire/sounds/376694/</a></LI>
	 <LI><a href="https://freesound.org/people/GameAudio/sounds/220173/">https://freesound.org/people/GameAudio/sounds/220173/</a></LI>
	 <LI><a href="https://freesound.org/people/derplayer/sounds/587196/">https://freesound.org/people/derplayer/sounds/587196/</a></LI>
	 <LI><a href="https://freesound.org/people/Latranz/sounds/520200/">https://freesound.org/people/Latranz/sounds/520200/</a></LI>
	 <LI><a href="https://freesound.org/people/NovaSoundTechnology/sounds/118750/">https://freesound.org/people/NovaSoundTechnology/sounds/118750/</a></LI>
	 <LI><a href="https://freesound.org/people/aunrea/sounds/495658/">https://freesound.org/people/aunrea/sounds/495658/</a></LI>
	 <LI><a href="https://freesound.org/people/skymary/sounds/412017/">https://freesound.org/people/skymary/sounds/412017/</a></LI>
   </UL>
	 The full text of the CC0 license can be found here: 
	 <a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">https://creativecommons.org/publicdomain/zero/1.0/legalcode</a></LI>
   <LI>The mixer examples use PT Player 6.3 by Frank Wille, who has released
     this ProTracker player under a public domain license.</LI>
   <LI>The mixer examples use LSP 1.10 by Arnaud Carr&eacute;, who has released this
     ProTracker converter/player under the MIT license.</LI>
   <LI>The mixer plugins use unsigned 32 to 32 bit long division code by
       agermose on the AmigaGameDev discord.</LI>
   <LI>The mixer examples use startup code by Henrik Erlandsson, who has 
     released this code under the MIT license.</LI>
   <LI>The mixer examples use Joystick reading code based on a forum thread on
     eab.abime.net (<a href="https://eab.abime.net/showpost.php?p=986196&postcount=2">https://eab.abime.net/showpost.php?p=986196&postcount=2</a>).</LI>
</UL>	 
<p>Full license information for the PT Player, LSP converter/player and startup
code can be found in LICENSE files included in their respective directories.</p>
     
<h3 id="license">License/Disclaimer</h3>
<p>With exception of the items listed in the <a href="#acknowledgements">"Acknowledgements"</a> section of this
document, all code, documentation and other files fall under the following
license:</p>

<p>Copyright (c) 2023-2024 Jeroen Knoester</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &ldquo;Software&rdquo;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
  </div>
</div>

<footer>
<h4>Copyright (C) 2023, Jeroen Knoester</h4>
</footer>

</body>
</html>
